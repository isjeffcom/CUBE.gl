{"version":3,"file":"lzw-BLf4Plu7.js","sources":["../node_modules/geotiff/dist-module/compression/lzw.js"],"sourcesContent":["import BaseDecoder from './basedecoder.js';\nconst MIN_BITS = 9;\nconst CLEAR_CODE = 256; // clear code\nconst EOI_CODE = 257; // end of information\nconst MAX_BYTELENGTH = 12;\nfunction getByte(array, position, length) {\n    const d = position % 8;\n    const a = Math.floor(position / 8);\n    const de = 8 - d;\n    const ef = (position + length) - ((a + 1) * 8);\n    let fg = (8 * (a + 2)) - (position + length);\n    const dg = ((a + 2) * 8) - position;\n    fg = Math.max(0, fg);\n    if (a >= array.length) {\n        console.warn('ran off the end of the buffer before finding EOI_CODE (end on input code)');\n        return EOI_CODE;\n    }\n    let chunk1 = array[a] & ((2 ** (8 - d)) - 1);\n    chunk1 <<= (length - de);\n    let chunks = chunk1;\n    if (a + 1 < array.length) {\n        let chunk2 = array[a + 1] >>> fg;\n        chunk2 <<= Math.max(0, (length - dg));\n        chunks += chunk2;\n    }\n    if (ef > 8 && a + 2 < array.length) {\n        const hi = ((a + 3) * 8) - (position + length);\n        const chunk3 = array[a + 2] >>> hi;\n        chunks += chunk3;\n    }\n    return chunks;\n}\nfunction appendReversed(dest, source) {\n    for (let i = source.length - 1; i >= 0; i--) {\n        dest.push(source[i]);\n    }\n    return dest;\n}\nfunction decompress(input) {\n    const dictionaryIndex = new Uint16Array(4093);\n    const dictionaryChar = new Uint8Array(4093);\n    for (let i = 0; i <= 257; i++) {\n        dictionaryIndex[i] = 4096;\n        dictionaryChar[i] = i;\n    }\n    let dictionaryLength = 258;\n    let byteLength = MIN_BITS;\n    let position = 0;\n    function initDictionary() {\n        dictionaryLength = 258;\n        byteLength = MIN_BITS;\n    }\n    function getNext(array) {\n        const byte = getByte(array, position, byteLength);\n        position += byteLength;\n        return byte;\n    }\n    function addToDictionary(i, c) {\n        dictionaryChar[dictionaryLength] = c;\n        dictionaryIndex[dictionaryLength] = i;\n        dictionaryLength++;\n        return dictionaryLength - 1;\n    }\n    function getDictionaryReversed(n) {\n        const rev = [];\n        for (let i = n; i !== 4096; i = dictionaryIndex[i]) {\n            rev.push(dictionaryChar[i]);\n        }\n        return rev;\n    }\n    const result = [];\n    initDictionary();\n    const array = new Uint8Array(input);\n    let code = getNext(array);\n    let oldCode;\n    while (code !== EOI_CODE) {\n        if (code === CLEAR_CODE) {\n            initDictionary();\n            code = getNext(array);\n            while (code === CLEAR_CODE) {\n                code = getNext(array);\n            }\n            if (code === EOI_CODE) {\n                break;\n            }\n            else if (code > CLEAR_CODE) {\n                throw new Error(`corrupted code at scanline ${code}`);\n            }\n            else {\n                const val = getDictionaryReversed(code);\n                appendReversed(result, val);\n                oldCode = code;\n            }\n        }\n        else if (code < dictionaryLength) {\n            const val = getDictionaryReversed(code);\n            appendReversed(result, val);\n            addToDictionary(oldCode, val[val.length - 1]);\n            oldCode = code;\n        }\n        else {\n            const oldVal = getDictionaryReversed(oldCode);\n            if (!oldVal) {\n                throw new Error(`Bogus entry. Not in dictionary, ${oldCode} / ${dictionaryLength}, position: ${position}`);\n            }\n            appendReversed(result, oldVal);\n            result.push(oldVal[oldVal.length - 1]);\n            addToDictionary(oldCode, oldVal[oldVal.length - 1]);\n            oldCode = code;\n        }\n        if (dictionaryLength + 1 >= (2 ** byteLength)) {\n            if (byteLength === MAX_BYTELENGTH) {\n                oldCode = undefined;\n            }\n            else {\n                byteLength++;\n            }\n        }\n        code = getNext(array);\n    }\n    return new Uint8Array(result);\n}\nexport default class LZWDecoder extends BaseDecoder {\n    decodeBlock(buffer) {\n        return decompress(buffer, false).buffer;\n    }\n}\n"],"names":["MIN_BITS","CLEAR_CODE","EOI_CODE","MAX_BYTELENGTH","getByte","array","position","length","d","a","de","ef","fg","dg","chunk1","chunks","chunk2","hi","chunk3","appendReversed","dest","source","i","decompress","input","dictionaryIndex","dictionaryChar","dictionaryLength","byteLength","initDictionary","getNext","byte","addToDictionary","c","getDictionaryReversed","n","rev","result","code","oldCode","val","oldVal","LZWDecoder","BaseDecoder","buffer"],"mappings":"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","x_google_ignoreList":[0]}