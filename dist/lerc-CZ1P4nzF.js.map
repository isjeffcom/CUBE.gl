{"version":3,"file":"lerc-CZ1P4nzF.js","sources":["../node_modules/lerc/LercDecode.js","../node_modules/zstddec/dist/zstddec.modern.js","../node_modules/geotiff/dist-module/compression/lerc.js"],"sourcesContent":["/* jshint forin: false, bitwise: false */\n/*\nCopyright 2015-2021 Esri\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\nhttp://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n\nA copy of the license and additional notices are located with the\nsource distribution at:\n\nhttp://github.com/Esri/lerc/\n\nContributors:  Johannes Schmid, (LERC v1)\n               Chayanika Khatua, (LERC v1)\n               Wenxue Ju (LERC v1, v2.x)\n*/\n\n/* Copyright 2015-2021 Esri. Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 @preserve */\n\n/**\n * a module for decoding LERC blobs\n * @module Lerc\n */\n(function() {\n  //this decoder supports all lerc versions, each version has its own class (LercDecode and Lerc2Decode). \n  //the exported module handles format variation autoamtically.\n\n  //the original LercDecode for Version 1\n  var LercDecode = (function() {\n\n    // Note: currently, this module only has an implementation for decoding LERC data, not encoding. The name of\n    // the class was chosen to be future proof.\n\n    var CntZImage = {};\n\n    CntZImage.defaultNoDataValue = -3.4027999387901484e+38; // smallest Float32 value\n\n    /**\n     * Decode a LERC byte stream and return an object containing the pixel data and some required and optional\n     * information about it, such as the image's width and height.\n     *\n     * @param {ArrayBuffer} input The LERC input byte stream\n     * @param {object} [options] Decoding options, containing any of the following properties:\n     * @config {number} [inputOffset = 0]\n     *        Skip the first inputOffset bytes of the input byte stream. A valid LERC file is expected at that position.\n     * @config {Uint8Array} [encodedMask = null]\n     *        If specified, the decoder will not read mask information from the input and use the specified encoded\n     *        mask data instead. Mask header/data must not be present in the LERC byte stream in this case.\n     * @config {number} [noDataValue = LercCode.defaultNoDataValue]\n     *        Pixel value to use for masked pixels.\n     * @config {ArrayBufferView|Array} [pixelType = Float32Array]\n     *        The desired type of the pixelData array in the return value. Note that it is the caller's responsibility to\n     *        provide an appropriate noDataValue if the default pixelType is overridden.\n     * @config {boolean} [returnMask = false]\n     *        If true, the return value will contain a maskData property of type Uint8Array which has one element per\n     *        pixel, the value of which is 1 or 0 depending on whether that pixel's data is present or masked. If the\n     *        input LERC data does not contain a mask, maskData will not be returned.\n     * @config {boolean} [returnEncodedMask = false]\n     *        If true, the return value will contain a encodedMaskData property, which can be passed into encode() as\n     *        encodedMask.\n     * @config {boolean} [returnFileInfo = false]\n     *        If true, the return value will have a fileInfo property that contains metadata obtained from the\n     *        LERC headers and the decoding process.\n     * @config {boolean} [computeUsedBitDepths = false]\n     *        If true, the fileInfo property in the return value will contain the set of all block bit depths\n     *        encountered during decoding. Will only have an effect if returnFileInfo option is true.\n     * @returns {{width, height, pixelData, minValue, maxValue, noDataValue, maskData, encodedMaskData, fileInfo}}\n     */\n    CntZImage.decode = function(input, options) {\n      options = options || {};\n\n      var skipMask = options.encodedMaskData || (options.encodedMaskData === null);\n      var parsedData = parse(input, options.inputOffset || 0, skipMask);\n\n      var noDataValue = (options.noDataValue !== null) ? options.noDataValue : CntZImage.defaultNoDataValue;\n\n      var uncompressedData = uncompressPixelValues(parsedData, options.pixelType || Float32Array,\n        options.encodedMaskData, noDataValue, options.returnMask);\n\n      var result = {\n        width: parsedData.width,\n        height: parsedData.height,\n        pixelData: uncompressedData.resultPixels,\n        minValue: uncompressedData.minValue,\n        maxValue: parsedData.pixels.maxValue,\n        noDataValue: noDataValue\n      };\n\n      if (uncompressedData.resultMask) {\n        result.maskData = uncompressedData.resultMask;\n      }\n\n      if (options.returnEncodedMask && parsedData.mask) {\n        result.encodedMaskData = parsedData.mask.bitset ? parsedData.mask.bitset : null;\n      }\n\n      if (options.returnFileInfo) {\n        result.fileInfo = formatFileInfo(parsedData);\n        if (options.computeUsedBitDepths) {\n          result.fileInfo.bitDepths = computeUsedBitDepths(parsedData);\n        }\n      }\n\n      return result;\n    };\n\n    var uncompressPixelValues = function(data, TypedArrayClass, maskBitset, noDataValue, storeDecodedMask) {\n      var blockIdx = 0;\n      var numX = data.pixels.numBlocksX;\n      var numY = data.pixels.numBlocksY;\n      var blockWidth = Math.floor(data.width / numX);\n      var blockHeight = Math.floor(data.height / numY);\n      var scale = 2 * data.maxZError;\n      var minValue = Number.MAX_VALUE, currentValue;\n      maskBitset = maskBitset || ((data.mask) ? data.mask.bitset : null);\n\n      var resultPixels, resultMask;\n      resultPixels = new TypedArrayClass(data.width * data.height);\n      if (storeDecodedMask && maskBitset) {\n        resultMask = new Uint8Array(data.width * data.height);\n      }\n      var blockDataBuffer = new Float32Array(blockWidth * blockHeight);\n\n      var xx, yy;\n      for (var y = 0; y <= numY; y++) {\n        var thisBlockHeight = (y !== numY) ? blockHeight : (data.height % numY);\n        if (thisBlockHeight === 0) {\n          continue;\n        }\n        for (var x = 0; x <= numX; x++) {\n          var thisBlockWidth = (x !== numX) ? blockWidth : (data.width % numX);\n          if (thisBlockWidth === 0) {\n            continue;\n          }\n\n          var outPtr = y * data.width * blockHeight + x * blockWidth;\n          var outStride = data.width - thisBlockWidth;\n\n          var block = data.pixels.blocks[blockIdx];\n\n          var blockData, blockPtr, constValue;\n          if (block.encoding < 2) {\n            // block is either uncompressed or bit-stuffed (encodings 0 and 1)\n            if (block.encoding === 0) {\n              // block is uncompressed\n              blockData = block.rawData;\n            } else {\n              // block is bit-stuffed\n              unstuff(block.stuffedData, block.bitsPerPixel, block.numValidPixels, block.offset, scale, blockDataBuffer, data.pixels.maxValue);\n              blockData = blockDataBuffer;\n            }\n            blockPtr = 0;\n          }\n          else if (block.encoding === 2) {\n            // block is all 0\n            constValue = 0;\n          }\n          else {\n            // block has constant value (encoding === 3)\n            constValue = block.offset;\n          }\n\n          var maskByte;\n          if (maskBitset) {\n            for (yy = 0; yy < thisBlockHeight; yy++) {\n              if (outPtr & 7) {\n                //\n                maskByte = maskBitset[outPtr >> 3];\n                maskByte <<= outPtr & 7;\n              }\n              for (xx = 0; xx < thisBlockWidth; xx++) {\n                if (!(outPtr & 7)) {\n                  // read next byte from mask\n                  maskByte = maskBitset[outPtr >> 3];\n                }\n                if (maskByte & 128) {\n                  // pixel data present\n                  if (resultMask) {\n                    resultMask[outPtr] = 1;\n                  }\n                  currentValue = (block.encoding < 2) ? blockData[blockPtr++] : constValue;\n                  minValue = minValue > currentValue ? currentValue : minValue;\n                  resultPixels[outPtr++] = currentValue;\n                } else {\n                  // pixel data not present\n                  if (resultMask) {\n                    resultMask[outPtr] = 0;\n                  }\n                  resultPixels[outPtr++] = noDataValue;\n                }\n                maskByte <<= 1;\n              }\n              outPtr += outStride;\n            }\n          } else {\n            // mask not present, simply copy block over\n            if (block.encoding < 2) {\n              // duplicating this code block for performance reasons\n              // blockData case:\n              for (yy = 0; yy < thisBlockHeight; yy++) {\n                for (xx = 0; xx < thisBlockWidth; xx++) {\n                  currentValue = blockData[blockPtr++];\n                  minValue = minValue > currentValue ? currentValue : minValue;\n                  resultPixels[outPtr++] = currentValue;\n                }\n                outPtr += outStride;\n              }\n            }\n            else {\n              // constValue case:\n              minValue = minValue > constValue ? constValue : minValue;\n              for (yy = 0; yy < thisBlockHeight; yy++) {\n                for (xx = 0; xx < thisBlockWidth; xx++) {\n                  resultPixels[outPtr++] = constValue;\n                }\n                outPtr += outStride;\n              }\n            }\n          }\n          if ((block.encoding === 1) && (blockPtr !== block.numValidPixels)) {\n            throw \"Block and Mask do not match\";\n          }\n          blockIdx++;\n        }\n      }\n\n      return {\n        resultPixels: resultPixels,\n        resultMask: resultMask,\n        minValue: minValue\n      };\n    };\n\n    var formatFileInfo = function(data) {\n      return {\n        \"fileIdentifierString\": data.fileIdentifierString,\n        \"fileVersion\": data.fileVersion,\n        \"imageType\": data.imageType,\n        \"height\": data.height,\n        \"width\": data.width,\n        \"maxZError\": data.maxZError,\n        \"eofOffset\": data.eofOffset,\n        \"mask\": data.mask ? {\n          \"numBlocksX\": data.mask.numBlocksX,\n          \"numBlocksY\": data.mask.numBlocksY,\n          \"numBytes\": data.mask.numBytes,\n          \"maxValue\": data.mask.maxValue\n        } : null,\n        \"pixels\": {\n          \"numBlocksX\": data.pixels.numBlocksX,\n          \"numBlocksY\": data.pixels.numBlocksY,\n          \"numBytes\": data.pixels.numBytes,\n          \"maxValue\": data.pixels.maxValue,\n          \"noDataValue\": data.noDataValue\n        }\n      };\n    };\n\n    var computeUsedBitDepths = function(data) {\n      var numBlocks = data.pixels.numBlocksX * data.pixels.numBlocksY;\n      var bitDepths = {};\n      for (var i = 0; i < numBlocks; i++) {\n        var block = data.pixels.blocks[i];\n        if (block.encoding === 0) {\n          bitDepths.float32 = true;\n        } else if (block.encoding === 1) {\n          bitDepths[block.bitsPerPixel] = true;\n        } else {\n          bitDepths[0] = true;\n        }\n      }\n\n      return Object.keys(bitDepths);\n    };\n\n    var parse = function(input, fp, skipMask) {\n      var data = {};\n\n      // File header\n      var fileIdView = new Uint8Array(input, fp, 10);\n      data.fileIdentifierString = String.fromCharCode.apply(null, fileIdView);\n      if (data.fileIdentifierString.trim() !== \"CntZImage\") {\n        throw \"Unexpected file identifier string: \" + data.fileIdentifierString;\n      }\n      fp += 10;\n      var view = new DataView(input, fp, 24);\n      data.fileVersion = view.getInt32(0, true);\n      data.imageType = view.getInt32(4, true);\n      data.height = view.getUint32(8, true);\n      data.width = view.getUint32(12, true);\n      data.maxZError = view.getFloat64(16, true);\n      fp += 24;\n\n      // Mask Header\n      if (!skipMask) {\n        view = new DataView(input, fp, 16);\n        data.mask = {};\n        data.mask.numBlocksY = view.getUint32(0, true);\n        data.mask.numBlocksX = view.getUint32(4, true);\n        data.mask.numBytes = view.getUint32(8, true);\n        data.mask.maxValue = view.getFloat32(12, true);\n        fp += 16;\n\n        // Mask Data\n        if (data.mask.numBytes > 0) {\n          var bitset = new Uint8Array(Math.ceil(data.width * data.height / 8));\n          view = new DataView(input, fp, data.mask.numBytes);\n          var cnt = view.getInt16(0, true);\n          var ip = 2, op = 0;\n          do {\n            if (cnt > 0) {\n              while (cnt--) { bitset[op++] = view.getUint8(ip++); }\n            } else {\n              var val = view.getUint8(ip++);\n              cnt = -cnt;\n              while (cnt--) { bitset[op++] = val; }\n            }\n            cnt = view.getInt16(ip, true);\n            ip += 2;\n          } while (ip < data.mask.numBytes);\n          if ((cnt !== -32768) || (op < bitset.length)) {\n            throw \"Unexpected end of mask RLE encoding\";\n          }\n          data.mask.bitset = bitset;\n          fp += data.mask.numBytes;\n        }\n        else if ((data.mask.numBytes | data.mask.numBlocksY | data.mask.maxValue) === 0) {  // Special case, all nodata\n          data.mask.bitset = new Uint8Array(Math.ceil(data.width * data.height / 8));\n        }\n      }\n\n      // Pixel Header\n      view = new DataView(input, fp, 16);\n      data.pixels = {};\n      data.pixels.numBlocksY = view.getUint32(0, true);\n      data.pixels.numBlocksX = view.getUint32(4, true);\n      data.pixels.numBytes = view.getUint32(8, true);\n      data.pixels.maxValue = view.getFloat32(12, true);\n      fp += 16;\n\n      var numBlocksX = data.pixels.numBlocksX;\n      var numBlocksY = data.pixels.numBlocksY;\n      // the number of blocks specified in the header does not take into account the blocks at the end of\n      // each row/column with a special width/height that make the image complete in case the width is not\n      // evenly divisible by the number of blocks.\n      var actualNumBlocksX = numBlocksX + ((data.width % numBlocksX) > 0 ? 1 : 0);\n      var actualNumBlocksY = numBlocksY + ((data.height % numBlocksY) > 0 ? 1 : 0);\n      data.pixels.blocks = new Array(actualNumBlocksX * actualNumBlocksY);\n      var blockI = 0;\n      for (var blockY = 0; blockY < actualNumBlocksY; blockY++) {\n        for (var blockX = 0; blockX < actualNumBlocksX; blockX++) {\n\n          // Block\n          var size = 0;\n          var bytesLeft = input.byteLength - fp;\n          view = new DataView(input, fp, Math.min(10, bytesLeft));\n          var block = {};\n          data.pixels.blocks[blockI++] = block;\n          var headerByte = view.getUint8(0); size++;\n          block.encoding = headerByte & 63;\n          if (block.encoding > 3) {\n            throw \"Invalid block encoding (\" + block.encoding + \")\";\n          }\n          if (block.encoding === 2) {\n            fp++;\n            continue;\n          }\n          if ((headerByte !== 0) && (headerByte !== 2)) {\n            headerByte >>= 6;\n            block.offsetType = headerByte;\n            if (headerByte === 2) {\n              block.offset = view.getInt8(1); size++;\n            } else if (headerByte === 1) {\n              block.offset = view.getInt16(1, true); size += 2;\n            } else if (headerByte === 0) {\n              block.offset = view.getFloat32(1, true); size += 4;\n            } else {\n              throw \"Invalid block offset type\";\n            }\n\n            if (block.encoding === 1) {\n              headerByte = view.getUint8(size); size++;\n              block.bitsPerPixel = headerByte & 63;\n              headerByte >>= 6;\n              block.numValidPixelsType = headerByte;\n              if (headerByte === 2) {\n                block.numValidPixels = view.getUint8(size); size++;\n              } else if (headerByte === 1) {\n                block.numValidPixels = view.getUint16(size, true); size += 2;\n              } else if (headerByte === 0) {\n                block.numValidPixels = view.getUint32(size, true); size += 4;\n              } else {\n                throw \"Invalid valid pixel count type\";\n              }\n            }\n          }\n          fp += size;\n\n          if (block.encoding === 3) {\n            continue;\n          }\n\n          var arrayBuf, store8;\n          if (block.encoding === 0) {\n            var numPixels = (data.pixels.numBytes - 1) / 4;\n            if (numPixels !== Math.floor(numPixels)) {\n              throw \"uncompressed block has invalid length\";\n            }\n            arrayBuf = new ArrayBuffer(numPixels * 4);\n            store8 = new Uint8Array(arrayBuf);\n            store8.set(new Uint8Array(input, fp, numPixels * 4));\n            var rawData = new Float32Array(arrayBuf);\n            block.rawData = rawData;\n            fp += numPixels * 4;\n          } else if (block.encoding === 1) {\n            var dataBytes = Math.ceil(block.numValidPixels * block.bitsPerPixel / 8);\n            var dataWords = Math.ceil(dataBytes / 4);\n            arrayBuf = new ArrayBuffer(dataWords * 4);\n            store8 = new Uint8Array(arrayBuf);\n            store8.set(new Uint8Array(input, fp, dataBytes));\n            block.stuffedData = new Uint32Array(arrayBuf);\n            fp += dataBytes;\n          }\n        }\n      }\n      data.eofOffset = fp;\n      return data;\n    };\n\n    var unstuff = function(src, bitsPerPixel, numPixels, offset, scale, dest, maxValue) {\n      var bitMask = (1 << bitsPerPixel) - 1;\n      var i = 0, o;\n      var bitsLeft = 0;\n      var n, buffer;\n      var nmax = Math.ceil((maxValue - offset) / scale);\n      // get rid of trailing bytes that are already part of next block\n      var numInvalidTailBytes = src.length * 4 - Math.ceil(bitsPerPixel * numPixels / 8);\n      src[src.length - 1] <<= 8 * numInvalidTailBytes;\n\n      for (o = 0; o < numPixels; o++) {\n        if (bitsLeft === 0) {\n          buffer = src[i++];\n          bitsLeft = 32;\n        }\n        if (bitsLeft >= bitsPerPixel) {\n          n = (buffer >>> (bitsLeft - bitsPerPixel)) & bitMask;\n          bitsLeft -= bitsPerPixel;\n        } else {\n          var missingBits = (bitsPerPixel - bitsLeft);\n          n = ((buffer & bitMask) << missingBits) & bitMask;\n          buffer = src[i++];\n          bitsLeft = 32 - missingBits;\n          n += (buffer >>> bitsLeft);\n        }\n        //pixel values may exceed max due to quantization\n        dest[o] = n < nmax ? offset + n * scale : maxValue;\n      }\n      return dest;\n    };\n\n    return CntZImage;\n  })();\n\n  //version 2. Supports 2.1, 2.2, 2.3\n  var Lerc2Decode = (function() {\n    \"use strict\";\n    // Note: currently, this module only has an implementation for decoding LERC data, not encoding. The name of\n    // the class was chosen to be future proof, following LercDecode.\n\n    /*****************************************\n    * private static class bitsutffer used by Lerc2Decode\n    *******************************************/\n    var BitStuffer = {\n      //methods ending with 2 are for the new byte order used by Lerc2.3 and above.\n      //originalUnstuff is used to unpack Huffman code table. code is duplicated to unstuffx for performance reasons.\n      unstuff: function(src, dest, bitsPerPixel, numPixels, lutArr, offset, scale, maxValue) {\n        var bitMask = (1 << bitsPerPixel) - 1;\n        var i = 0, o;\n        var bitsLeft = 0;\n        var n, buffer, missingBits, nmax;\n\n        // get rid of trailing bytes that are already part of next block\n        var numInvalidTailBytes = src.length * 4 - Math.ceil(bitsPerPixel * numPixels / 8);\n        src[src.length - 1] <<= 8 * numInvalidTailBytes;\n        if (lutArr) {\n          for (o = 0; o < numPixels; o++) {\n            if (bitsLeft === 0) {\n              buffer = src[i++];\n              bitsLeft = 32;\n            }\n            if (bitsLeft >= bitsPerPixel) {\n              n = (buffer >>> (bitsLeft - bitsPerPixel)) & bitMask;\n              bitsLeft -= bitsPerPixel;\n            }\n            else {\n              missingBits = (bitsPerPixel - bitsLeft);\n              n = ((buffer & bitMask) << missingBits) & bitMask;\n              buffer = src[i++];\n              bitsLeft = 32 - missingBits;\n              n += (buffer >>> bitsLeft);\n            }\n            dest[o] = lutArr[n];//offset + lutArr[n] * scale;\n          }\n        }\n        else {\n          nmax = Math.ceil((maxValue - offset) / scale);\n          for (o = 0; o < numPixels; o++) {\n            if (bitsLeft === 0) {\n              buffer = src[i++];\n              bitsLeft = 32;\n            }\n            if (bitsLeft >= bitsPerPixel) {\n              n = (buffer >>> (bitsLeft - bitsPerPixel)) & bitMask;\n              bitsLeft -= bitsPerPixel;\n            }\n            else {\n              missingBits = (bitsPerPixel - bitsLeft);\n              n = ((buffer & bitMask) << missingBits) & bitMask;\n              buffer = src[i++];\n              bitsLeft = 32 - missingBits;\n              n += (buffer >>> bitsLeft);\n            }\n            //pixel values may exceed max due to quantization\n            dest[o] = n < nmax ? offset + n * scale : maxValue;\n          }\n        }\n      },\n\n      unstuffLUT: function(src, bitsPerPixel, numPixels, offset, scale, maxValue) {\n        var bitMask = (1 << bitsPerPixel) - 1;\n        var i = 0, o = 0, missingBits = 0, bitsLeft = 0, n = 0;\n        var buffer;\n        var dest = [];\n\n        // get rid of trailing bytes that are already part of next block\n        var numInvalidTailBytes = src.length * 4 - Math.ceil(bitsPerPixel * numPixels / 8);\n        src[src.length - 1] <<= 8 * numInvalidTailBytes;\n\n        var nmax = Math.ceil((maxValue - offset) / scale);\n        for (o = 0; o < numPixels; o++) {\n          if (bitsLeft === 0) {\n            buffer = src[i++];\n            bitsLeft = 32;\n          }\n          if (bitsLeft >= bitsPerPixel) {\n            n = (buffer >>> (bitsLeft - bitsPerPixel)) & bitMask;\n            bitsLeft -= bitsPerPixel;\n          } else {\n            missingBits = (bitsPerPixel - bitsLeft);\n            n = ((buffer & bitMask) << missingBits) & bitMask;\n            buffer = src[i++];\n            bitsLeft = 32 - missingBits;\n            n += (buffer >>> bitsLeft);\n          }\n          //dest.push(n);\n          dest[o] = n < nmax ? offset + n * scale : maxValue;\n        }\n        dest.unshift(offset);//1st one\n        return dest;\n      },\n\n      unstuff2: function(src, dest, bitsPerPixel, numPixels, lutArr, offset, scale, maxValue) {\n        var bitMask = (1 << bitsPerPixel) - 1;\n        var i = 0, o;\n        var bitsLeft = 0, bitPos = 0;\n        var n, buffer, missingBits;\n        if (lutArr) {\n          for (o = 0; o < numPixels; o++) {\n            if (bitsLeft === 0) {\n              buffer = src[i++];\n              bitsLeft = 32;\n              bitPos = 0;\n            }\n            if (bitsLeft >= bitsPerPixel) {\n              n = ((buffer >>> bitPos) & bitMask);\n              bitsLeft -= bitsPerPixel;\n              bitPos += bitsPerPixel;\n            } else {\n              missingBits = (bitsPerPixel - bitsLeft);\n              n = (buffer >>> bitPos) & bitMask;\n              buffer = src[i++];\n              bitsLeft = 32 - missingBits;\n              n |= (buffer & ((1 << missingBits) - 1)) << (bitsPerPixel - missingBits);\n              bitPos = missingBits;\n            }\n            dest[o] = lutArr[n];\n          }\n        }\n        else {\n          var nmax = Math.ceil((maxValue - offset) / scale);\n          for (o = 0; o < numPixels; o++) {\n            if (bitsLeft === 0) {\n              buffer = src[i++];\n              bitsLeft = 32;\n              bitPos = 0;\n            }\n            if (bitsLeft >= bitsPerPixel) {\n              //no unsigned left shift\n              n = ((buffer >>> bitPos) & bitMask);\n              bitsLeft -= bitsPerPixel;\n              bitPos += bitsPerPixel;\n            } else {\n              missingBits = (bitsPerPixel - bitsLeft);\n              n = (buffer >>> bitPos) & bitMask;//((buffer & bitMask) << missingBits) & bitMask;\n              buffer = src[i++];\n              bitsLeft = 32 - missingBits;\n              n |= (buffer & ((1 << missingBits) - 1)) << (bitsPerPixel - missingBits);\n              bitPos = missingBits;\n            }\n            //pixel values may exceed max due to quantization\n            dest[o] = n < nmax ? offset + n * scale : maxValue;\n          }\n        }\n        return dest;\n      },\n\n      unstuffLUT2: function(src, bitsPerPixel, numPixels, offset, scale, maxValue) {\n        var bitMask = (1 << bitsPerPixel) - 1;\n        var i = 0, o = 0, missingBits = 0, bitsLeft = 0, n = 0, bitPos = 0;\n        var buffer;\n        var dest = [];\n        var nmax = Math.ceil((maxValue - offset) / scale);\n        for (o = 0; o < numPixels; o++) {\n          if (bitsLeft === 0) {\n            buffer = src[i++];\n            bitsLeft = 32;\n            bitPos = 0;\n          }\n          if (bitsLeft >= bitsPerPixel) {\n            //no unsigned left shift\n            n = ((buffer >>> bitPos) & bitMask);\n            bitsLeft -= bitsPerPixel;\n            bitPos += bitsPerPixel;\n          } else {\n            missingBits = (bitsPerPixel - bitsLeft);\n            n = (buffer >>> bitPos) & bitMask;//((buffer & bitMask) << missingBits) & bitMask;\n            buffer = src[i++];\n            bitsLeft = 32 - missingBits;\n            n |= (buffer & ((1 << missingBits) - 1)) << (bitsPerPixel - missingBits);\n            bitPos = missingBits;\n          }\n          //dest.push(n);\n          dest[o] = n < nmax ? offset + n * scale : maxValue;\n        }\n        dest.unshift(offset);\n        return dest;\n      },\n\n      originalUnstuff: function(src, dest, bitsPerPixel, numPixels) {\n        var bitMask = (1 << bitsPerPixel) - 1;\n        var i = 0, o;\n        var bitsLeft = 0;\n        var n, buffer, missingBits;\n\n        // get rid of trailing bytes that are already part of next block\n        var numInvalidTailBytes = src.length * 4 - Math.ceil(bitsPerPixel * numPixels / 8);\n        src[src.length - 1] <<= 8 * numInvalidTailBytes;\n\n        for (o = 0; o < numPixels; o++) {\n          if (bitsLeft === 0) {\n            buffer = src[i++];\n            bitsLeft = 32;\n          }\n          if (bitsLeft >= bitsPerPixel) {\n            n = (buffer >>> (bitsLeft - bitsPerPixel)) & bitMask;\n            bitsLeft -= bitsPerPixel;\n          }\n          else {\n            missingBits = (bitsPerPixel - bitsLeft);\n            n = ((buffer & bitMask) << missingBits) & bitMask;\n            buffer = src[i++];\n            bitsLeft = 32 - missingBits;\n            n += (buffer >>> bitsLeft);\n          }\n          dest[o] = n;\n        }\n        return dest;\n      },\n\n      originalUnstuff2: function(src, dest, bitsPerPixel, numPixels) {\n        var bitMask = (1 << bitsPerPixel) - 1;\n        var i = 0, o;\n        var bitsLeft = 0, bitPos = 0;\n        var n, buffer, missingBits;\n        //micro-optimizations\n        for (o = 0; o < numPixels; o++) {\n          if (bitsLeft === 0) {\n            buffer = src[i++];\n            bitsLeft = 32;\n            bitPos = 0;\n          }\n          if (bitsLeft >= bitsPerPixel) {\n            //no unsigned left shift\n            n = ((buffer >>> bitPos) & bitMask);\n            bitsLeft -= bitsPerPixel;\n            bitPos += bitsPerPixel;\n          } else {\n            missingBits = (bitsPerPixel - bitsLeft);\n            n = (buffer >>> bitPos) & bitMask;//((buffer & bitMask) << missingBits) & bitMask;\n            buffer = src[i++];\n            bitsLeft = 32 - missingBits;\n            n |= (buffer & ((1 << missingBits) - 1)) << (bitsPerPixel - missingBits);\n            bitPos = missingBits;\n          }\n          dest[o] = n;\n        }\n        return dest;\n      }\n    };\n\n    /*****************************************\n    *private static class used by Lerc2Decode\n    ******************************************/\n    var Lerc2Helpers = {\n      HUFFMAN_LUT_BITS_MAX: 12, //use 2^12 lut, treat it like constant\n      computeChecksumFletcher32: function(input) {\n\n        var sum1 = 0xffff, sum2 = 0xffff;\n        var len = input.length;\n        var words = Math.floor(len / 2);\n        var i = 0;\n        while (words) {\n          var tlen = (words >= 359) ? 359 : words;\n          words -= tlen;\n          do {\n            sum1 += (input[i++] << 8);\n            sum2 += sum1 += input[i++];\n          } while (--tlen);\n\n          sum1 = (sum1 & 0xffff) + (sum1 >>> 16);\n          sum2 = (sum2 & 0xffff) + (sum2 >>> 16);\n        }\n\n        // add the straggler byte if it exists\n        if (len & 1) {\n          sum2 += sum1 += (input[i] << 8);\n        }\n        // second reduction step to reduce sums to 16 bits\n        sum1 = (sum1 & 0xffff) + (sum1 >>> 16);\n        sum2 = (sum2 & 0xffff) + (sum2 >>> 16);\n\n        return (sum2 << 16 | sum1) >>> 0;\n      },\n\n      readHeaderInfo: function(input, data) {\n        var ptr = data.ptr;\n        var fileIdView = new Uint8Array(input, ptr, 6);\n        var headerInfo = {};\n        headerInfo.fileIdentifierString = String.fromCharCode.apply(null, fileIdView);\n        if (headerInfo.fileIdentifierString.lastIndexOf(\"Lerc2\", 0) !== 0) {\n          throw \"Unexpected file identifier string (expect Lerc2 ): \" + headerInfo.fileIdentifierString;\n        }\n        ptr += 6;\n        var view = new DataView(input, ptr, 8);\n        var fileVersion = view.getInt32(0, true);\n        headerInfo.fileVersion = fileVersion;\n        ptr += 4;\n        if (fileVersion >= 3) {\n          headerInfo.checksum = view.getUint32(4, true); //nrows\n          ptr += 4;\n        }\n\n        //keys start from here\n        view = new DataView(input, ptr, 12);\n        headerInfo.height = view.getUint32(0, true); //nrows\n        headerInfo.width = view.getUint32(4, true); //ncols\n        ptr += 8;\n        if (fileVersion >= 4) {\n          headerInfo.numDims = view.getUint32(8, true);\n          ptr += 4;\n        }\n        else {\n          headerInfo.numDims = 1;\n        }\n\n        view = new DataView(input, ptr, 40);\n        headerInfo.numValidPixel = view.getUint32(0, true);\n        headerInfo.microBlockSize = view.getInt32(4, true);\n        headerInfo.blobSize = view.getInt32(8, true);\n        headerInfo.imageType = view.getInt32(12, true);\n\n        headerInfo.maxZError = view.getFloat64(16, true);\n        headerInfo.zMin = view.getFloat64(24, true);\n        headerInfo.zMax = view.getFloat64(32, true);\n        ptr += 40;\n        data.headerInfo = headerInfo;\n        data.ptr = ptr;\n\n        var checksum, keyLength;\n        if (fileVersion >= 3) {\n          keyLength = fileVersion >= 4 ? 52 : 48;\n          checksum = this.computeChecksumFletcher32(new Uint8Array(input, ptr - keyLength, headerInfo.blobSize - 14));\n          if (checksum !== headerInfo.checksum) {\n            throw \"Checksum failed.\";\n          }\n        }\n        return true;\n      },\n\n      checkMinMaxRanges: function(input, data) {\n        var headerInfo = data.headerInfo;\n        var OutPixelTypeArray = this.getDataTypeArray(headerInfo.imageType);\n        var rangeBytes = headerInfo.numDims * this.getDataTypeSize(headerInfo.imageType);\n        var minValues = this.readSubArray(input, data.ptr, OutPixelTypeArray, rangeBytes);\n        var maxValues = this.readSubArray(input, data.ptr + rangeBytes, OutPixelTypeArray, rangeBytes);\n        data.ptr += (2 * rangeBytes);\n        var i, equal = true;\n        for (i = 0; i < headerInfo.numDims; i++) {\n          if (minValues[i] !== maxValues[i]) {\n            equal = false;\n            break;\n          }\n        }\n        headerInfo.minValues = minValues;\n        headerInfo.maxValues = maxValues;\n        return equal;\n      },\n\n      readSubArray: function(input, ptr, OutPixelTypeArray, numBytes) {\n        var rawData;\n        if (OutPixelTypeArray === Uint8Array) {\n          rawData = new Uint8Array(input, ptr, numBytes);\n        }\n        else {\n          var arrayBuf = new ArrayBuffer(numBytes);\n          var store8 = new Uint8Array(arrayBuf);\n          store8.set(new Uint8Array(input, ptr, numBytes));\n          rawData = new OutPixelTypeArray(arrayBuf);\n        }\n        return rawData;\n      },\n\n      readMask: function(input, data) {\n        var ptr = data.ptr;\n        var headerInfo = data.headerInfo;\n        var numPixels = headerInfo.width * headerInfo.height;\n        var numValidPixel = headerInfo.numValidPixel;\n\n        var view = new DataView(input, ptr, 4);\n        var mask = {};\n        mask.numBytes = view.getUint32(0, true);\n        ptr += 4;\n\n        // Mask Data\n        if ((0 === numValidPixel || numPixels === numValidPixel) && 0 !== mask.numBytes) {\n          throw (\"invalid mask\");\n        }\n        var bitset, resultMask;\n        if (numValidPixel === 0) {\n          bitset = new Uint8Array(Math.ceil(numPixels / 8));\n          mask.bitset = bitset;\n          resultMask = new Uint8Array(numPixels);\n          data.pixels.resultMask = resultMask;\n          ptr += mask.numBytes;\n        }// ????? else if (data.mask.numBytes > 0 && data.mask.numBytes< data.numValidPixel) {\n        else if (mask.numBytes > 0) {\n          bitset = new Uint8Array(Math.ceil(numPixels / 8));\n          view = new DataView(input, ptr, mask.numBytes);\n          var cnt = view.getInt16(0, true);\n          var ip = 2, op = 0, val = 0;\n          do {\n            if (cnt > 0) {\n              while (cnt--) { bitset[op++] = view.getUint8(ip++); }\n            } else {\n              val = view.getUint8(ip++);\n              cnt = -cnt;\n              while (cnt--) { bitset[op++] = val; }\n            }\n            cnt = view.getInt16(ip, true);\n            ip += 2;\n          } while (ip < mask.numBytes);\n          if ((cnt !== -32768) || (op < bitset.length)) {\n            throw \"Unexpected end of mask RLE encoding\";\n          }\n\n          resultMask = new Uint8Array(numPixels);\n          var mb = 0, k = 0;\n\n          for (k = 0; k < numPixels; k++) {\n            if (k & 7) {\n              mb = bitset[k >> 3];\n              mb <<= k & 7;\n            }\n            else {\n              mb = bitset[k >> 3];\n            }\n            if (mb & 128) {\n              resultMask[k] = 1;\n            }\n          }\n          data.pixels.resultMask = resultMask;\n\n          mask.bitset = bitset;\n          ptr += mask.numBytes;\n        }\n        data.ptr = ptr;\n        data.mask = mask;\n        return true;\n      },\n\n      readDataOneSweep: function(input, data, OutPixelTypeArray, useBSQForOutputDim) {\n        var ptr = data.ptr;\n        var headerInfo = data.headerInfo;\n        var numDims = headerInfo.numDims;\n        var numPixels = headerInfo.width * headerInfo.height;\n        var imageType = headerInfo.imageType;\n        var numBytes = headerInfo.numValidPixel * Lerc2Helpers.getDataTypeSize(imageType) * numDims;\n        //data.pixels.numBytes = numBytes;\n        var rawData;\n        var mask = data.pixels.resultMask;\n        if (OutPixelTypeArray === Uint8Array) {\n          rawData = new Uint8Array(input, ptr, numBytes);\n        }\n        else {\n          var arrayBuf = new ArrayBuffer(numBytes);\n          var store8 = new Uint8Array(arrayBuf);\n          store8.set(new Uint8Array(input, ptr, numBytes));\n          rawData = new OutPixelTypeArray(arrayBuf);\n        }\n        if (rawData.length === numPixels * numDims) {\n          if (useBSQForOutputDim) {\n            data.pixels.resultPixels = Lerc2Helpers.swapDimensionOrder(rawData, numPixels, numDims, OutPixelTypeArray, true);\n          }\n          else {\n            data.pixels.resultPixels = rawData;\n          }\n        }\n        else  //mask\n        {\n          data.pixels.resultPixels = new OutPixelTypeArray(numPixels * numDims);\n          var z = 0, k = 0, i = 0, nStart = 0;\n          if (numDims > 1) {\n            if (useBSQForOutputDim) {\n              for (k = 0; k < numPixels; k++) {\n                if (mask[k]) {\n                  nStart = k;\n                  for (i = 0; i < numDims; i++, nStart+=numPixels) {\n                    data.pixels.resultPixels[nStart] = rawData[z++];\n                  }\n                }\n              }\n            }\n            else {\n              for (k = 0; k < numPixels; k++) {\n                if (mask[k]) {\n                  nStart = k * numDims;\n                  for (i = 0; i < numDims; i++) {\n                    data.pixels.resultPixels[nStart + i] = rawData[z++];\n                  }\n                }\n              }\n            }\n          }\n          else {\n            for (k = 0; k < numPixels; k++) {\n              if (mask[k]) {\n                data.pixels.resultPixels[k] = rawData[z++];\n              }\n            }\n          }\n        }\n        ptr += numBytes;\n        data.ptr = ptr;       //return data;\n        return true;\n      },\n\n      readHuffmanTree: function(input, data) {\n        var BITS_MAX = this.HUFFMAN_LUT_BITS_MAX; //8 is slow for the large test image\n        //var size_max = 1 << BITS_MAX;\n        /* ************************\n        * reading code table\n        *************************/\n        var view = new DataView(input, data.ptr, 16);\n        data.ptr += 16;\n        var version = view.getInt32(0, true);\n        if (version < 2) {\n          throw \"unsupported Huffman version\";\n        }\n        var size = view.getInt32(4, true);\n        var i0 = view.getInt32(8, true);\n        var i1 = view.getInt32(12, true);\n        if (i0 >= i1) {\n          return false;\n        }\n        var blockDataBuffer = new Uint32Array(i1 - i0);\n        Lerc2Helpers.decodeBits(input, data, blockDataBuffer);\n        var codeTable = []; //size\n        var i, j, k, len;\n\n        for (i = i0; i < i1; i++) {\n          j = i - (i < size ? 0 : size);//wrap around\n          codeTable[j] = { first: blockDataBuffer[i - i0], second: null };\n        }\n\n        var dataBytes = input.byteLength - data.ptr;\n        var dataWords = Math.ceil(dataBytes / 4);\n        var arrayBuf = new ArrayBuffer(dataWords * 4);\n        var store8 = new Uint8Array(arrayBuf);\n        store8.set(new Uint8Array(input, data.ptr, dataBytes));\n        var stuffedData = new Uint32Array(arrayBuf); //must start from x*4\n        var bitPos = 0, word, srcPtr = 0;\n        word = stuffedData[0];\n        for (i = i0; i < i1; i++) {\n          j = i - (i < size ? 0 : size);//wrap around\n          len = codeTable[j].first;\n          if (len > 0) {\n            codeTable[j].second = (word << bitPos) >>> (32 - len);\n\n            if (32 - bitPos >= len) {\n              bitPos += len;\n              if (bitPos === 32) {\n                bitPos = 0;\n                srcPtr++;\n                word = stuffedData[srcPtr];\n              }\n            }\n            else {\n              bitPos += len - 32;\n              srcPtr++;\n              word = stuffedData[srcPtr];\n              codeTable[j].second |= word >>> (32 - bitPos);\n            }\n          }\n        }\n\n        //finished reading code table\n\n        /* ************************\n        * building lut\n        *************************/\n        var numBitsLUT = 0, numBitsLUTQick = 0;\n        var tree = new TreeNode();\n        for (i = 0; i < codeTable.length; i++) {\n          if (codeTable[i] !== undefined) {\n            numBitsLUT = Math.max(numBitsLUT, codeTable[i].first);\n          }\n        }\n        if (numBitsLUT >= BITS_MAX) {\n          numBitsLUTQick = BITS_MAX;\n        }\n        else {\n          numBitsLUTQick = numBitsLUT;\n        }\n        // for debugging purpose\n        // if (numBitsLUT >= 30) {\n        //   console.log(\"WARning, large NUM LUT BITS IS \" + numBitsLUT);\n        // }\n        var decodeLut = [], entry, code, numEntries, jj, currentBit, node;\n        for (i = i0; i < i1; i++) {\n          j = i - (i < size ? 0 : size);//wrap around\n          len = codeTable[j].first;\n          if (len > 0) {\n            entry = [len, j];\n            if (len <= numBitsLUTQick) {\n              code = codeTable[j].second << (numBitsLUTQick - len);\n              numEntries = 1 << (numBitsLUTQick - len);\n              for (k = 0; k < numEntries; k++) {\n                decodeLut[code | k] = entry;\n              }\n            }\n            else {\n              //build tree\n              code = codeTable[j].second;\n              node = tree;\n              for (jj = len - 1; jj >= 0; jj--) {\n                currentBit = code >>> jj & 1; //no left shift as length could be 30,31\n                if (currentBit) {\n                  if (!node.right) {\n                    node.right = new TreeNode();\n                  }\n                  node = node.right;\n                }\n                else {\n                  if (!node.left) {\n                    node.left = new TreeNode();\n                  }\n                  node = node.left;\n                }\n                if (jj === 0 && !node.val) {\n                  node.val = entry[1];\n                }\n              }\n            }\n          }\n        }\n        return {\n          decodeLut: decodeLut,\n          numBitsLUTQick: numBitsLUTQick,\n          numBitsLUT: numBitsLUT,\n          tree: tree,\n          stuffedData: stuffedData,\n          srcPtr: srcPtr,\n          bitPos: bitPos\n        };\n      },\n\n      readHuffman: function(input, data, OutPixelTypeArray, useBSQForOutputDim) {\n        var headerInfo = data.headerInfo;\n        var numDims = headerInfo.numDims;\n        var height = data.headerInfo.height;\n        var width = data.headerInfo.width;\n        var numPixels = width * height;\n        //var size_max = 1 << BITS_MAX;\n        /* ************************\n        * reading huffman structure info\n        *************************/\n        var huffmanInfo = this.readHuffmanTree(input, data);\n        var decodeLut = huffmanInfo.decodeLut;\n        var tree = huffmanInfo.tree;\n        //stuffedData includes huffman headers\n        var stuffedData = huffmanInfo.stuffedData;\n        var srcPtr = huffmanInfo.srcPtr;\n        var bitPos = huffmanInfo.bitPos;\n        var numBitsLUTQick = huffmanInfo.numBitsLUTQick;\n        var numBitsLUT = huffmanInfo.numBitsLUT;\n        var offset = data.headerInfo.imageType === 0 ? 128 : 0;\n        /*************************\n        *  decode\n        ***************************/\n        var node, val, delta, mask = data.pixels.resultMask, valTmp, valTmpQuick, currentBit;\n        var i, j, k, ii;\n        var prevVal = 0;\n        if (bitPos > 0) {\n          srcPtr++;\n          bitPos = 0;\n        }\n        var word = stuffedData[srcPtr];\n        var deltaEncode = data.encodeMode === 1;\n        var resultPixelsAllDim = new OutPixelTypeArray(numPixels * numDims);\n        var resultPixels = resultPixelsAllDim;\n        var iDim;\n        // TODO: reevaluate the need to keep inlined decoding code as IE support is phasing out\n        if (numDims < 2 || deltaEncode) {\n          for (iDim = 0; iDim < numDims; iDim++) {\n            if (numDims > 1) {\n              //get the mem block of current dimension\n              resultPixels = new OutPixelTypeArray(resultPixelsAllDim.buffer, numPixels * iDim, numPixels);\n              prevVal = 0;\n            }\n            if (data.headerInfo.numValidPixel === width * height) { //all valid\n              for (k = 0, i = 0; i < height; i++) {\n                for (j = 0; j < width; j++, k++) {\n                  val = 0;\n                  valTmp = (word << bitPos) >>> (32 - numBitsLUTQick);\n                  valTmpQuick = valTmp;// >>> deltaBits;\n                  if (32 - bitPos < numBitsLUTQick) {\n                    valTmp |= ((stuffedData[srcPtr + 1]) >>> (64 - bitPos - numBitsLUTQick));\n                    valTmpQuick = valTmp;// >>> deltaBits;\n                  }\n                  if (decodeLut[valTmpQuick])    // if there, move the correct number of bits and done\n                  {\n                    val = decodeLut[valTmpQuick][1];\n                    bitPos += decodeLut[valTmpQuick][0];\n                  }\n                  else {\n                    valTmp = (word << bitPos) >>> (32 - numBitsLUT);\n                    valTmpQuick = valTmp;// >>> deltaBits;\n                    if (32 - bitPos < numBitsLUT) {\n                      valTmp |= ((stuffedData[srcPtr + 1]) >>> (64 - bitPos - numBitsLUT));\n                      valTmpQuick = valTmp;// >>> deltaBits;\n                    }\n                    node = tree;\n                    for (ii = 0; ii < numBitsLUT; ii++) {\n                      currentBit = valTmp >>> (numBitsLUT - ii - 1) & 1;\n                      node = currentBit ? node.right : node.left;\n                      if (!(node.left || node.right)) {\n                        val = node.val;\n                        bitPos = bitPos + ii + 1;\n                        break;\n                      }\n                    }\n                  }\n    \n                  if (bitPos >= 32) {\n                    bitPos -= 32;\n                    srcPtr++;\n                    word = stuffedData[srcPtr];\n                  }\n    \n                  delta = val - offset;\n                  if (deltaEncode) {\n                    if (j > 0) {\n                      delta += prevVal;    // use overflow\n                    }\n                    else if (i > 0) {\n                      delta += resultPixels[k - width];\n                    }\n                    else {\n                      delta += prevVal;\n                    }\n                    delta &= 0xFF; //overflow\n                    resultPixels[k] = delta;//overflow\n                    prevVal = delta;\n                  }\n                  else {\n                    resultPixels[k] = delta;\n                  }\n                }\n              }\n            }\n            else { //not all valid, use mask\n              for (k = 0, i = 0; i < height; i++) {\n                for (j = 0; j < width; j++, k++) {\n                  if (mask[k]) {\n                    val = 0;\n                    valTmp = (word << bitPos) >>> (32 - numBitsLUTQick);\n                    valTmpQuick = valTmp;// >>> deltaBits;\n                    if (32 - bitPos < numBitsLUTQick) {\n                      valTmp |= ((stuffedData[srcPtr + 1]) >>> (64 - bitPos - numBitsLUTQick));\n                      valTmpQuick = valTmp;// >>> deltaBits;\n                    }\n                    if (decodeLut[valTmpQuick])    // if there, move the correct number of bits and done\n                    {\n                      val = decodeLut[valTmpQuick][1];\n                      bitPos += decodeLut[valTmpQuick][0];\n                    }\n                    else {\n                      valTmp = (word << bitPos) >>> (32 - numBitsLUT);\n                      valTmpQuick = valTmp;// >>> deltaBits;\n                      if (32 - bitPos < numBitsLUT) {\n                        valTmp |= ((stuffedData[srcPtr + 1]) >>> (64 - bitPos - numBitsLUT));\n                        valTmpQuick = valTmp;// >>> deltaBits;\n                      }\n                      node = tree;\n                      for (ii = 0; ii < numBitsLUT; ii++) {\n                        currentBit = valTmp >>> (numBitsLUT - ii - 1) & 1;\n                        node = currentBit ? node.right : node.left;\n                        if (!(node.left || node.right)) {\n                          val = node.val;\n                          bitPos = bitPos + ii + 1;\n                          break;\n                        }\n                      }\n                    }\n    \n                    if (bitPos >= 32) {\n                      bitPos -= 32;\n                      srcPtr++;\n                      word = stuffedData[srcPtr];\n                    }\n    \n                    delta = val - offset;\n                    if (deltaEncode) {\n                      if (j > 0 && mask[k - 1]) {\n                        delta += prevVal;    // use overflow\n                      }\n                      else if (i > 0 && mask[k - width]) {\n                        delta += resultPixels[k - width];\n                      }\n                      else {\n                        delta += prevVal;\n                      }\n    \n                      delta &= 0xFF; //overflow\n                      resultPixels[k] = delta;//overflow\n                      prevVal = delta;\n                    }\n                    else {\n                      resultPixels[k] = delta;\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        else {\n          for (k = 0, i = 0; i < height; i++) {\n            for (j = 0; j < width; j++) {\n              k = i * width + j;\n              if (!mask || mask[k]) {\n                for (iDim = 0; iDim < numDims; iDim++, k+=numPixels) {\n                  val = 0;\n                  valTmp = (word << bitPos) >>> (32 - numBitsLUTQick);\n                  valTmpQuick = valTmp;\n                  if (32 - bitPos < numBitsLUTQick) {\n                    valTmp |= ((stuffedData[srcPtr + 1]) >>> (64 - bitPos - numBitsLUTQick));\n                    valTmpQuick = valTmp;\n                  }\n                  if (decodeLut[valTmpQuick])\n                  {\n                    val = decodeLut[valTmpQuick][1];\n                    bitPos += decodeLut[valTmpQuick][0];\n                  }\n                  else {\n                    valTmp = (word << bitPos) >>> (32 - numBitsLUT);\n                    valTmpQuick = valTmp;\n                    if (32 - bitPos < numBitsLUT) {\n                      valTmp |= ((stuffedData[srcPtr + 1]) >>> (64 - bitPos - numBitsLUT));\n                      valTmpQuick = valTmp;\n                    }\n                    node = tree;\n                    for (ii = 0; ii < numBitsLUT; ii++) {\n                      currentBit = valTmp >>> (numBitsLUT - ii - 1) & 1;\n                      node = currentBit ? node.right : node.left;\n                      if (!(node.left || node.right)) {\n                        val = node.val;\n                        bitPos = bitPos + ii + 1;\n                        break;\n                      }\n                    }\n                  }\n\n                  if (bitPos >= 32) {\n                    bitPos -= 32;\n                    srcPtr++;\n                    word = stuffedData[srcPtr];\n                  }\n\n                  delta = val - offset;\n                  resultPixels[k] = delta;\n                }\n              }\n            }\n          }\n        }\n        data.ptr = data.ptr + (srcPtr + 1) * 4 + (bitPos > 0 ? 4 : 0);\n        data.pixels.resultPixels = resultPixelsAllDim;\n        //swap for BIP layout\n        if (numDims > 1 && !useBSQForOutputDim) {\n          data.pixels.resultPixels = Lerc2Helpers.swapDimensionOrder(resultPixelsAllDim, numPixels, numDims, OutPixelTypeArray);\n        }\n      },\n\n      decodeBits: function(input, data, blockDataBuffer, offset, iDim) {\n        {\n          //bitstuff encoding is 3\n          var headerInfo = data.headerInfo;\n          var fileVersion = headerInfo.fileVersion;\n          //var block = {};\n          var blockPtr = 0;\n          var viewByteLength = ((input.byteLength - data.ptr) >= 5) ? 5 : (input.byteLength - data.ptr);\n          var view = new DataView(input, data.ptr, viewByteLength);\n          var headerByte = view.getUint8(0);\n          blockPtr++;\n          var bits67 = headerByte >> 6;\n          var n = (bits67 === 0) ? 4 : 3 - bits67;\n          var doLut = (headerByte & 32) > 0 ? true : false;//5th bit\n          var numBits = headerByte & 31;\n          var numElements = 0;\n          if (n === 1) {\n            numElements = view.getUint8(blockPtr); blockPtr++;\n          } else if (n === 2) {\n            numElements = view.getUint16(blockPtr, true); blockPtr += 2;\n          } else if (n === 4) {\n            numElements = view.getUint32(blockPtr, true); blockPtr += 4;\n          } else {\n            throw \"Invalid valid pixel count type\";\n          }\n          //fix: huffman codes are bit stuffed, but not bound by data's max value, so need to use originalUnstuff\n          //offset = offset || 0;\n          var scale = 2 * headerInfo.maxZError;\n          var stuffedData, arrayBuf, store8, dataBytes, dataWords;\n          var lutArr, lutData, lutBytes, lutBitsPerElement, bitsPerPixel;\n          var zMax = headerInfo.numDims > 1 ? headerInfo.maxValues[iDim] : headerInfo.zMax;\n          if (doLut) {\n            data.counter.lut++;\n            lutBytes = view.getUint8(blockPtr);\n            lutBitsPerElement = numBits;\n            blockPtr++;\n            dataBytes = Math.ceil((lutBytes - 1) * numBits / 8);\n            dataWords = Math.ceil(dataBytes / 4);\n            arrayBuf = new ArrayBuffer(dataWords * 4);\n            store8 = new Uint8Array(arrayBuf);\n\n            data.ptr += blockPtr;\n            store8.set(new Uint8Array(input, data.ptr, dataBytes));\n\n            lutData = new Uint32Array(arrayBuf);\n            data.ptr += dataBytes;\n\n            bitsPerPixel = 0;\n            while ((lutBytes - 1) >>> bitsPerPixel) {\n              bitsPerPixel++;\n            }\n            dataBytes = Math.ceil(numElements * bitsPerPixel / 8);\n            dataWords = Math.ceil(dataBytes / 4);\n            arrayBuf = new ArrayBuffer(dataWords * 4);\n            store8 = new Uint8Array(arrayBuf);\n            store8.set(new Uint8Array(input, data.ptr, dataBytes));\n            stuffedData = new Uint32Array(arrayBuf);\n            data.ptr += dataBytes;\n            if (fileVersion >= 3) {\n              lutArr = BitStuffer.unstuffLUT2(lutData, numBits, lutBytes - 1, offset, scale, zMax);\n            }\n            else {\n              lutArr = BitStuffer.unstuffLUT(lutData, numBits, lutBytes - 1, offset, scale, zMax);\n            }\n            //lutArr.unshift(0);\n            if (fileVersion >= 3) {\n              //BitStuffer.unstuff2(block, blockDataBuffer, headerInfo.zMax);\n              BitStuffer.unstuff2(stuffedData, blockDataBuffer, bitsPerPixel, numElements, lutArr);\n            }\n            else {\n              BitStuffer.unstuff(stuffedData, blockDataBuffer, bitsPerPixel, numElements, lutArr);\n            }\n          }\n          else {\n            //console.debug(\"bitstuffer\");\n            data.counter.bitstuffer++;\n            bitsPerPixel = numBits;\n            data.ptr += blockPtr;\n            if (bitsPerPixel > 0) {\n              dataBytes = Math.ceil(numElements * bitsPerPixel / 8);\n              dataWords = Math.ceil(dataBytes / 4);\n              arrayBuf = new ArrayBuffer(dataWords * 4);\n              store8 = new Uint8Array(arrayBuf);\n              store8.set(new Uint8Array(input, data.ptr, dataBytes));\n              stuffedData = new Uint32Array(arrayBuf);\n              data.ptr += dataBytes;\n              if (fileVersion >= 3) {\n                if (offset == null) {\n                  BitStuffer.originalUnstuff2(stuffedData, blockDataBuffer, bitsPerPixel, numElements);\n                }\n                else {\n                  BitStuffer.unstuff2(stuffedData, blockDataBuffer, bitsPerPixel, numElements, false, offset, scale, zMax);\n                }\n              }\n              else {\n                if (offset == null) {\n                  BitStuffer.originalUnstuff(stuffedData, blockDataBuffer, bitsPerPixel, numElements);\n                }\n                else {\n                  BitStuffer.unstuff(stuffedData, blockDataBuffer, bitsPerPixel, numElements, false, offset, scale, zMax);\n                }\n              }\n            }\n          }\n        }\n\n      },\n\n      readTiles: function(input, data, OutPixelTypeArray, useBSQForOutputDim) {\n        var headerInfo = data.headerInfo;\n        var width = headerInfo.width;\n        var height = headerInfo.height;\n        var numPixels = width * height;\n        var microBlockSize = headerInfo.microBlockSize;\n        var imageType = headerInfo.imageType;\n        var dataTypeSize = Lerc2Helpers.getDataTypeSize(imageType);\n        var numBlocksX = Math.ceil(width / microBlockSize);\n        var numBlocksY = Math.ceil(height / microBlockSize);\n        data.pixels.numBlocksY = numBlocksY;\n        data.pixels.numBlocksX = numBlocksX;\n        data.pixels.ptr = 0;\n        var row = 0, col = 0, blockY = 0, blockX = 0, thisBlockHeight = 0, thisBlockWidth = 0, bytesLeft = 0, headerByte = 0, bits67 = 0, testCode = 0, outPtr = 0, outStride = 0, numBytes = 0, bytesleft = 0, z = 0, blockPtr = 0;\n        var view, block, arrayBuf, store8, rawData;\n        var blockEncoding;\n        var blockDataBuffer = new OutPixelTypeArray(microBlockSize * microBlockSize);\n        var lastBlockHeight = (height % microBlockSize) || microBlockSize;\n        var lastBlockWidth = (width % microBlockSize) || microBlockSize;\n        var offsetType, offset;\n        var numDims = headerInfo.numDims, iDim;\n        var mask = data.pixels.resultMask;\n        var resultPixels = data.pixels.resultPixels;\n        var fileVersion = headerInfo.fileVersion;\n        var fileVersionCheckNum = fileVersion >= 5 ? 14 : 15;\n        var isDiffEncoding;\n        var zMax = headerInfo.zMax;\n        //var resultPixelsAllDim = resultPixels;\n        var resultPixelsPrevDim;\n        for (blockY = 0; blockY < numBlocksY; blockY++) {\n          thisBlockHeight = (blockY !== numBlocksY - 1) ? microBlockSize : lastBlockHeight;\n          for (blockX = 0; blockX < numBlocksX; blockX++) {\n            //console.debug(\"y\" + blockY + \" x\" + blockX);\n            thisBlockWidth = (blockX !== numBlocksX - 1) ? microBlockSize : lastBlockWidth;\n\n            outPtr = blockY * width * microBlockSize + blockX * microBlockSize;\n            outStride = width - thisBlockWidth;\n\n            for (iDim = 0; iDim < numDims; iDim++) {\n              if (numDims > 1) {\n                resultPixelsPrevDim = resultPixels;\n                outPtr = blockY * width * microBlockSize + blockX * microBlockSize;\n                resultPixels = new OutPixelTypeArray(data.pixels.resultPixels.buffer, numPixels * iDim * dataTypeSize, numPixels);\n                zMax = headerInfo.maxValues[iDim];\n              } else {\n                resultPixelsPrevDim = null;\n              }\n              bytesLeft = input.byteLength - data.ptr;\n              view = new DataView(input, data.ptr, Math.min(10, bytesLeft));\n              block = {};\n              blockPtr = 0;\n              headerByte = view.getUint8(0);\n              blockPtr++;\n              isDiffEncoding = headerInfo.fileVersion >= 5 ? headerByte & 4 : 0;\n              bits67 = (headerByte >> 6) & 0xFF;\n              testCode = (headerByte >> 2) & fileVersionCheckNum;    // use bits 2345 for integrity check\n              if (testCode !== (((blockX * microBlockSize) >> 3) & fileVersionCheckNum)) {\n                throw \"integrity issue\";\n              }\n\n              if (isDiffEncoding && iDim === 0) {\n                throw \"integrity issue\";\n              }\n\n              blockEncoding = headerByte & 3;\n              if (blockEncoding > 3) {\n                data.ptr += blockPtr;\n                throw \"Invalid block encoding (\" + blockEncoding + \")\";\n              }\n              else if (blockEncoding === 2) { //constant 0\n                if (isDiffEncoding) {\n                  if (mask) {\n                    for (row = 0; row < thisBlockHeight; row++) {\n                      for (col = 0; col < thisBlockWidth; col++) {\n                        if (mask[outPtr]) {\n                          resultPixels[outPtr] = resultPixelsPrevDim[outPtr];\n                        }\n                        outPtr++;\n                      }\n                    }\n                  }\n                  else {\n                    for (row = 0; row < thisBlockHeight; row++) {\n                      for (col = 0; col < thisBlockWidth; col++) {\n                        resultPixels[outPtr] = resultPixelsPrevDim[outPtr];\n                        outPtr++;\n                      }\n                    }\n                  }\n                }\n                data.counter.constant++;\n                data.ptr += blockPtr;\n                continue;\n              }\n              else if (blockEncoding === 0) {  //uncompressed\n                if (isDiffEncoding) {\n                  // doesn't make sense, should not happen\n                  throw \"integrity issue\";\n                }\n                data.counter.uncompressed++;\n                data.ptr += blockPtr;\n                numBytes = thisBlockHeight * thisBlockWidth * dataTypeSize;\n                bytesleft = input.byteLength - data.ptr;\n                numBytes = numBytes < bytesleft ? numBytes : bytesleft;\n                //bit alignment\n                arrayBuf = new ArrayBuffer((numBytes % dataTypeSize) === 0 ? numBytes : (numBytes + dataTypeSize - numBytes % dataTypeSize));\n                store8 = new Uint8Array(arrayBuf);\n                store8.set(new Uint8Array(input, data.ptr, numBytes));\n                rawData = new OutPixelTypeArray(arrayBuf);\n                z = 0;\n                if (mask) {\n                  for (row = 0; row < thisBlockHeight; row++) {\n                    for (col = 0; col < thisBlockWidth; col++) {\n                      if (mask[outPtr]) {\n                        resultPixels[outPtr] = rawData[z++];\n                      }\n                      outPtr++;\n                    }\n                    outPtr += outStride;\n                  }\n                }\n                else {//all valid\n                  for (row = 0; row < thisBlockHeight; row++) {\n                    for (col = 0; col < thisBlockWidth; col++) {\n                      resultPixels[outPtr++] = rawData[z++];\n                    }\n                    outPtr += outStride;\n                  }\n                }\n                data.ptr += z * dataTypeSize;\n              }\n              else { //1 or 3\n                offsetType = Lerc2Helpers.getDataTypeUsed((isDiffEncoding && imageType < 6) ? 4 : imageType, bits67);\n                offset = Lerc2Helpers.getOnePixel(block, blockPtr, offsetType, view);\n                blockPtr += Lerc2Helpers.getDataTypeSize(offsetType);\n                if (blockEncoding === 3) //constant offset value\n                {\n                  data.ptr += blockPtr;\n                  data.counter.constantoffset++;\n                  //you can delete the following resultMask case in favor of performance because val is constant and users use nodata mask, otherwise nodatavalue post processing handles it too.\n                  //while the above statement is true, we're not doing it as we want to keep invalid pixel value at 0 rather than arbitrary values\n                  if (mask) {\n                    for (row = 0; row < thisBlockHeight; row++) {\n                      for (col = 0; col < thisBlockWidth; col++) {\n                        if (mask[outPtr]) {\n                          resultPixels[outPtr] = isDiffEncoding ? Math.min(zMax, resultPixelsPrevDim[outPtr] + offset) : offset;\n                        }\n                        outPtr++;\n                      }\n                      outPtr += outStride;\n                    }\n                  }\n                  else {\n                    for (row = 0; row < thisBlockHeight; row++) {\n                      for (col = 0; col < thisBlockWidth; col++) {\n                        resultPixels[outPtr] = isDiffEncoding ? Math.min(zMax, resultPixelsPrevDim[outPtr] + offset) : offset;\n                        outPtr++;\n                      }\n                      outPtr += outStride;\n                    }\n                  }\n                }\n                else { //bitstuff encoding is 3\n                  data.ptr += blockPtr;\n                  //heavy lifting\n                  Lerc2Helpers.decodeBits(input, data, blockDataBuffer, offset, iDim);\n                  blockPtr = 0;\n                  // duplicate code to favor performance, diff encoding is for multidimension only\n                  if (isDiffEncoding) {\n                    if (mask) {\n                      for (row = 0; row < thisBlockHeight; row++) {\n                        for (col = 0; col < thisBlockWidth; col++) {\n                          if (mask[outPtr]) {\n                            resultPixels[outPtr] = blockDataBuffer[blockPtr++] + resultPixelsPrevDim[outPtr];\n                          }\n                          outPtr++;\n                        }\n                        outPtr += outStride;\n                      }\n                    }\n                    else {\n                      for (row = 0; row < thisBlockHeight; row++) {\n                        for (col = 0; col < thisBlockWidth; col++) {\n                          resultPixels[outPtr] = blockDataBuffer[blockPtr++] + resultPixelsPrevDim[outPtr];\n                          outPtr++;\n                        }\n                        outPtr += outStride;\n                      }\n                    }\n                  }\n                  else if (mask) {\n                    for (row = 0; row < thisBlockHeight; row++) {\n                      for (col = 0; col < thisBlockWidth; col++) {\n                        if (mask[outPtr]) {\n                          resultPixels[outPtr] = blockDataBuffer[blockPtr++];\n                        }\n                        outPtr++;\n                      }\n                      outPtr += outStride;\n                    }\n                  }\n                  else {\n                    for (row = 0; row < thisBlockHeight; row++) {\n                      for (col = 0; col < thisBlockWidth; col++) {\n                        resultPixels[outPtr++] = blockDataBuffer[blockPtr++];\n                      }\n                      outPtr += outStride;\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        //swap for BIP: it's always easier for clients to handle BSQ so we keep existing logic and introduce a swap here to minimze changes\n        if (numDims > 1 && !useBSQForOutputDim) {\n          data.pixels.resultPixels = Lerc2Helpers.swapDimensionOrder(data.pixels.resultPixels, numPixels, numDims, OutPixelTypeArray);\n        }\n      },\n\n      /*****************\n      *  private methods (helper methods)\n      *****************/\n\n      formatFileInfo: function(data) {\n        return {\n          \"fileIdentifierString\": data.headerInfo.fileIdentifierString,\n          \"fileVersion\": data.headerInfo.fileVersion,\n          \"imageType\": data.headerInfo.imageType,\n          \"height\": data.headerInfo.height,\n          \"width\": data.headerInfo.width,\n          \"numValidPixel\": data.headerInfo.numValidPixel,\n          \"microBlockSize\": data.headerInfo.microBlockSize,\n          \"blobSize\": data.headerInfo.blobSize,\n          \"maxZError\": data.headerInfo.maxZError,\n          \"pixelType\": Lerc2Helpers.getPixelType(data.headerInfo.imageType),\n          \"eofOffset\": data.eofOffset,\n          \"mask\": data.mask ? {\n            \"numBytes\": data.mask.numBytes\n          } : null,\n          \"pixels\": {\n            \"numBlocksX\": data.pixels.numBlocksX,\n            \"numBlocksY\": data.pixels.numBlocksY,\n            //\"numBytes\": data.pixels.numBytes,\n            \"maxValue\": data.headerInfo.zMax,\n            \"minValue\": data.headerInfo.zMin,\n            \"noDataValue\": data.noDataValue\n          }\n        };\n      },\n\n      constructConstantSurface: function(data, useBSQForOutputDim) {\n        var val = data.headerInfo.zMax;\n        var valMin = data.headerInfo.zMin;\n        var maxValues = data.headerInfo.maxValues;\n        var numDims = data.headerInfo.numDims;\n        var numPixels = data.headerInfo.height * data.headerInfo.width;\n        var i = 0, k = 0, nStart = 0;\n        var mask = data.pixels.resultMask;\n        var resultPixels = data.pixels.resultPixels;\n        if (mask) {\n          if (numDims > 1) {\n            if (useBSQForOutputDim) {\n              for (i = 0; i < numDims; i++) {\n                nStart = i * numPixels;\n                val = maxValues[i];\n                for (k = 0; k < numPixels; k++) {\n                  if (mask[k]) {\n                    resultPixels[nStart + k] = val;\n                  }\n                }\n              }  \n            }\n            else {\n              for (k = 0; k < numPixels; k++) {\n                if (mask[k]) {\n                  nStart = k * numDims;\n                  for (i = 0; i < numDims; i++) {\n                    resultPixels[nStart + numDims] = maxValues[i];\n                  }\n                }\n              }\n            }\n          }\n          else {\n            for (k = 0; k < numPixels; k++) {\n              if (mask[k]) {\n                resultPixels[k] = val;\n              }\n            }\n          }\n        }\n        else {\n          if (numDims > 1 && valMin !== val) {\n            if (useBSQForOutputDim) {\n              for (i = 0; i < numDims; i++) {\n                nStart = i * numPixels;\n                val = maxValues[i];\n                for (k = 0; k < numPixels; k++) {\n                  resultPixels[nStart + k] = val;\n                }\n              }\n            }\n            else {\n              for (k = 0; k < numPixels; k++) {\n                nStart = k * numDims;\n                for (i = 0; i < numDims; i++) {\n                  resultPixels[nStart + i] = maxValues[i];\n                }\n              }\n            }\n          }\n          else {\n            for (k = 0; k < numPixels * numDims; k++) {\n              resultPixels[k] = val;\n            }\n          }\n        }\n        return;\n      },\n\n      getDataTypeArray: function(t) {\n        var tp;\n        switch (t) {\n          case 0: //char\n            tp = Int8Array;\n            break;\n          case 1: //byte\n            tp = Uint8Array;\n            break;\n          case 2: //short\n            tp = Int16Array;\n            break;\n          case 3: //ushort\n            tp = Uint16Array;\n            break;\n          case 4:\n            tp = Int32Array;\n            break;\n          case 5:\n            tp = Uint32Array;\n            break;\n          case 6:\n            tp = Float32Array;\n            break;\n          case 7:\n            tp = Float64Array;\n            break;\n          default:\n            tp = Float32Array;\n        }\n        return tp;\n      },\n\n      getPixelType: function(t) {\n        var tp;\n        switch (t) {\n          case 0: //char\n            tp = \"S8\";\n            break;\n          case 1: //byte\n            tp = \"U8\";\n            break;\n          case 2: //short\n            tp = \"S16\";\n            break;\n          case 3: //ushort\n            tp = \"U16\";\n            break;\n          case 4:\n            tp = \"S32\";\n            break;\n          case 5:\n            tp = \"U32\";\n            break;\n          case 6:\n            tp = \"F32\";\n            break;\n          case 7:\n            tp = \"F64\";\n            break;\n          default:\n            tp = \"F32\";\n        }\n        return tp;\n      },\n\n      isValidPixelValue: function(t, val) {\n        if (val == null) {\n          return false;\n        }\n        var isValid;\n        switch (t) {\n          case 0: //char\n            isValid = val >= -128 && val <= 127;\n            break;\n          case 1: //byte  (unsigned char)\n            isValid = val >= 0 && val <= 255;\n            break;\n          case 2: //short\n            isValid = val >= -32768 && val <= 32767;\n            break;\n          case 3: //ushort\n            isValid = val >= 0 && val <= 65536;\n            break;\n          case 4: //int 32\n            isValid = val >= -2147483648 && val <= 2147483647;\n            break;\n          case 5: //uinit 32\n            isValid = val >= 0 && val <= 4294967296;\n            break;\n          case 6:\n            isValid = val >= -3.4027999387901484e+38 && val <= 3.4027999387901484e+38;\n            break;\n          case 7:\n            isValid = val >= -1.7976931348623157e+308 && val <= 1.7976931348623157e+308;\n            break;\n          default:\n            isValid = false;\n        }\n        return isValid;\n      },\n\n      getDataTypeSize: function(t) {\n        var s = 0;\n        switch (t) {\n          case 0: //ubyte\n          case 1: //byte\n            s = 1;\n            break;\n          case 2: //short\n          case 3: //ushort\n            s = 2;\n            break;\n          case 4:\n          case 5:\n          case 6:\n            s = 4;\n            break;\n          case 7:\n            s = 8;\n            break;\n          default:\n            s = t;\n        }\n        return s;\n      },\n\n      getDataTypeUsed: function(dt, tc) {\n        var t = dt;\n        switch (dt) {\n          case 2: //short\n          case 4: //long\n            t = dt - tc;\n            break;\n          case 3: //ushort\n          case 5: //ulong\n            t = dt - 2 * tc;\n            break;\n          case 6: //float\n            if (0 === tc) {\n              t = dt;\n            }\n            else if (1 === tc) {\n              t = 2;\n            }\n            else {\n              t = 1;//byte\n            }\n            break;\n          case 7: //double\n            if (0 === tc) {\n              t = dt;\n            }\n            else {\n              t = dt - 2 * tc + 1;\n            }\n            break;\n          default:\n            t = dt;\n            break;\n        }\n        return t;\n      },\n\n      getOnePixel: function(block, blockPtr, offsetType, view) {\n        var temp = 0;\n        switch (offsetType) {\n          case 0: //char\n            temp = view.getInt8(blockPtr);\n            break;\n          case 1: //byte\n            temp = view.getUint8(blockPtr);\n            break;\n          case 2:\n            temp = view.getInt16(blockPtr, true);\n            break;\n          case 3:\n            temp = view.getUint16(blockPtr, true);\n            break;\n          case 4:\n            temp = view.getInt32(blockPtr, true);\n            break;\n          case 5:\n            temp = view.getUInt32(blockPtr, true);\n            break;\n          case 6:\n            temp = view.getFloat32(blockPtr, true);\n            break;\n          case 7:\n            temp = view.getFloat64(blockPtr, true);\n            break;\n          default:\n            throw (\"the decoder does not understand this pixel type\");\n        }\n        return temp;\n      },\n\n      swapDimensionOrder: function(pixels, numPixels, numDims, OutPixelTypeArray, inputIsBIP) {\n        var i = 0, j = 0, iDim = 0, temp = 0, swap = pixels;\n        if (numDims > 1) {\n          swap = new OutPixelTypeArray(numPixels * numDims);\n          if (inputIsBIP) {\n            for (i=0; i<numPixels; i++) {\n              temp = i;\n              for (iDim=0; iDim < numDims; iDim++, temp += numPixels) {\n                swap[temp] = pixels[j++];\n              }\n            }  \n          }\n          else {\n            for (i=0; i<numPixels; i++) {\n              temp = i;\n              for (iDim=0; iDim < numDims; iDim++, temp += numPixels) {\n                swap[j++] = pixels[temp];\n              }\n            }\n          }\n        }\n        return swap;\n      }\n    };\n\n    /***************************************************\n    *private class for a tree node. Huffman code is in Lerc2Helpers\n    ****************************************************/\n    var TreeNode = function(val, left, right) {\n      this.val = val;\n      this.left = left;\n      this.right = right;\n    };\n\n    var Lerc2Decode = {\n      /*\n      * ********removed options compared to LERC1. We can bring some of them back if needed.\n       * removed pixel type. LERC2 is typed and doesn't require user to give pixel type\n       * changed encodedMaskData to maskData. LERC2 's js version make it faster to use maskData directly.\n       * removed returnMask. mask is used by LERC2 internally and is cost free. In case of user input mask, it's returned as well and has neglible cost.\n       * removed nodatavalue. Because LERC2 pixels are typed, nodatavalue will sacrify a useful value for many types (8bit, 16bit) etc,\n       *       user has to be knowledgable enough about raster and their data to avoid usability issues. so nodata value is simply removed now.\n       *       We can add it back later if their's a clear requirement.\n       * removed encodedMask. This option was not implemented in LercDecode. It can be done after decoding (less efficient)\n       * removed computeUsedBitDepths.\n       *\n       *\n       * response changes compared to LERC1\n       * 1. encodedMaskData is not available\n       * 2. noDataValue is optional (returns only if user's noDataValue is with in the valid data type range)\n       * 3. maskData is always available\n      */\n      /*****************\n      *  public properties\n      ******************/\n      //HUFFMAN_LUT_BITS_MAX: 12, //use 2^12 lut, not configurable\n\n      /*****************\n      *  public methods\n      *****************/\n\n      /**\n       * Decode a LERC2 byte stream and return an object containing the pixel data and optional metadata.\n       *\n       * @param {ArrayBuffer} input The LERC input byte stream\n       * @param {object} [options] options Decoding options\n       * @param {number} [options.inputOffset] The number of bytes to skip in the input byte stream. A valid LERC file is expected at that position\n       * @param {boolean} [options.returnFileInfo] If true, the return value will have a fileInfo property that contains metadata obtained from the LERC headers and the decoding process\n       * @param {boolean} [options.returnPixelInterleavedDims]  If true, returned dimensions are pixel-interleaved, a.k.a [p1_dim0, p1_dim1, p1_dimn, p2_dim0...], default is [p1_dim0, p2_dim0, ..., p1_dim1, p2_dim1...]\n       */\n      decode: function(/*byte array*/ input, /*object*/ options) {\n        //currently there's a bug in the sparse array, so please do not set to false\n        options = options || {};\n        var noDataValue = options.noDataValue;\n\n        //initialize\n        var i = 0, data = {};\n        data.ptr = options.inputOffset || 0;\n        data.pixels = {};\n\n        // File header\n        if (!Lerc2Helpers.readHeaderInfo(input, data)) {\n          return;\n        }\n\n        var headerInfo = data.headerInfo;\n        var fileVersion = headerInfo.fileVersion;\n        var OutPixelTypeArray = Lerc2Helpers.getDataTypeArray(headerInfo.imageType);\n\n        // version check\n        if (fileVersion > 5) {\n          throw \"unsupported lerc version 2.\" + fileVersion;\n        }\n\n        // Mask Header\n        Lerc2Helpers.readMask(input, data);\n        if (headerInfo.numValidPixel !== headerInfo.width * headerInfo.height && !data.pixels.resultMask) {\n          data.pixels.resultMask = options.maskData;\n        }\n\n        var numPixels = headerInfo.width * headerInfo.height;\n        data.pixels.resultPixels = new OutPixelTypeArray(numPixels * headerInfo.numDims);\n\n        data.counter = {\n          onesweep: 0,\n          uncompressed: 0,\n          lut: 0,\n          bitstuffer: 0,\n          constant: 0,\n          constantoffset: 0\n        };\n        var useBSQForOutputDim = !options.returnPixelInterleavedDims;\n        if (headerInfo.numValidPixel !== 0) {\n          //not tested\n          if (headerInfo.zMax === headerInfo.zMin) //constant surface\n          {\n            Lerc2Helpers.constructConstantSurface(data, useBSQForOutputDim);\n          }\n          else if (fileVersion >= 4 && Lerc2Helpers.checkMinMaxRanges(input, data)) {\n            Lerc2Helpers.constructConstantSurface(data, useBSQForOutputDim);\n          }\n          else {\n            var view = new DataView(input, data.ptr, 2);\n            var bReadDataOneSweep = view.getUint8(0);\n            data.ptr++;\n            if (bReadDataOneSweep) {\n              //console.debug(\"OneSweep\");\n              Lerc2Helpers.readDataOneSweep(input, data, OutPixelTypeArray, useBSQForOutputDim);\n            }\n            else {\n              //lerc2.1: //bitstuffing + lut\n              //lerc2.2: //bitstuffing + lut + huffman\n              //lerc2.3: new bitstuffer\n              if (fileVersion > 1 && headerInfo.imageType <= 1 && Math.abs(headerInfo.maxZError - 0.5) < 0.00001) {\n                //this is 2.x plus 8 bit (unsigned and signed) data, possiblity of Huffman\n                var flagHuffman = view.getUint8(1);\n                data.ptr++;\n                data.encodeMode = flagHuffman;\n                if (flagHuffman > 2 || (fileVersion < 4 && flagHuffman > 1)) {\n                  throw \"Invalid Huffman flag \" + flagHuffman;\n                }\n                if (flagHuffman) {//1 - delta Huffman, 2 - Huffman\n                  //console.log(\"Huffman\");\n                  Lerc2Helpers.readHuffman(input, data, OutPixelTypeArray, useBSQForOutputDim);\n                }\n                else {\n                  //console.log(\"Tiles\");\n                  Lerc2Helpers.readTiles(input, data, OutPixelTypeArray, useBSQForOutputDim);\n                }\n              }\n              else { //lerc2.x non-8 bit data\n                //console.log(\"Tiles\");\n                Lerc2Helpers.readTiles(input, data, OutPixelTypeArray, useBSQForOutputDim);\n              }\n            }\n          }\n        }\n\n        data.eofOffset = data.ptr;\n        var diff;\n        if (options.inputOffset) {\n          diff = data.headerInfo.blobSize + options.inputOffset - data.ptr;\n          if (Math.abs(diff) >= 1) {\n            //console.debug(\"incorrect eof: dataptr \" + data.ptr + \" offset \" + options.inputOffset + \" blobsize \" + data.headerInfo.blobSize + \" diff: \" + diff);\n            data.eofOffset = options.inputOffset + data.headerInfo.blobSize;\n          }\n        }\n        else {\n          diff = data.headerInfo.blobSize - data.ptr;\n          if (Math.abs(diff) >= 1) {\n            //console.debug(\"incorrect first band eof: dataptr \" + data.ptr + \" blobsize \" + data.headerInfo.blobSize + \" diff: \" + diff);\n            data.eofOffset = data.headerInfo.blobSize;\n          }\n        }\n\n        var result = {\n          width: headerInfo.width,\n          height: headerInfo.height,\n          pixelData: data.pixels.resultPixels,\n          minValue: headerInfo.zMin,\n          maxValue: headerInfo.zMax,\n          validPixelCount: headerInfo.numValidPixel,\n          dimCount: headerInfo.numDims,\n          dimStats: {\n            minValues: headerInfo.minValues,\n            maxValues: headerInfo.maxValues\n          },\n          maskData: data.pixels.resultMask\n          //noDataValue: noDataValue\n        };\n\n        //we should remove this if there's no existing client\n        //optional noDataValue processing, it's user's responsiblity\n        if (data.pixels.resultMask && Lerc2Helpers.isValidPixelValue(headerInfo.imageType, noDataValue)) {\n          var mask = data.pixels.resultMask;\n          for (i = 0; i < numPixels; i++) {\n            if (!mask[i]) {\n              result.pixelData[i] = noDataValue;\n            }\n          }\n          result.noDataValue = noDataValue;\n        }\n        data.noDataValue = noDataValue;\n        if (options.returnFileInfo) {\n          result.fileInfo = Lerc2Helpers.formatFileInfo(data);\n        }\n        return result;\n      },\n\n      getBandCount: function(/*byte array*/ input) {\n        var count = 0;\n        var i = 0;\n        var temp = {};\n        temp.ptr = 0;\n        temp.pixels = {};\n        while (i < input.byteLength - 58) {\n          Lerc2Helpers.readHeaderInfo(input, temp);\n          i += temp.headerInfo.blobSize;\n          count++;\n          temp.ptr = i;\n        }\n        return count;\n      }\n    };\n\n    return Lerc2Decode;\n  })();\n\n  var isPlatformLittleEndian = (function() {\n    var a = new ArrayBuffer(4);\n    var b = new Uint8Array(a);\n    var c = new Uint32Array(a);\n    c[0] = 1;\n    return b[0] === 1;\n  })();\n\n  var Lerc = {\n    /************wrapper**********************************************/\n    /**\n     * A wrapper for decoding both LERC1 and LERC2 byte streams capable of handling multiband pixel blocks for various pixel types.\n     *\n     * @alias module:Lerc\n     * @param {ArrayBuffer} input The LERC input byte stream\n     * @param {object} [options] The decoding options below are optional.\n     * @param {number} [options.inputOffset] The number of bytes to skip in the input byte stream. A valid Lerc file is expected at that position.\n     * @param {string} [options.pixelType] (LERC1 only) Default value is F32. Valid pixel types for input are U8/S8/S16/U16/S32/U32/F32.\n     * @param {number} [options.noDataValue] (LERC1 only). It is recommended to use the returned mask instead of setting this value.\n     * @param {boolean} [options.returnPixelInterleavedDims] (nDim LERC2 only) If true, returned dimensions are pixel-interleaved, a.k.a [p1_dim0, p1_dim1, p1_dimn, p2_dim0...], default is [p1_dim0, p2_dim0, ..., p1_dim1, p2_dim1...]\n     * @returns {{width, height, pixels, pixelType, mask, statistics}}\n       * @property {number} width Width of decoded image.\n       * @property {number} height Height of decoded image.\n       * @property {array} pixels [band1, band2, ] Each band is a typed array of width*height.\n       * @property {string} pixelType The type of pixels represented in the output.\n       * @property {mask} mask Typed array with a size of width*height, or null if all pixels are valid.\n       * @property {array} statistics [statistics_band1, statistics_band2, ] Each element is a statistics object representing min and max values\n    **/\n    decode: function(encodedData, options) {\n      if (!isPlatformLittleEndian) {\n        throw \"Big endian system is not supported.\";\n      }\n      options = options || {};\n      var inputOffset = options.inputOffset || 0;\n      var fileIdView = new Uint8Array(encodedData, inputOffset, 10);\n      var fileIdentifierString = String.fromCharCode.apply(null, fileIdView);\n      var lerc, majorVersion;\n      if (fileIdentifierString.trim() === \"CntZImage\") {\n        lerc = LercDecode;\n        majorVersion = 1;\n      }\n      else if (fileIdentifierString.substring(0, 5) === \"Lerc2\") {\n        lerc = Lerc2Decode;\n        majorVersion = 2;\n      }\n      else {\n        throw \"Unexpected file identifier string: \" + fileIdentifierString;\n      }\n\n      var iPlane = 0, eof = encodedData.byteLength - 10, encodedMaskData, bandMasks = [], bandMask, maskData;\n      var decodedPixelBlock = {\n        width: 0,\n        height: 0,\n        pixels: [],\n        pixelType: options.pixelType,\n        mask: null,\n        statistics: []\n      };\n      var uniqueBandMaskCount = 0;\n\n      while (inputOffset < eof) {\n        var result = lerc.decode(encodedData, {\n          inputOffset: inputOffset,//for both lerc1 and lerc2\n          encodedMaskData: encodedMaskData,//lerc1 only\n          maskData: maskData,//lerc2 only\n          returnMask: iPlane === 0 ? true : false,//lerc1 only\n          returnEncodedMask: iPlane === 0 ? true : false,//lerc1 only\n          returnFileInfo: true,//for both lerc1 and lerc2\n          returnPixelInterleavedDims: options.returnPixelInterleavedDims,//for ndim lerc2 only\n          pixelType: options.pixelType || null,//lerc1 only\n          noDataValue: options.noDataValue || null//lerc1 only\n        });\n\n        inputOffset = result.fileInfo.eofOffset;\n        maskData = result.maskData;//lerc2\n        if (iPlane === 0) {\n          encodedMaskData = result.encodedMaskData;//lerc1\n          decodedPixelBlock.width = result.width;\n          decodedPixelBlock.height = result.height;\n          decodedPixelBlock.dimCount = result.dimCount || 1;\n          //decodedPixelBlock.dimStats = decodedPixelBlock.dimStats;\n          decodedPixelBlock.pixelType = result.pixelType || result.fileInfo.pixelType;\n          decodedPixelBlock.mask = maskData;\n        }\n        if (majorVersion > 1) {\n          if (maskData) {\n            bandMasks.push(maskData);\n          }\n          if (result.fileInfo.mask && result.fileInfo.mask.numBytes > 0) {\n            uniqueBandMaskCount++;\n          }\n        }\n\n        iPlane++;\n        decodedPixelBlock.pixels.push(result.pixelData);\n        decodedPixelBlock.statistics.push({\n          minValue: result.minValue,\n          maxValue: result.maxValue,\n          noDataValue: result.noDataValue,\n          dimStats: result.dimStats\n        });\n      }\n      var i, j, numPixels;\n      if (majorVersion > 1 && uniqueBandMaskCount > 1) {\n        numPixels = decodedPixelBlock.width * decodedPixelBlock.height;\n        decodedPixelBlock.bandMasks = bandMasks;\n        maskData = new Uint8Array(numPixels);\n        maskData.set(bandMasks[0]);\n        for (i = 1; i < bandMasks.length; i++) {\n          bandMask = bandMasks[i];\n          for (j = 0; j < numPixels; j++) {\n            maskData[j] = maskData[j] & bandMask[j];\n          }\n        }\n        decodedPixelBlock.maskData = maskData;\n      }\n\n      return decodedPixelBlock;\n    }\n  };\n\n  if (typeof define === \"function\" && define.amd) {/* jshint ignore:line */\n    //amd loaders such as dojo and requireJS\n    //http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition\n    define([], function() { return Lerc; });/* jshint ignore:line */\n  }\n  else if (typeof module !== \"undefined\" && module.exports) {/* jshint ignore:line */\n    //commonJS module 1.0/1.1/1.1.1 systems, such as nodeJS\n    //http://wiki.commonjs.org/wiki/Modules\n    module.exports = Lerc;/* jshint ignore:line */\n  }\n  else {\n    //assign to this, most likely window\n    this.Lerc = Lerc;\n  }\n\n})();\n","let init;\nlet instance;\nlet heap;\nconst IMPORT_OBJECT = {\n  env: {\n    emscripten_notify_memory_growth: _ => {\n      heap = new Uint8Array(instance.exports.memory.buffer);\n    }\n  }\n};\n/**\r\n * ZSTD (Zstandard) decoder.\r\n */\nclass ZSTDDecoder {\n  init() {\n    if (init) return init;\n    if (typeof fetch !== 'undefined') {\n      // Web.\n      init = fetch(`data:application/wasm;base64,${wasm}`).then(response => response.arrayBuffer()).then(arrayBuffer => WebAssembly.instantiate(arrayBuffer, IMPORT_OBJECT)).then(this._init);\n    } else {\n      // Node.js.\n      init = WebAssembly.instantiate(Buffer.from(wasm, 'base64'), IMPORT_OBJECT).then(this._init);\n    }\n    return init;\n  }\n  _init(result) {\n    instance = result.instance;\n    IMPORT_OBJECT.env.emscripten_notify_memory_growth(0); // initialize heap.\n  }\n  decode(array, uncompressedSize = 0) {\n    if (!instance) throw new Error('ZSTDDecoder: Await .init() before decoding.');\n    // Write compressed data into WASM memory.\n    const compressedSize = array.byteLength;\n    const compressedPtr = instance.exports.malloc(compressedSize);\n    heap.set(array, compressedPtr);\n    // Decompress into WASM memory.\n    uncompressedSize = uncompressedSize || Number(instance.exports.ZSTD_findDecompressedSize(compressedPtr, compressedSize));\n    const uncompressedPtr = instance.exports.malloc(uncompressedSize);\n    const actualSize = instance.exports.ZSTD_decompress(uncompressedPtr, uncompressedSize, compressedPtr, compressedSize);\n    // Read decompressed data and free WASM memory.\n    const dec = heap.slice(uncompressedPtr, uncompressedPtr + actualSize);\n    instance.exports.free(compressedPtr);\n    instance.exports.free(uncompressedPtr);\n    return dec;\n  }\n}\n/**\r\n * BSD License\r\n *\r\n * For Zstandard software\r\n *\r\n * Copyright (c) 2016-present, Yann Collet, Facebook, Inc. All rights reserved.\r\n *\r\n * Redistribution and use in source and binary forms, with or without modification,\r\n * are permitted provided that the following conditions are met:\r\n *\r\n *  * Redistributions of source code must retain the above copyright notice, this\r\n *    list of conditions and the following disclaimer.\r\n *\r\n *  * Redistributions in binary form must reproduce the above copyright notice,\r\n *    this list of conditions and the following disclaimer in the documentation\r\n *    and/or other materials provided with the distribution.\r\n *\r\n *  * Neither the name Facebook nor the names of its contributors may be used to\r\n *    endorse or promote products derived from this software without specific\r\n *    prior written permission.\r\n *\r\n * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\r\n * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\r\n * WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\r\n * DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR\r\n * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\r\n * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\r\n * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\r\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\r\n * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\r\n * SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\r\n */\n// wasm:begin\nconst wasm = 'AGFzbQEAAAABoAEUYAF/AGADf39/AGACf38AYAF/AX9gBX9/f39/AX9gA39/fwF/YAR/f39/AX9gAn9/AX9gAAF/YAd/f39/f39/AX9gB39/f39/f38AYAR/f39/AX5gAn9/AX5gBn9/f39/fwBgDn9/f39/f39/f39/f39/AX9gCH9/f39/f39/AX9gCX9/f39/f39/fwF/YAN+f38BfmAFf39/f38AYAAAAicBA2Vudh9lbXNjcmlwdGVuX25vdGlmeV9tZW1vcnlfZ3Jvd3RoAAADJyYDAAMACAQJBQEHBwADBgoLBAQDBAEABgUMBQ0OAQEBDxAREgYAEwQFAXABAgIFBwEBggKAgAIGCAF/AUGgnwQLB9MBCgZtZW1vcnkCAAxaU1REX2lzRXJyb3IADRlaU1REX2ZpbmREZWNvbXByZXNzZWRTaXplABkPWlNURF9kZWNvbXByZXNzACQGbWFsbG9jAAEEZnJlZQACGV9faW5kaXJlY3RfZnVuY3Rpb25fdGFibGUBABlfZW1zY3JpcHRlbl9zdGFja19yZXN0b3JlAAQcZW1zY3JpcHRlbl9zdGFja19nZXRfY3VycmVudAAFIl9fY3hhX2luY3JlbWVudF9leGNlcHRpb25fcmVmY291bnQAJQkHAQBBAQsBJgwBCgqtkgMm1ScBC38jAEEQayIKJAACQAJAAkACQAJAAkACQAJAAkACQCAAQfQBTQRAQagbKAIAIgRBECAAQQtqQfgDcSAAQQtJGyIGQQN2IgB2IgFBA3EEQAJAIAFBf3NBAXEgAGoiAkEDdCIBQdAbaiIAIAFB2BtqKAIAIgEoAggiBUYEQEGoGyAEQX4gAndxNgIADAELIAUgADYCDCAAIAU2AggLIAFBCGohACABIAJBA3QiAkEDcjYCBCABIAJqIgEgASgCBEEBcjYCBAwLCyAGQbAbKAIAIghNDQEgAQRAAkBBAiAAdCICQQAgAmtyIAEgAHRxaCIBQQN0IgBB0BtqIgIgAEHYG2ooAgAiACgCCCIFRgRAQagbIARBfiABd3EiBDYCAAwBCyAFIAI2AgwgAiAFNgIICyAAIAZBA3I2AgQgACAGaiIHIAFBA3QiASAGayIFQQFyNgIEIAAgAWogBTYCACAIBEAgCEF4cUHQG2ohAUG8GygCACECAn8gBEEBIAhBA3Z0IgNxRQRAQagbIAMgBHI2AgAgAQwBCyABKAIICyEDIAEgAjYCCCADIAI2AgwgAiABNgIMIAIgAzYCCAsgAEEIaiEAQbwbIAc2AgBBsBsgBTYCAAwLC0GsGygCACILRQ0BIAtoQQJ0QdgdaigCACICKAIEQXhxIAZrIQMgAiEBA0ACQCABKAIQIgBFBEAgASgCFCIARQ0BCyAAKAIEQXhxIAZrIgEgAyABIANJIgEbIQMgACACIAEbIQIgACEBDAELCyACKAIYIQkgAiACKAIMIgBHBEAgAigCCCIBIAA2AgwgACABNgIIDAoLIAIoAhQiAQR/IAJBFGoFIAIoAhAiAUUNAyACQRBqCyEFA0AgBSEHIAEiAEEUaiEFIAAoAhQiAQ0AIABBEGohBSAAKAIQIgENAAsgB0EANgIADAkLQX8hBiAAQb9/Sw0AIABBC2oiAUF4cSEGQawbKAIAIgdFDQBBHyEIQQAgBmshAyAAQfT//wdNBEAgBkEmIAFBCHZnIgBrdkEBcSAAQQF0a0E+aiEICwJAAkACQCAIQQJ0QdgdaigCACIBRQRAQQAhAAwBC0EAIQAgBkEZIAhBAXZrQQAgCEEfRxt0IQIDQAJAIAEoAgRBeHEgBmsiBCADTw0AIAEhBSAEIgMNAEEAIQMgASEADAMLIAAgASgCFCIEIAQgASACQR12QQRxaigCECIBRhsgACAEGyEAIAJBAXQhAiABDQALCyAAIAVyRQRAQQAhBUECIAh0IgBBACAAa3IgB3EiAEUNAyAAaEECdEHYHWooAgAhAAsgAEUNAQsDQCAAKAIEQXhxIAZrIgIgA0khASACIAMgARshAyAAIAUgARshBSAAKAIQIgEEfyABBSAAKAIUCyIADQALCyAFRQ0AIANBsBsoAgAgBmtPDQAgBSgCGCEIIAUgBSgCDCIARwRAIAUoAggiASAANgIMIAAgATYCCAwICyAFKAIUIgEEfyAFQRRqBSAFKAIQIgFFDQMgBUEQagshAgNAIAIhBCABIgBBFGohAiAAKAIUIgENACAAQRBqIQIgACgCECIBDQALIARBADYCAAwHCyAGQbAbKAIAIgVNBEBBvBsoAgAhAAJAIAUgBmsiAUEQTwRAIAAgBmoiAiABQQFyNgIEIAAgBWogATYCACAAIAZBA3I2AgQMAQsgACAFQQNyNgIEIAAgBWoiASABKAIEQQFyNgIEQQAhAkEAIQELQbAbIAE2AgBBvBsgAjYCACAAQQhqIQAMCQsgBkG0GygCACICSQRAQbQbIAIgBmsiATYCAEHAG0HAGygCACIAIAZqIgI2AgAgAiABQQFyNgIEIAAgBkEDcjYCBCAAQQhqIQAMCQtBACEAIAZBL2oiAwJ/QYAfKAIABEBBiB8oAgAMAQtBjB9CfzcCAEGEH0KAoICAgIAENwIAQYAfIApBDGpBcHFB2KrVqgVzNgIAQZQfQQA2AgBB5B5BADYCAEGAIAsiAWoiBEEAIAFrIgdxIgEgBk0NCEHgHigCACIFBEBB2B4oAgAiCCABaiIJIAhNIAUgCUlyDQkLAkBB5B4tAABBBHFFBEACQAJAAkACQEHAGygCACIFBEBB6B4hAANAIAAoAgAiCCAFTQRAIAUgCCAAKAIEakkNAwsgACgCCCIADQALC0EAEAMiAkF/Rg0DIAEhBEGEHygCACIAQQFrIgUgAnEEQCABIAJrIAIgBWpBACAAa3FqIQQLIAQgBk0NA0HgHigCACIABEBB2B4oAgAiBSAEaiIHIAVNIAAgB0lyDQQLIAQQAyIAIAJHDQEMBQsgBCACayAHcSIEEAMiAiAAKAIAIAAoAgRqRg0BIAIhAAsgAEF/Rg0BIAZBMGogBE0EQCAAIQIMBAtBiB8oAgAiAiADIARrakEAIAJrcSICEANBf0YNASACIARqIQQgACECDAMLIAJBf0cNAgtB5B5B5B4oAgBBBHI2AgALIAEQAyICQX9GQQAQAyIAQX9GciAAIAJNcg0FIAAgAmsiBCAGQShqTQ0FC0HYHkHYHigCACAEaiIANgIAQdweKAIAIABJBEBB3B4gADYCAAsCQEHAGygCACIDBEBB6B4hAANAIAIgACgCACIBIAAoAgQiBWpGDQIgACgCCCIADQALDAQLQbgbKAIAIgBBACAAIAJNG0UEQEG4GyACNgIAC0EAIQBB7B4gBDYCAEHoHiACNgIAQcgbQX82AgBBzBtBgB8oAgA2AgBB9B5BADYCAANAIABBA3QiAUHYG2ogAUHQG2oiBTYCACABQdwbaiAFNgIAIABBAWoiAEEgRw0AC0G0GyAEQShrIgBBeCACa0EHcSIBayIFNgIAQcAbIAEgAmoiATYCACABIAVBAXI2AgQgACACakEoNgIEQcQbQZAfKAIANgIADAQLIAIgA00gASADS3INAiAAKAIMQQhxDQIgACAEIAVqNgIEQcAbIANBeCADa0EHcSIAaiIBNgIAQbQbQbQbKAIAIARqIgIgAGsiADYCACABIABBAXI2AgQgAiADakEoNgIEQcQbQZAfKAIANgIADAMLQQAhAAwGC0EAIQAMBAtBuBsoAgAgAksEQEG4GyACNgIACyACIARqIQVB6B4hAAJAA0AgBSAAKAIAIgFHBEAgACgCCCIADQEMAgsLIAAtAAxBCHFFDQMLQegeIQADQAJAIAAoAgAiASADTQRAIAMgASAAKAIEaiIFSQ0BCyAAKAIIIQAMAQsLQbQbIARBKGsiAEF4IAJrQQdxIgFrIgc2AgBBwBsgASACaiIBNgIAIAEgB0EBcjYCBCAAIAJqQSg2AgRBxBtBkB8oAgA2AgAgAyAFQScgBWtBB3FqQS9rIgAgACADQRBqSRsiAUEbNgIEIAFB8B4pAgA3AhAgAUHoHikCADcCCEHwHiABQQhqNgIAQeweIAQ2AgBB6B4gAjYCAEH0HkEANgIAIAFBGGohAANAIABBBzYCBCAAQQhqIQIgAEEEaiEAIAIgBUkNAAsgASADRg0AIAEgASgCBEF+cTYCBCADIAEgA2siAkEBcjYCBCABIAI2AgACfyACQf8BTQRAIAJBeHFB0BtqIQACf0GoGygCACIBQQEgAkEDdnQiAnFFBEBBqBsgASACcjYCACAADAELIAAoAggLIQEgACADNgIIIAEgAzYCDEEMIQJBCAwBC0EfIQAgAkH///8HTQRAIAJBJiACQQh2ZyIAa3ZBAXEgAEEBdGtBPmohAAsgAyAANgIcIANCADcCECAAQQJ0QdgdaiEBAkACQEGsGygCACIFQQEgAHQiBHFFBEBBrBsgBCAFcjYCACABIAM2AgAMAQsgAkEZIABBAXZrQQAgAEEfRxt0IQAgASgCACEFA0AgBSIBKAIEQXhxIAJGDQIgAEEddiEFIABBAXQhACABIAVBBHFqIgQoAhAiBQ0ACyAEIAM2AhALIAMgATYCGEEIIQIgAyIBIQBBDAwBCyABKAIIIgAgAzYCDCABIAM2AgggAyAANgIIQQAhAEEYIQJBDAsgA2ogATYCACACIANqIAA2AgALQbQbKAIAIgAgBk0NAEG0GyAAIAZrIgE2AgBBwBtBwBsoAgAiACAGaiICNgIAIAIgAUEBcjYCBCAAIAZBA3I2AgQgAEEIaiEADAQLQaQbQTA2AgBBACEADAMLIAAgAjYCACAAIAAoAgQgBGo2AgQgAkF4IAJrQQdxaiIIIAZBA3I2AgQgAUF4IAFrQQdxaiIEIAYgCGoiA2shBwJAQcAbKAIAIARGBEBBwBsgAzYCAEG0G0G0GygCACAHaiIANgIAIAMgAEEBcjYCBAwBC0G8GygCACAERgRAQbwbIAM2AgBBsBtBsBsoAgAgB2oiADYCACADIABBAXI2AgQgACADaiAANgIADAELIAQoAgQiAEEDcUEBRgRAIABBeHEhCSAEKAIMIQICQCAAQf8BTQRAIAQoAggiASACRgRAQagbQagbKAIAQX4gAEEDdndxNgIADAILIAEgAjYCDCACIAE2AggMAQsgBCgCGCEGAkAgAiAERwRAIAQoAggiACACNgIMIAIgADYCCAwBCwJAIAQoAhQiAAR/IARBFGoFIAQoAhAiAEUNASAEQRBqCyEBA0AgASEFIAAiAkEUaiEBIAAoAhQiAA0AIAJBEGohASACKAIQIgANAAsgBUEANgIADAELQQAhAgsgBkUNAAJAIAQoAhwiAEECdEHYHWoiASgCACAERgRAIAEgAjYCACACDQFBrBtBrBsoAgBBfiAAd3E2AgAMAgsCQCAEIAYoAhBGBEAgBiACNgIQDAELIAYgAjYCFAsgAkUNAQsgAiAGNgIYIAQoAhAiAARAIAIgADYCECAAIAI2AhgLIAQoAhQiAEUNACACIAA2AhQgACACNgIYCyAHIAlqIQcgBCAJaiIEKAIEIQALIAQgAEF+cTYCBCADIAdBAXI2AgQgAyAHaiAHNgIAIAdB/wFNBEAgB0F4cUHQG2ohAAJ/QagbKAIAIgFBASAHQQN2dCICcUUEQEGoGyABIAJyNgIAIAAMAQsgACgCCAshASAAIAM2AgggASADNgIMIAMgADYCDCADIAE2AggMAQtBHyECIAdB////B00EQCAHQSYgB0EIdmciAGt2QQFxIABBAXRrQT5qIQILIAMgAjYCHCADQgA3AhAgAkECdEHYHWohAAJAAkBBrBsoAgAiAUEBIAJ0IgVxRQRAQawbIAEgBXI2AgAgACADNgIADAELIAdBGSACQQF2a0EAIAJBH0cbdCECIAAoAgAhAQNAIAEiACgCBEF4cSAHRg0CIAJBHXYhASACQQF0IQIgACABQQRxaiIFKAIQIgENAAsgBSADNgIQCyADIAA2AhggAyADNgIMIAMgAzYCCAwBCyAAKAIIIgEgAzYCDCAAIAM2AgggA0EANgIYIAMgADYCDCADIAE2AggLIAhBCGohAAwCCwJAIAhFDQACQCAFKAIcIgFBAnRB2B1qIgIoAgAgBUYEQCACIAA2AgAgAA0BQawbIAdBfiABd3EiBzYCAAwCCwJAIAUgCCgCEEYEQCAIIAA2AhAMAQsgCCAANgIUCyAARQ0BCyAAIAg2AhggBSgCECIBBEAgACABNgIQIAEgADYCGAsgBSgCFCIBRQ0AIAAgATYCFCABIAA2AhgLAkAgA0EPTQRAIAUgAyAGaiIAQQNyNgIEIAAgBWoiACAAKAIEQQFyNgIEDAELIAUgBkEDcjYCBCAFIAZqIgQgA0EBcjYCBCADIARqIAM2AgAgA0H/AU0EQCADQXhxQdAbaiEAAn9BqBsoAgAiAUEBIANBA3Z0IgJxRQRAQagbIAEgAnI2AgAgAAwBCyAAKAIICyEBIAAgBDYCCCABIAQ2AgwgBCAANgIMIAQgATYCCAwBC0EfIQAgA0H///8HTQRAIANBJiADQQh2ZyIAa3ZBAXEgAEEBdGtBPmohAAsgBCAANgIcIARCADcCECAAQQJ0QdgdaiEBAkACQCAHQQEgAHQiAnFFBEBBrBsgAiAHcjYCACABIAQ2AgAgBCABNgIYDAELIANBGSAAQQF2a0EAIABBH0cbdCEAIAEoAgAhAQNAIAEiAigCBEF4cSADRg0CIABBHXYhASAAQQF0IQAgAiABQQRxaiIHKAIQIgENAAsgByAENgIQIAQgAjYCGAsgBCAENgIMIAQgBDYCCAwBCyACKAIIIgAgBDYCDCACIAQ2AgggBEEANgIYIAQgAjYCDCAEIAA2AggLIAVBCGohAAwBCwJAIAlFDQACQCACKAIcIgFBAnRB2B1qIgUoAgAgAkYEQCAFIAA2AgAgAA0BQawbIAtBfiABd3E2AgAMAgsCQCACIAkoAhBGBEAgCSAANgIQDAELIAkgADYCFAsgAEUNAQsgACAJNgIYIAIoAhAiAQRAIAAgATYCECABIAA2AhgLIAIoAhQiAUUNACAAIAE2AhQgASAANgIYCwJAIANBD00EQCACIAMgBmoiAEEDcjYCBCAAIAJqIgAgACgCBEEBcjYCBAwBCyACIAZBA3I2AgQgAiAGaiIFIANBAXI2AgQgAyAFaiADNgIAIAgEQCAIQXhxQdAbaiEAQbwbKAIAIQECf0EBIAhBA3Z0IgcgBHFFBEBBqBsgBCAHcjYCACAADAELIAAoAggLIQQgACABNgIIIAQgATYCDCABIAA2AgwgASAENgIIC0G8GyAFNgIAQbAbIAM2AgALIAJBCGohAAsgCkEQaiQAIAAL3AsBCH8CQCAARQ0AIABBCGsiAyAAQQRrKAIAIgJBeHEiAGohBQJAIAJBAXENACACQQJxRQ0BIAMgAygCACIEayIDQbgbKAIASQ0BIAAgBGohAAJAAkACQEG8GygCACADRwRAIAMoAgwhASAEQf8BTQRAIAEgAygCCCICRw0CQagbQagbKAIAQX4gBEEDdndxNgIADAULIAMoAhghByABIANHBEAgAygCCCICIAE2AgwgASACNgIIDAQLIAMoAhQiAgR/IANBFGoFIAMoAhAiAkUNAyADQRBqCyEEA0AgBCEGIAIiAUEUaiEEIAEoAhQiAg0AIAFBEGohBCABKAIQIgINAAsgBkEANgIADAMLIAUoAgQiAkEDcUEDRw0DQbAbIAA2AgAgBSACQX5xNgIEIAMgAEEBcjYCBCAFIAA2AgAPCyACIAE2AgwgASACNgIIDAILQQAhAQsgB0UNAAJAIAMoAhwiBEECdEHYHWoiAigCACADRgRAIAIgATYCACABDQFBrBtBrBsoAgBBfiAEd3E2AgAMAgsCQCADIAcoAhBGBEAgByABNgIQDAELIAcgATYCFAsgAUUNAQsgASAHNgIYIAMoAhAiAgRAIAEgAjYCECACIAE2AhgLIAMoAhQiAkUNACABIAI2AhQgAiABNgIYCyADIAVPDQAgBSgCBCIEQQFxRQ0AAkACQAJAAkAgBEECcUUEQEHAGygCACAFRgRAQcAbIAM2AgBBtBtBtBsoAgAgAGoiADYCACADIABBAXI2AgQgA0G8GygCAEcNBkGwG0EANgIAQbwbQQA2AgAPC0G8GygCACIHIAVGBEBBvBsgAzYCAEGwG0GwGygCACAAaiIANgIAIAMgAEEBcjYCBCAAIANqIAA2AgAPCyAEQXhxIABqIQAgBSgCDCEBIARB/wFNBEAgBSgCCCICIAFGBEBBqBtBqBsoAgBBfiAEQQN2d3E2AgAMBQsgAiABNgIMIAEgAjYCCAwECyAFKAIYIQggASAFRwRAIAUoAggiAiABNgIMIAEgAjYCCAwDCyAFKAIUIgIEfyAFQRRqBSAFKAIQIgJFDQIgBUEQagshBANAIAQhBiACIgFBFGohBCABKAIUIgINACABQRBqIQQgASgCECICDQALIAZBADYCAAwCCyAFIARBfnE2AgQgAyAAQQFyNgIEIAAgA2ogADYCAAwDC0EAIQELIAhFDQACQCAFKAIcIgRBAnRB2B1qIgIoAgAgBUYEQCACIAE2AgAgAQ0BQawbQawbKAIAQX4gBHdxNgIADAILAkAgBSAIKAIQRgRAIAggATYCEAwBCyAIIAE2AhQLIAFFDQELIAEgCDYCGCAFKAIQIgIEQCABIAI2AhAgAiABNgIYCyAFKAIUIgJFDQAgASACNgIUIAIgATYCGAsgAyAAQQFyNgIEIAAgA2ogADYCACADIAdHDQBBsBsgADYCAA8LIABB/wFNBEAgAEF4cUHQG2ohAgJ/QagbKAIAIgRBASAAQQN2dCIAcUUEQEGoGyAAIARyNgIAIAIMAQsgAigCCAshACACIAM2AgggACADNgIMIAMgAjYCDCADIAA2AggPC0EfIQEgAEH///8HTQRAIABBJiAAQQh2ZyICa3ZBAXEgAkEBdGtBPmohAQsgAyABNgIcIANCADcCECABQQJ0QdgdaiEEAn8CQAJ/QawbKAIAIgZBASABdCICcUUEQEGsGyACIAZyNgIAIAQgAzYCAEEYIQFBCAwBCyAAQRkgAUEBdmtBACABQR9HG3QhASAEKAIAIQQDQCAEIgIoAgRBeHEgAEYNAiABQR12IQQgAUEBdCEBIAIgBEEEcWoiBigCECIEDQALIAYgAzYCEEEYIQEgAiEEQQgLIQAgAyICDAELIAIoAggiBCADNgIMIAIgAzYCCEEYIQBBCCEBQQALIQYgASADaiAENgIAIAMgAjYCDCAAIANqIAY2AgBByBtByBsoAgBBAWsiAEF/IAAbNgIACwtsAQJ/QaAbKAIAIgEgAEEHakF4cSICaiEAAkAgAkEAIAAgAU0bRQRAIAA/AEEQdE0NASAAPwBBEHRrQf//A2pBEHZAAEF/RgR/QQAFQQAQAEEBCw0BC0GkG0EwNgIAQX8PC0GgGyAANgIAIAELBgAgACQACwQAIwALuQUBDH8jAEEQayIMJAACQCAEQQdNBEAgDEIANwMIIAQEQCAMQQhqIAMgBPwKAAALQWwgACABIAIgDEEIakEIEAYiACAAIARLGyAAIABBiX9JGyEFDAELIAEoAgBBAWoiDkEBdCIIBEAgAEEAIAj8CwALIAMoAAAiBUEPcSIHQQpLBEBBVCEFDAELIAIgB0EFajYCACADIARqIgJBBGshCCACQQdrIQ0gB0EGaiEPQQQhBiAFQQR2IQVBICAHdCIJQQFyIQpBACECQQEhByADIQQDQAJAIAdBAXFFBEADQCAFQX9zQYCAgIB4cmgiB0EYSUUEQCACQSRqIQIgBCANTQR/IARBA2oFIAQgDWtBA3QgBmpBH3EhBiAICyIEKAAAIAZ2IQUMAQsLIAYgB0EecSILakECaiEGIAdBAXZBA2wgAmogBSALdkEDcWoiAiAOTw0BAn8gBCANSyAGQQN2IARqIgUgCEtxRQRAIAZBB3EhBiAFDAELIAQgCGtBA3QgBmpBH3EhBiAICyIEKAAAIAZ2IQULIAUgCUEBa3EiByAJQQF0QQFrIgsgCmsiEEkEfyAPQQFrBSAFIAtxIgUgEEEAIAUgCU4bayEHIA8LIQUgACACQQF0aiAHQQFrIgs7AQAgAkEBaiECIAUgBmohBiAJQQEgB2sgCyAHQQBKGyAKaiIKSgRAIApBAkgNAUEgIApnIgVrIQ9BASAFQR9zdCEJCyACIA5PDQAgC0EARyEHAn8gBCANSyAGQQN1IARqIgUgCEtxRQRAIAZBB3EhBiAFDAELIAYgBCAIa0EDdGpBH3EhBiAICyIEKAAAIAZ2IQUMAQsLQWwhBSAKQQFHDQAgAiAOSwRAQVAhBQwBCyAGQSBKDQAgASACQQFrNgIAIAQgBkEHakEDdWogA2shBQsgDEEQaiQAIAULrRkCEX8BfiMAQTBrIgckAEG4fyEIAkAgBUUNACAELAAAIglB/wFxIQ0CQAJAIAlBAEgEQCANQf4Aa0EBdiIGIAVPDQMgDUH/AGsiCEH/AUsNAiAEQQFqIQRBACEFA0AgBSAITwRAIAYhDQwDBSAAIAVqIg0gBCAFQQF2aiIJLQAAQQR2OgAAIA0gCS0AAEEPcToAASAFQQJqIQUMAQsACwALIAUgDU0NAiAHQf8BNgIEIAYgB0EEaiAHQQhqIARBAWoiCiANEAYiBEGIf0sEQCAEIQgMAwtBVCEIIAcoAggiC0EGSw0CIAcoAgQiBUEBdCIMQQJqrUIBIAuthiIYQQQgC3QiCUEIaq18fEILfEL8//////////8Ag0LoAlYNAkFSIQggBUH/AUsNAkHoAiAJa60gBUEBaiIQQQF0rSAYfEIIfFQNAiANIARrIRQgBCAKaiEVIAwgBkGABGoiDCAJakEEaiIWakECaiERIAZBhARqIRcgBkGGBGohE0GAgAIgC3RBEHYhCEEAIQVBASEOQQEgC3QiCkEBayISIQQDQCAFIBBGRQRAAkAgBiAFQQF0Ig9qLwEAIglB//8DRgRAIBMgBEECdGogBToAACAEQQFrIQRBASEJDAELIA5BACAIIAnBShshDgsgDyAWaiAJOwEAIAVBAWohBQwBCwsgBiAOOwGCBCAGIAs7AYAEAkAgBCASRgRAQgAhGEEAIQlBACEIA0AgCSAQRgRAIApBA3YgCkEBdmpBA2oiBkEBdCEJQQAhBEEAIQgDQCAIIApPDQQgCCARaiEQQQAhBQNAIAVBAkZFBEAgEyAFIAZsIARqIBJxQQJ0aiAFIBBqLQAAOgAAIAVBAWohBQwBCwsgCEECaiEIIAQgCWogEnEhBAwACwAFIAYgCUEBdGouAQAhBCAIIBFqIg8gGDcAAEEIIQUDQCAEIAVMRQRAIAUgD2ogGDcAACAFQQhqIQUMAQsLIBhCgYKEiJCgwIABfCEYIAlBAWohCSAEIAhqIQgMAQsACwALIApBA3YgCkEBdmpBA2ohEUEAIQhBACEFA0AgCCAQRkUEQEEAIQkgBiAIQQF0ai4BACIPQQAgD0EAShshDwNAIAkgD0ZFBEAgEyAFQQJ0aiAIOgAAA0AgBSARaiAScSIFIARLDQALIAlBAWohCQwBCwsgCEEBaiEIDAELC0F/IQggBQ0DCyALQR9rIQhBACEFA0AgBSAKRkUEQCAWIBcgBUECdGoiBC0AAkEBdGoiBiAGLwEAIgZBAWo7AQAgBCAIIAZnaiIJOgADIAQgBiAJdCAKazsBACAFQQFqIQUMAQsLAkACQCAOQf//A3EEQCAHQRxqIgQgFSAUEAgiCEGIf0sNAiAHQRRqIAQgDBAJIAdBDGogBCAMEAkgBygCICIIQSBLDQECQCAHAn8gBygCJCIEIAcoAixPBEAgByAEIAhBA3ZrIgU2AiQgCEEHcQwBCyAEIAcoAigiBUYNASAHIAQgBCAFayAIQQN2IgYgBCAGayAFSRsiBGsiBTYCJCAIIARBA3RrCyIINgIgIAcgBSgAADYCHAtBACEFA0ACQAJAIAhBIU8EQCAHQbAaNgIkDAELIAcCfyAHKAIkIgQgBygCLE8EQCAHIAQgCEEDdmsiBDYCJEEBIQkgCEEHcQwBCyAEIAcoAigiBkYNASAHIAQgCEEDdiIJIAQgBmsgBCAJayAGTyIJGyIGayIENgIkIAggBkEDdGsLNgIgIAcgBCgAADYCHCAJRSAFQfsBS3INACAAIAVqIgggB0EUaiAHQRxqIgQQCjoAACAIIAdBDGogBBAKOgABAkAgBygCICIGQSFPBEAgB0GwGjYCJAwBCyAHKAIkIgQgBygCLE8EQCAHIAZBB3E2AiAgByAEIAZBA3ZrIgQ2AiQgByAEKAAANgIcDAMLIAQgBygCKCIJRg0AIAcgBiAEIAlrIAZBA3YiBiAEIAZrIgYgCUkbIgpBA3RrNgIgIAcgBCAKayIENgIkIAcgBCgAADYCHCAGIAlPDQILIAVBAnIhBQsgAEEBaiEMAn8CQANAQbp/IQggBUH9AUsNByAAIAVqIgogB0EUaiAHQRxqEAo6AAAgBSAMaiELIAcoAiAiBkEgSw0BAkAgBwJ/IAcoAiQiBCAHKAIsTwRAIAcgBCAGQQN2ayIENgIkIAZBB3EMAQsgBCAHKAIoIglGDQEgByAEIAQgCWsgBkEDdiIOIAQgDmsgCUkbIglrIgQ2AiQgBiAJQQN0aws2AiAgByAEKAAANgIcCyAFQf0BRg0HIAsgB0EMaiAHQRxqEAo6AAAgBUECaiEFIAcoAiAiBkEgTQRAIAcCfyAHKAIkIgQgBygCLE8EQCAHIAQgBkEDdmsiCDYCJCAGQQdxDAELIAQgBygCKCIIRg0CIAcgBCAEIAhrIAZBA3YiCSAEIAlrIAhJGyIEayIINgIkIAYgBEEDdGsLNgIgIAcgCCgAADYCHAwBCwsgB0GwGjYCJCAAIAVqIAdBFGogB0EcahAKOgAAIApBA2oMAQsgB0GwGjYCJCALIAdBDGogB0EcahAKOgAAIApBAmoLIABrIQgMBAsgCCAHQRRqIAdBHGoiBBAKOgACIAggB0EMaiAEEAo6AAMgBUEEaiEFIAcoAiAhCAwACwALIAdBHGoiBCAVIBQQCCIIQYh/Sw0BIAdBFGogBCAMEAkgB0EMaiAEIAwQCSAHKAIgIghBIEsNAAJAIAcCfyAHKAIkIgQgBygCLE8EQCAHIAQgCEEDdmsiBTYCJCAIQQdxDAELIAQgBygCKCIFRg0BIAcgBCAEIAVrIAhBA3YiBiAEIAZrIAVJGyIEayIFNgIkIAggBEEDdGsLIgg2AiAgByAFKAAANgIcC0EAIQUDQAJAAkAgCEEhTwRAIAdBsBo2AiQMAQsgBwJ/IAcoAiQiBCAHKAIsTwRAIAcgBCAIQQN2ayIENgIkQQEhCSAIQQdxDAELIAQgBygCKCIGRg0BIAcgBCAIQQN2IgkgBCAGayAEIAlrIAZPIgkbIgZrIgQ2AiQgCCAGQQN0aws2AiAgByAEKAAANgIcIAlFIAVB+wFLcg0AIAAgBWoiCCAHQRRqIAdBHGoiBBALOgAAIAggB0EMaiAEEAs6AAECQCAHKAIgIgZBIU8EQCAHQbAaNgIkDAELIAcoAiQiBCAHKAIsTwRAIAcgBkEHcTYCICAHIAQgBkEDdmsiBDYCJCAHIAQoAAA2AhwMAwsgBCAHKAIoIglGDQAgByAGIAQgCWsgBkEDdiIGIAQgBmsiBiAJSRsiCkEDdGs2AiAgByAEIAprIgQ2AiQgByAEKAAANgIcIAYgCU8NAgsgBUECciEFCyAAQQFqIQwCfwJAA0BBun8hCCAFQf0BSw0GIAAgBWoiCiAHQRRqIAdBHGoQCzoAACAFIAxqIQsgBygCICIGQSBLDQECQCAHAn8gBygCJCIEIAcoAixPBEAgByAEIAZBA3ZrIgQ2AiQgBkEHcQwBCyAEIAcoAigiCUYNASAHIAQgBCAJayAGQQN2Ig4gBCAOayAJSRsiCWsiBDYCJCAGIAlBA3RrCzYCICAHIAQoAAA2AhwLIAVB/QFGDQYgCyAHQQxqIAdBHGoQCzoAACAFQQJqIQUgBygCICIGQSBNBEAgBwJ/IAcoAiQiBCAHKAIsTwRAIAcgBCAGQQN2ayIINgIkIAZBB3EMAQsgBCAHKAIoIghGDQIgByAEIAQgCGsgBkEDdiIJIAQgCWsgCEkbIgRrIgg2AiQgBiAEQQN0aws2AiAgByAIKAAANgIcDAELCyAHQbAaNgIkIAAgBWogB0EUaiAHQRxqEAs6AAAgCkEDagwBCyAHQbAaNgIkIAsgB0EMaiAHQRxqEAs6AAAgCkECagsgAGshCAwDCyAIIAdBFGogB0EcaiIEEAs6AAIgCCAHQQxqIAQQCzoAAyAFQQRqIQUgBygCICEIDAALAAtBbCEICyAIQYh/Sw0CC0EAIQUgAUEAQTT8CwAgCCEGQQAhBANAIAUgBkcEQCAAIAVqIggtAAAiCUEMSw0CIAEgCUECdGoiCSAJKAIAQQFqNgIAIAVBAWohBUEBIAgtAAB0QQF1IARqIQQMAQsLQWwhCCAERQ0BIARnIgVBHHNBC0sNASADQSAgBWsiAzYCAEGAgICAeEEBIAN0IARrIgNnIgR2IANHDQEgACAGakEgIARrIgA6AAAgASAAQQJ0aiIAIAAoAgBBAWo2AgAgASgCBCIAQQJJIABBAXFyDQEgAiAGQQFqNgIAIA1BAWohCAwBC0FsIQgLIAdBMGokACAIC/UBAQF/IAJFBEAgAEIANwIAIABBADYCECAAQgA3AghBuH8PCyAAIAE2AgwgACABQQRqNgIQIAJBBE8EQCAAIAEgAmoiAUEEayIDNgIIIAAgAygAADYCACABQQFrLQAAIgEEQCAAQQggAWdBH3NrNgIEIAIPCyAAQQA2AgRBfw8LIAAgATYCCCAAIAEtAAAiAzYCAAJAAkACQCACQQJrDgIBAAILIAAgAS0AAkEQdCADciIDNgIACyAAIAEtAAFBCHQgA2o2AgALIAEgAmpBAWstAAAiAUUEQCAAQQA2AgRBbA8LIAAgAWcgAkEDdGtBCWo2AgQgAguuAQEEfyABIAIvAQAiAyABKAIEaiIENgIEIAAgA0ECdEGwGWooAgAgASgCAEEAIARrdnE2AgACQCAEQSFPBEAgAUGwGjYCCAwBCyABKAIIIgMgASgCEE8EQCABEAwMAQsgAyABKAIMIgVGDQAgASADIAMgBWsgBEEDdiIGIAMgBmsgBUkbIgNrIgU2AgggASAEIANBA3RrNgIEIAEgBSgAADYCAAsgACACQQRqNgIEC0wBBH8gACgCBCAAKAIAQQJ0aiICLQACIQMgAi8BACEEIAEgASgCBCIFIAItAAMiAmo2AgQgACAEIAEoAgAgBXRBACACa3ZqNgIAIAMLVgEEfyAAKAIEIAAoAgBBAnRqIgItAAIhAyACLwEAIQQgASACLQADIgIgASgCBGoiBTYCBCAAIAQgAkECdEGwGWooAgAgASgCAEEAIAVrdnFqNgIAIAMLLwEBfyAAIAAoAgQiAUEHcTYCBCAAIAAoAgggAUEDdmsiATYCCCAAIAEoAAA2AgALCAAgAEGIf0sLxQkCDX8CfiMAQRBrIgskACALQQA2AgwgC0EANgIIAn8CQCADQdQJaiIFIAMgC0EIaiALQQxqIAEgAiADQegAahAHIhBBiH9LDQAgCygCCCEIQQogACgCACIJQf8BcSIHIAdBCk8bQQFqIgQgCygCDCIBTwRAAkAgASAETw0AIAQgAWshAkEAIQEDQCABIAhGBEAgBCEBA0AgASACTQRAA0AgAkUNBSADIAJBAnRqQQA2AgAgAkEBayECDAALAAUgAyABQQJ0aiADIAEgAmtBAnRqKAIANgIAIAFBAWshAQwBCwALAAUgASAFaiIKIAJBACAKLQAAIgobIApqOgAAIAFBAWohAQwBCwALAAsgBCEBC0FUIAEgB0EBaksNARogAEEEaiEKIAAgCUH/gYB4cSABQRB0QYCA/AdxcjYCACABQQFqIQ4gA0E0aiEEQQAhAUEAIQIDQCACIA5GRQRAIAMgAkECdCIAaigCACEHIAAgBGogATYCACACQQFqIQIgASAHaiEBDAELCyADQdQHaiEHIAhBA2shAUEAIQADQAJAQQAhAiAAIAFOBEADQCAAIAhODQIgBCAAIAVqLQAAQQJ0aiIBIAEoAgAiAUEBajYCACABIAdqIAA6AAAgAEEBaiEADAALAAUDQCACQQRGRQRAIAQgBSAAIAJyIglqLQAAQQJ0aiIMIAwoAgAiDEEBajYCACAHIAxqIAk6AAAgAkEBaiECDAELCyAAQQRqIQAMAgsACwsgAygCACEIQQAhAEEBIQkDQCAJIA5GDQEgDiAJayEEIAMgCUECdGooAgAhBQJAAkACQAJAAkACQEEBIAl0QQF1IgxBAWsOCAABBAIEBAQDBAtBACECIAVBACAFQQBKGyEGIAAhAQNAIAIgBkYNBSAKIAFBAXRqIg0gByACIAhqai0AADoAASANIAQ6AAAgAkEBaiECIAFBAWohAQwACwALQQAhAiAFQQAgBUEAShshDSAAIQEDQCACIA1GDQQgCiABQQF0aiIGIAcgAiAIamotAAAiDzoAAyAGIAQ6AAIgBiAPOgABIAYgBDoAACACQQFqIQIgAUECaiEBDAALAAtBACECIAVBACAFQQBKGyEGIARB/wFxrSERIAAhAQNAIAIgBkYNAyAKIAFBAXRqIAcgAiAIamoxAABCCIYgEYRCgYCEgJCAwAB+NwAAIAJBAWohAiABQQRqIQEMAAsAC0EAIQIgBUEAIAVBAEobIQYgBEH/AXGtIREgACEBA0AgAiAGRg0CIAogAUEBdGoiBCAHIAIgCGpqMQAAQgiGIBGEQoGAhICQgMAAfiISNwAIIAQgEjcAACACQQFqIQIgAUEIaiEBDAALAAtBACEBIAVBACAFQQBKGyENIARB/wFxrSESIAAhBANAIAEgDUYNASAKIARBAXRqIQ8gByABIAhqajEAAEIIhiAShEKBgISAkIDAAH4hEUEAIQIDQCACIAxORQRAIA8gAkEBdGoiBiARNwAYIAYgETcAECAGIBE3AAggBiARNwAAIAJBEGohAgwBCwsgAUEBaiEBIAQgDGohBAwACwALIAlBAWohCSAFIAhqIQggBSAMbCAAaiEADAALAAsgEAshAiALQRBqJAAgAgufAwIBfgF/AkACQAJAAkACQAJAQQEgBCADa3QiCEEBaw4IAAEEAgQEBAMECyAGQRh0IANBEHRqIQMDQCABIAJGDQUgACABLQAAIgQgBEEIdCAFciAGQQFGGyADcjYBACABQQFqIQEgAEEEaiEADAALAAsgBkEYdCADQRB0aiEDA0AgASACRg0EIAAgAS0AACIEIARBCHQgBXIgBkEBRhsgA3IiBDYBBCAAIAQ2AQAgAUEBaiEBIABBCGohAAwACwALA0AgASACRg0DIAAgAS0AACADIAUgBhAQIgc3AQggACAHNwEAIAFBAWohASAAQRBqIQAMAAsACwNAIAEgAkYNAiAAIAEtAAAgAyAFIAYQECIHNwEYIAAgBzcBECAAIAc3AQggACAHNwEAIAFBAWohASAAQSBqIQAMAAsACwNAIAEgAkYNASAAIAhBAnRqIQQgAS0AACADIAUgBhAQIQcDQCAAIARGRQRAIAAgBzcBGCAAIAc3ARAgACAHNwEIIAAgBzcBACAAQSBqIQAMAQsLIAFBAWohASAEIQAMAAsACwsmACADQRh0IAFBEHRqIAAgAEEIdCACciADQQFGG3KtQoGAgIAQfgu7BgEKfyMAQSBrIgUkACAELwECIQsgBUEMaiACIAMQCCIDQYh/TQRAIARBBGohCCAAIAFqIQkCQAJAAkAgAUEETwRAIAlBA2shDUEAIAtrQR9xIQwgBSgCFCEDIAUoAhghByAFKAIcIQ4gBSgCDCEGIAUoAhAhBANAIARBIEsEQEGwGiEDDAQLAkAgAyAOTwRAIARBB3EhAiAEQQN2IQZBASEEDAELIAMgB0YNBCAEIARBA3YiAiADIAdrIAMgAmsgB08iBBsiBkEDdGshAgsgAyAGayIDKAAAIQYgBEUgACANT3INAiAIIAYgAnQgDHZBAXRqIgQtAAAhCiAAIAQtAAE6AAAgCCAGIAIgCmoiAnQgDHZBAXRqIgQtAAAhCiAAIAQtAAE6AAEgAiAKaiEEIABBAmohAAwACwALIAUoAhAiBEEhTwRAIAVBsBo2AhQMAwsgBSgCFCIDIAUoAhxPBEAgBSAEQQdxIgI2AhAgBSADIARBA3ZrIgM2AhQgBSADKAAANgIMIAIhBAwDCyADIAUoAhgiAkYNAiAFIAQgAyACayAEQQN2IgQgAyAEayACSRsiAkEDdGsiBDYCECAFIAMgAmsiAjYCFCAFIAIoAAA2AgwMAgsgAiEECyAFIAQ2AhAgBSADNgIUIAUgBjYCDAtBACALa0EfcSEHA0ACQCAEQSFPBEAgBUGwGjYCFAwBCyAFAn8gBSgCFCICIAUoAhxPBEAgBSACIARBA3ZrIgM2AhRBASEGIARBB3EMAQsgAiAFKAIYIgNGDQEgBSACIARBA3YiBiACIANrIAIgBmsgA08iBhsiAmsiAzYCFCAEIAJBA3RrCyIENgIQIAUgAygAACICNgIMIAZFIAAgCU9yDQAgCCACIAR0IAd2QQF0aiICLQABIQMgBSAEIAItAABqNgIQIAAgAzoAACAAQQFqIQAgBSgCECEEDAELCwNAIAAgCU9FBEAgCCAFKAIMIAUoAhAiAnQgB3ZBAXRqIgMtAAEhBCAFIAIgAy0AAGo2AhAgACAEOgAAIABBAWohAAwBCwtBbEFsIAEgBSgCEEEgRxsgBSgCFCAFKAIYRxshAwsgBUEgaiQAIAML/SEBGX8jAEHQAGsiBSQAQWwhBgJAIAFBBkkgA0EKSXINAAJAIAMgAi8ABCIHIAIvAAAiCiACLwACIglqakEGaiILSQ0AIAAgAUEDakECdiIMaiIIIAxqIg0gDGoiDCAAIAFqIhFLDQAgBC8BAiEOIAVBPGogAkEGaiICIAoQCCIGQYh/Sw0BIAVBKGogAiAKaiICIAkQCCIGQYh/Sw0BIAVBFGogAiAJaiICIAcQCCIGQYh/Sw0BIAUgAiAHaiADIAtrEAgiBkGIf0sNASAEQQRqIQogEUEDayESAkAgESAMa0EESQRAIAwhAyANIQIgCCEEDAELQQAgDmtBH3EhBkEAIQkgDCEDIA0hAiAIIQQDQCAJQQFxIAMgEk9yDQEgACAKIAUoAjwiCSAFKAJAIgt0IAZ2QQJ0aiIHLwEAOwAAIActAAIhECAHLQADIQ8gBCAKIAUoAigiEyAFKAIsIhR0IAZ2QQJ0aiIHLwEAOwAAIActAAIhFSAHLQADIRYgAiAKIAUoAhQiFyAFKAIYIhh0IAZ2QQJ0aiIHLwEAOwAAIActAAIhGSAHLQADIRogAyAKIAUoAgAiGyAFKAIEIhx0IAZ2QQJ0aiIHLwEAOwAAIActAAIhHSAHLQADIQcgACAPaiIPIAogCSALIBBqIgl0IAZ2QQJ0aiIALwEAOwAAIAUgCSAALQACajYCQCAALQADIQkgBCAWaiIEIAogEyAUIBVqIgt0IAZ2QQJ0aiIALwEAOwAAIAUgCyAALQACajYCLCAALQADIQsgAiAaaiICIAogFyAYIBlqIhB0IAZ2QQJ0aiIALwEAOwAAIAUgECAALQACajYCGCAALQADIRAgAyAHaiIHIAogGyAcIB1qIgB0IAZ2QQJ0aiIDLwEAOwAAIAUgACADLQACajYCBCAJIA9qIQAgBCALaiEEIAIgEGohAiAHIAMtAANqIQMgBUE8ahATIAVBKGoQE3IgBUEUahATciAFEBNyQQBHIQkMAAsACyAAIAhLIAQgDUtyDQBBbCEGIAIgDEsNAQJAAkAgCCAAayIJQQRPBEAgCEEDayEQQQAgDmtBH3EhCyAFKAJAIQYDQCAGQSFPBEAgBUGwGjYCRAwDCyAFAn8gBSgCRCIHIAUoAkxPBEAgBSAHIAZBA3ZrIgk2AkRBASEHIAZBB3EMAQsgByAFKAJIIglGDQMgBSAHIAZBA3YiDyAHIAlrIAcgD2sgCU8iBxsiD2siCTYCRCAGIA9BA3RrCyIGNgJAIAUgCSgAACIJNgI8IAdFIAAgEE9yDQIgACAKIAkgBnQgC3ZBAnRqIgYvAQA7AAAgBSAFKAJAIAYtAAJqIgc2AkAgACAGLQADaiIJIAogBSgCPCAHdCALdkECdGoiAC8BADsAACAFIAUoAkAgAC0AAmoiBjYCQCAJIAAtAANqIQAMAAsACyAFKAJAIgZBIU8EQCAFQbAaNgJEDAILIAUoAkQiCyAFKAJMTwRAIAUgBkEHcSIHNgJAIAUgCyAGQQN2ayIGNgJEIAUgBigAADYCPCAHIQYMAgsgCyAFKAJIIgdGDQEgBSAGIAsgB2sgBkEDdiIGIAsgBmsgB0kbIgdBA3RrIgY2AkAgBSALIAdrIgc2AkQgBSAHKAAANgI8DAELIAggAGshCQsCQCAJQQJJDQAgCEECayELQQAgDmtBH3EhEANAAkAgBkEhTwRAIAVBsBo2AkQMAQsgBQJ/IAUoAkQiByAFKAJMTwRAIAUgByAGQQN2ayIJNgJEQQEhByAGQQdxDAELIAcgBSgCSCIJRg0BIAUgByAGQQN2Ig8gByAJayAHIA9rIAlPIgcbIg9rIgk2AkQgBiAPQQN0awsiBjYCQCAFIAkoAAAiCTYCPCAHRSAAIAtLcg0AIAAgCiAJIAZ0IBB2QQJ0aiIHLwEAOwAAIAUgBSgCQCAHLQACaiIGNgJAIAAgBy0AA2ohAAwBCwsDQCAAIAtLDQEgACAKIAUoAjwgBnQgEHZBAnRqIgcvAQA7AAAgBSAFKAJAIActAAJqIgY2AkAgACAHLQADaiEADAALAAsCQCAAIAhPDQAgACAKIAUoAjwgBnRBACAOa3ZBAnRqIgAtAAA6AAAgBQJ/IAAtAANBAUYEQCAFKAJAIAAtAAJqDAELIAUoAkAiCEEfSw0BQSAgCCAALQACaiIAIABBIE8bCzYCQAsCQAJAIA0gBGsiBkEETwRAIA1BA2shCUEAIA5rQR9xIQcgBSgCLCEAA0AgAEEhTwRAIAVBsBo2AjAMAwsgBQJ/IAUoAjAiCCAFKAI4TwRAIAUgCCAAQQN2ayIGNgIwQQEhCCAAQQdxDAELIAggBSgCNCIGRg0DIAUgCCAAQQN2IgsgCCAGayAIIAtrIAZPIggbIgtrIgY2AjAgACALQQN0awsiADYCLCAFIAYoAAAiBjYCKCAIRSAEIAlPcg0CIAQgCiAGIAB0IAd2QQJ0aiIALwEAOwAAIAUgBSgCLCAALQACaiIINgIsIAQgAC0AA2oiBiAKIAUoAiggCHQgB3ZBAnRqIgQvAQA7AAAgBSAFKAIsIAQtAAJqIgA2AiwgBiAELQADaiEEDAALAAsgBSgCLCIAQSFPBEAgBUGwGjYCMAwCCyAFKAIwIgcgBSgCOE8EQCAFIABBB3EiCDYCLCAFIAcgAEEDdmsiADYCMCAFIAAoAAA2AiggCCEADAILIAcgBSgCNCIIRg0BIAUgACAHIAhrIABBA3YiACAHIABrIAhJGyIIQQN0ayIANgIsIAUgByAIayIINgIwIAUgCCgAADYCKAwBCyANIARrIQYLAkAgBkECSQ0AIA1BAmshCUEAIA5rQR9xIQsDQAJAIABBIU8EQCAFQbAaNgIwDAELIAUCfyAFKAIwIgggBSgCOE8EQCAFIAggAEEDdmsiBjYCMEEBIQcgAEEHcQwBCyAIIAUoAjQiBkYNASAFIAggAEEDdiIHIAggBmsgCCAHayAGTyIHGyIIayIGNgIwIAAgCEEDdGsLIgA2AiwgBSAGKAAAIgg2AiggB0UgBCAJS3INACAEIAogCCAAdCALdkECdGoiCC8BADsAACAFIAUoAiwgCC0AAmoiADYCLCAEIAgtAANqIQQMAQsLA0AgBCAJSw0BIAQgCiAFKAIoIAB0IAt2QQJ0aiIILwEAOwAAIAUgBSgCLCAILQACaiIANgIsIAQgCC0AA2ohBAwACwALAkAgBCANTw0AIAQgCiAFKAIoIAB0QQAgDmt2QQJ0aiIALQAAOgAAIAUCfyAALQADQQFGBEAgBSgCLCAALQACagwBCyAFKAIsIgRBH0sNAUEgIAQgAC0AAmoiACAAQSBPGws2AiwLAkACQCAMIAJrIgZBBE8EQCAMQQNrIQdBACAOa0EfcSEIIAUoAhghAANAIABBIU8EQCAFQbAaNgIcDAMLIAUCfyAFKAIcIgQgBSgCJE8EQCAFIAQgAEEDdmsiBjYCHEEBIQkgAEEHcQwBCyAEIAUoAiAiDUYNAyAFIAQgAEEDdiIGIAQgDWsgBCAGayANTyIJGyIEayIGNgIcIAAgBEEDdGsLIgA2AhggBSAGKAAAIgQ2AhQgCUUgAiAHT3INAiACIAogBCAAdCAIdkECdGoiAC8BADsAACAFIAUoAhggAC0AAmoiBDYCGCACIAAtAANqIg0gCiAFKAIUIAR0IAh2QQJ0aiICLwEAOwAAIAUgBSgCGCACLQACaiIANgIYIA0gAi0AA2ohAgwACwALIAUoAhgiAEEhTwRAIAVBsBo2AhwMAgsgBSgCHCIIIAUoAiRPBEAgBSAAQQdxIgQ2AhggBSAIIABBA3ZrIgA2AhwgBSAAKAAANgIUIAQhAAwCCyAIIAUoAiAiBEYNASAFIAAgCCAEayAAQQN2IgAgCCAAayAESRsiBEEDdGsiADYCGCAFIAggBGsiBDYCHCAFIAQoAAA2AhQMAQsgDCACayEGCwJAIAZBAkkNACAMQQJrIQ1BACAOa0EfcSEHA0ACQCAAQSFPBEAgBUGwGjYCHAwBCyAFAn8gBSgCHCIEIAUoAiRPBEAgBSAEIABBA3ZrIgY2AhxBASEIIABBB3EMAQsgBCAFKAIgIghGDQEgBSAEIABBA3YiBiAEIAhrIAQgBmsgCE8iCBsiBGsiBjYCHCAAIARBA3RrCyIANgIYIAUgBigAACIENgIUIAhFIAIgDUtyDQAgAiAKIAQgAHQgB3ZBAnRqIgQvAQA7AAAgBSAFKAIYIAQtAAJqIgA2AhggAiAELQADaiECDAELCwNAIAIgDUsNASACIAogBSgCFCAAdCAHdkECdGoiBC8BADsAACAFIAUoAhggBC0AAmoiADYCGCACIAQtAANqIQIMAAsACwJAIAIgDE8NACACIAogBSgCFCAAdEEAIA5rdkECdGoiAC0AADoAACAFAn8gAC0AA0EBRgRAIAUoAhggAC0AAmoMAQsgBSgCGCICQR9LDQFBICACIAAtAAJqIgAgAEEgTxsLNgIYCwJAIBEgA2tBBE8EQEEAIA5rQR9xIQQgBSgCBCEAA0AgAEEhTwRAIAVBsBo2AggMAwsgBQJ/IAUoAggiAiAFKAIQTwRAIAUgAiAAQQN2ayIGNgIIQQEhAiAAQQdxDAELIAIgBSgCDCIMRg0DIAUgAiAAQQN2IgggAiAMayACIAhrIAxPIgIbIgxrIgY2AgggACAMQQN0awsiADYCBCAFIAYoAAAiDDYCACACRSADIBJPcg0CIAMgCiAMIAB0IAR2QQJ0aiIALwEAOwAAIAUgBSgCBCAALQACaiICNgIEIAMgAC0AA2oiAyAKIAUoAgAgAnQgBHZBAnRqIgIvAQA7AAAgBSAFKAIEIAItAAJqIgA2AgQgAyACLQADaiEDDAALAAsgBSgCBCIAQSFPBEAgBUGwGjYCCAwBCyAFKAIIIgQgBSgCEE8EQCAFIABBB3EiAjYCBCAFIAQgAEEDdmsiADYCCCAFIAAoAAA2AgAgAiEADAELIAQgBSgCDCICRg0AIAUgACAEIAJrIABBA3YiACAEIABrIAJJGyICQQN0ayIANgIEIAUgBCACayICNgIIIAUgAigAADYCAAsCQCARIANrQQJJDQAgEUECayEEQQAgDmtBH3EhDANAAkAgAEEhTwRAIAVBsBo2AggMAQsgBQJ/IAUoAggiAiAFKAIQTwRAIAUgAiAAQQN2ayIGNgIIQQEhCSAAQQdxDAELIAIgBSgCDCIIRg0BIAUgAiAAQQN2Ig0gAiAIayACIA1rIAhPIgkbIgJrIgY2AgggACACQQN0awsiADYCBCAFIAYoAAAiAjYCACAJRSADIARLcg0AIAMgCiACIAB0IAx2QQJ0aiICLwEAOwAAIAUgBSgCBCACLQACaiIANgIEIAMgAi0AA2ohAwwBCwsDQCADIARLDQEgAyAKIAUoAgAgAHQgDHZBAnRqIgIvAQA7AAAgBSAFKAIEIAItAAJqIgA2AgQgAyACLQADaiEDDAALAAsCQCADIBFPDQAgAyAKIAUoAgAgAHRBACAOa3ZBAnRqIgItAAA6AAAgAi0AA0EBRgRAIAUoAgQgAi0AAmohAAwBCyAFKAIEIgBBH0sNAEEgIAAgAi0AAmoiACAAQSBPGyEAC0FsQWxBbEFsQWxBbEFsQWwgASAAQSBHGyAFKAIIIAUoAgxHGyAFKAIYQSBHGyAFKAIcIAUoAiBHGyAFKAIsQSBHGyAFKAIwIAUoAjRHGyAFKAJAQSBHGyAFKAJEIAUoAkhHGyEGDAELQWwhBgsgBUHQAGokACAGCxkAIAAoAgggACgCEEkEQEEDDwsgABAMQQAL8xwBFn8jAEHQAGsiBSQAQWwhCAJAIAFBBkkgA0EKSXINAAJAIAMgAi8ABCIGIAIvAAAiCiACLwACIglqakEGaiISSQ0AIAAgAUEDakECdiILaiIHIAtqIg4gC2oiCyAAIAFqIg9LDQAgBC8BAiEMIAVBPGogAkEGaiICIAoQCCIIQYh/Sw0BIAVBKGogAiAKaiICIAkQCCIIQYh/Sw0BIAVBFGogAiAJaiICIAYQCCIIQYh/Sw0BIAUgAiAGaiADIBJrEAgiCEGIf0sNASAEQQRqIQogD0EDayESAkAgDyALa0EESQRAIAshAyAOIQIgByEEDAELQQAgDGtBH3EhCEEAIQYgCyEDIA4hAiAHIQQDQCAGQQFxIAMgEk9yDQEgCiAFKAI8IgYgBSgCQCIJdCAIdkEBdGoiDS0AACEQIAAgDS0AAToAACAKIAUoAigiDSAFKAIsIhF0IAh2QQF0aiITLQAAIRUgBCATLQABOgAAIAogBSgCFCITIAUoAhgiFnQgCHZBAXRqIhQtAAAhFyACIBQtAAE6AAAgCiAFKAIAIhQgBSgCBCIYdCAIdkEBdGoiGS0AACEaIAMgGS0AAToAACAKIAYgCSAQaiIGdCAIdkEBdGoiCS0AASEQIAUgBiAJLQAAajYCQCAAIBA6AAEgCiANIBEgFWoiBnQgCHZBAXRqIgktAAEhDSAFIAYgCS0AAGo2AiwgBCANOgABIAogEyAWIBdqIgZ0IAh2QQF0aiIJLQABIQ0gBSAGIAktAABqNgIYIAIgDToAASAKIBQgGCAaaiIGdCAIdkEBdGoiCS0AASENIAUgBiAJLQAAajYCBCADIA06AAEgA0ECaiEDIAJBAmohAiAEQQJqIQQgAEECaiEAIAVBPGoQEyAFQShqEBNyIAVBFGoQE3IgBRATckEARyEGDAALAAsgACAHSyAEIA5Lcg0AQWwhCCACIAtLDQECQCAHIABrQQROBEAgB0EDayEQQQAgDGtBH3EhDQNAIAUoAkAiBkEhTwRAIAVBsBo2AkQMAwsgBQJ/IAUoAkQiCCAFKAJMTwRAIAUgCCAGQQN2ayIINgJEQQEhCSAGQQdxDAELIAggBSgCSCIJRg0DIAUgCCAGQQN2IhEgCCAJayAIIBFrIAlPIgkbIhFrIgg2AkQgBiARQQN0awsiBjYCQCAFIAgoAAAiCDYCPCAJRSAAIBBPcg0CIAogCCAGdCANdkEBdGoiCC0AASEJIAUgBiAILQAAajYCQCAAIAk6AAAgCiAFKAI8IAUoAkAiBnQgDXZBAXRqIggtAAEhCSAFIAYgCC0AAGo2AkAgACAJOgABIABBAmohAAwACwALIAUoAkAiBkEhTwRAIAVBsBo2AkQMAQsgBSgCRCIJIAUoAkxPBEAgBSAGQQdxIgg2AkAgBSAJIAZBA3ZrIgY2AkQgBSAGKAAANgI8IAghBgwBCyAJIAUoAkgiCEYNACAFIAYgCSAIayAGQQN2IgYgCSAGayAISRsiCEEDdGsiBjYCQCAFIAkgCGsiCDYCRCAFIAgoAAA2AjwLQQAgDGtBH3EhCANAAkAgBkEhTwRAIAVBsBo2AkQMAQsgBQJ/IAUoAkQiCSAFKAJMTwRAIAUgCSAGQQN2ayIMNgJEQQEhCSAGQQdxDAELIAkgBSgCSCIMRg0BIAUgCSAGQQN2Ig0gCSAMayAJIA1rIAxPIgkbIg1rIgw2AkQgBiANQQN0awsiBjYCQCAFIAwoAAAiDDYCPCAJRSAAIAdPcg0AIAogDCAGdCAIdkEBdGoiCS0AASEMIAUgBiAJLQAAajYCQCAAIAw6AAAgAEEBaiEAIAUoAkAhBgwBCwsDQCAAIAdPRQRAIAogBSgCPCAFKAJAIgZ0IAh2QQF0aiIJLQABIQwgBSAGIAktAABqNgJAIAAgDDoAACAAQQFqIQAMAQsLAkAgDiAEa0EETgRAIA5BA2shCQNAIAUoAiwiAEEhTwRAIAVBsBo2AjAMAwsgBQJ/IAUoAjAiByAFKAI4TwRAIAUgByAAQQN2ayIGNgIwQQEhByAAQQdxDAELIAcgBSgCNCIGRg0DIAUgByAAQQN2IgwgByAGayAHIAxrIAZPIgcbIgxrIgY2AjAgACAMQQN0awsiADYCLCAFIAYoAAAiBjYCKCAHRSAEIAlPcg0CIAogBiAAdCAIdkEBdGoiBy0AASEGIAUgACAHLQAAajYCLCAEIAY6AAAgCiAFKAIoIAUoAiwiAHQgCHZBAXRqIgctAAEhBiAFIAAgBy0AAGo2AiwgBCAGOgABIARBAmohBAwACwALIAUoAiwiAEEhTwRAIAVBsBo2AjAMAQsgBSgCMCIGIAUoAjhPBEAgBSAAQQdxIgc2AiwgBSAGIABBA3ZrIgA2AjAgBSAAKAAANgIoIAchAAwBCyAGIAUoAjQiB0YNACAFIAAgBiAHayAAQQN2IgAgBiAAayAHSRsiB0EDdGsiADYCLCAFIAYgB2siBzYCMCAFIAcoAAA2AigLA0ACQCAAQSFPBEAgBUGwGjYCMAwBCyAFAn8gBSgCMCIHIAUoAjhPBEAgBSAHIABBA3ZrIgY2AjBBASEHIABBB3EMAQsgByAFKAI0IgZGDQEgBSAHIABBA3YiCSAHIAZrIAcgCWsgBk8iBxsiCWsiBjYCMCAAIAlBA3RrCyIANgIsIAUgBigAACIGNgIoIAdFIAQgDk9yDQAgCiAGIAB0IAh2QQF0aiIHLQABIQYgBSAAIActAABqNgIsIAQgBjoAACAEQQFqIQQgBSgCLCEADAELCwNAIAQgDk9FBEAgCiAFKAIoIAUoAiwiAHQgCHZBAXRqIgctAAEhBiAFIAAgBy0AAGo2AiwgBCAGOgAAIARBAWohBAwBCwsCQCALIAJrQQROBEAgC0EDayEOA0AgBSgCGCIAQSFPBEAgBUGwGjYCHAwDCyAFAn8gBSgCHCIEIAUoAiRPBEAgBSAEIABBA3ZrIgQ2AhxBASEGIABBB3EMAQsgBCAFKAIgIgdGDQMgBSAEIABBA3YiBiAEIAdrIAQgBmsgB08iBhsiB2siBDYCHCAAIAdBA3RrCyIANgIYIAUgBCgAACIENgIUIAZFIAIgDk9yDQIgCiAEIAB0IAh2QQF0aiIELQABIQcgBSAAIAQtAABqNgIYIAIgBzoAACAKIAUoAhQgBSgCGCIAdCAIdkEBdGoiBC0AASEHIAUgACAELQAAajYCGCACIAc6AAEgAkECaiECDAALAAsgBSgCGCIAQSFPBEAgBUGwGjYCHAwBCyAFKAIcIgcgBSgCJE8EQCAFIABBB3EiBDYCGCAFIAcgAEEDdmsiADYCHCAFIAAoAAA2AhQgBCEADAELIAcgBSgCICIERg0AIAUgACAHIARrIABBA3YiACAHIABrIARJGyIEQQN0ayIANgIYIAUgByAEayIENgIcIAUgBCgAADYCFAsDQAJAIABBIU8EQCAFQbAaNgIcDAELIAUCfyAFKAIcIgQgBSgCJE8EQCAFIAQgAEEDdmsiBDYCHEEBIQYgAEEHcQwBCyAEIAUoAiAiB0YNASAFIAQgAEEDdiIOIAQgB2sgBCAOayAHTyIGGyIHayIENgIcIAAgB0EDdGsLIgA2AhggBSAEKAAAIgQ2AhQgBkUgAiALT3INACAKIAQgAHQgCHZBAXRqIgQtAAEhByAFIAAgBC0AAGo2AhggAiAHOgAAIAJBAWohAiAFKAIYIQAMAQsLA0AgAiALT0UEQCAKIAUoAhQgBSgCGCIAdCAIdkEBdGoiBC0AASEHIAUgACAELQAAajYCGCACIAc6AAAgAkEBaiECDAELCwJAIA8gA2tBBE4EQANAIAUoAgQiAEEhTwRAIAVBsBo2AggMAwsgBQJ/IAUoAggiAiAFKAIQTwRAIAUgAiAAQQN2ayIENgIIQQEhAiAAQQdxDAELIAIgBSgCDCIERg0DIAUgAiAAQQN2IgsgAiAEayACIAtrIARPIgIbIgtrIgQ2AgggACALQQN0awsiADYCBCAFIAQoAAAiBDYCACACRSADIBJPcg0CIAogBCAAdCAIdkEBdGoiAi0AASEEIAUgACACLQAAajYCBCADIAQ6AAAgCiAFKAIAIAUoAgQiAHQgCHZBAXRqIgItAAEhBCAFIAAgAi0AAGo2AgQgAyAEOgABIANBAmohAwwACwALIAUoAgQiAEEhTwRAIAVBsBo2AggMAQsgBSgCCCIEIAUoAhBPBEAgBSAAQQdxIgI2AgQgBSAEIABBA3ZrIgA2AgggBSAAKAAANgIAIAIhAAwBCyAEIAUoAgwiAkYNACAFIAAgBCACayAAQQN2IgAgBCAAayACSRsiAkEDdGsiADYCBCAFIAQgAmsiAjYCCCAFIAIoAAA2AgALA0ACQCAAQSFPBEAgBUGwGjYCCAwBCyAFAn8gBSgCCCICIAUoAhBPBEAgBSACIABBA3ZrIgQ2AghBASECIABBB3EMAQsgAiAFKAIMIgRGDQEgBSACIABBA3YiCyACIARrIAIgC2sgBE8iAhsiC2siBDYCCCAAIAtBA3RrCyIANgIEIAUgBCgAACIENgIAIAJFIAMgD09yDQAgCiAEIAB0IAh2QQF0aiICLQABIQQgBSAAIAItAABqNgIEIAMgBDoAACADQQFqIQMgBSgCBCEADAELCwNAIAMgD09FBEAgCiAFKAIAIAUoAgQiAHQgCHZBAXRqIgItAAEhBCAFIAAgAi0AAGo2AgQgAyAEOgAAIANBAWohAwwBCwtBbEFsQWxBbEFsQWxBbEFsIAEgBSgCBEEgRxsgBSgCCCAFKAIMRxsgBSgCGEEgRxsgBSgCHCAFKAIgRxsgBSgCLEEgRxsgBSgCMCAFKAI0RxsgBSgCQEEgRxsgBSgCRCAFKAJIRxshCAwBC0FsIQgLIAVB0ABqJAAgCAsaACAABEAgAQRAIAIgACABEQIADwsgABACCwtSAQN/AkAgACgCmOsBIgFFDQAgASgCACABKAK01QEiAiABKAK41QEiAxAVIAIEQCADIAEgAhECAAwBCyABEAILIABBADYCqOsBIABCADcDmOsBC5QFAgR/An4jAEEQayIGJAACQCABIAJFckUEQEF/IQQMAQsCQEEBQQUgAxsiBCACSwRAIAJFIANBAUZyDQIgBkGo6r5pNgIMIAJFIgBFBEAgBkEMaiABIAL8CgAACyAGKAIMQajqvmlGDQIgBkHQ1LTCATYCDCAARQRAIAZBDGogASAC/AoAAAsgBigCDEFwcUHQ1LTCAUYNAgwBCyAAQQBBMPwLAEEBIQUCQCADQQFGDQAgAyEFIAEoAAAiA0Go6r5pRg0AIANBcHFB0NS0wgFHDQFBCCEEIAJBCEkNAiAAQQE2AhQgASgAACECIABBCDYCGCAAIAJB0NS0wgFrNgIcIAAgATUABDcDAEEAIQQMAgsgAiABIAIgBRAYIgJJBEAgAiEEDAILIAAgAjYCGCABIARqIgVBAWstAAAiAkEIcQRAQXIhBAwCCyACQSBxIgNFBEAgBS0AACIFQacBSwRAQXAhBAwDCyAFQQdxrUIBIAVBA3ZBCmqthiIIQgOIfiAIfCEJIARBAWohBAsgAkEGdiEFIAJBAnYhBwJAAkACQAJAIAJBA3EiAkEBaw4DAAECAwsgASAEai0AACECIARBAWohBAwCCyABIARqLwAAIQIgBEECaiEEDAELIAEgBGooAAAhAiAEQQRqIQQLIAdBAXEhBwJ+AkACQAJAAkAgBUEBaw4DAQIDAAtCfyADRQ0DGiABIARqMQAADAMLIAEgBGozAABCgAJ8DAILIAEgBGo1AAAMAQsgASAEaikAAAshCCAAIAc2AiAgACACNgIcIAAgCDcDAEEAIQQgAEEANgIUIAAgCCAJIAMbIgg3AwggAEKAgAggCCAIQoCACFobPgIQDAELQXYhBAsgBkEQaiQAIAQLXwEBf0G4fyEDIAFBAUEFIAIbIgFPBH8gACABakEBay0AACIAQQNxQQJ0QcAaaigCACABaiAAQQR2QQxxQdAaaigCAGogAEEgcSIBRWogAUEFdiAAQcAASXFqBUG4fwsLxAICBH8CfiMAQUBqIgQkAAJAA0AgAUEFTwRAAkAgACgAAEFwcUHQ1LTCAUYEQEJ+IQYgAUEISQ0EIAAoAAQiA0F3Sw0EIANBCGoiAiABSw0EIANBgX9JDQEMBAsgBEEQaiIDIAAgAUEAEBchAkJ+IAQpAxBCACAEKAIkQQFHGyACGyIGQn1WDQMgBiAHfCIHIAZUIQJCfiEGIAINAyADIAAgAUEAEBciAkGIf0sgAnINAyABIAQoAigiA2shAiAAIANqIQMDQCADIAIgBEEEahAaIgVBiH9LDQQgAiAFQQNqIgVJDQQgAiAFayECIAMgBWohAyAEKAIIRQ0ACyAEKAIwBH8gAkEESQ0EIANBBGoFIAMLIABrIgJBiH9LDQMLIAEgAmshASAAIAJqIQAMAQsLQn4gByABGyEGCyAEQUBrJAAgBgtkAQF/Qbh/IQMCQCABQQNJDQAgAC0AAiEBIAIgAC8AACIAQQFxNgIEIAIgAEEBdkEDcSIDNgIAIAIgACABQRB0ckEDdiIANgIIAkACQCADQQFrDgMCAQABC0FsDwsgACEDCyADC7ABAAJ/IAIgACgClOsBBH8gACgC0OkBBUGAgAgLIgIgA2pBQGtLBEAgACABIAJqQSBqIgE2AvzrAUEBIQIgASADagwBCyADQYCABE0EQCAAIABBiOwBaiIBNgL86wFBACECIAEgA2oMAQsgACABIARqIgEgA2siAkHg/wNqIgQgAiAFGzYC/OsBQQIhAiADIARqQYCABGsgASAFGwshAyAAIAI2AoTsASAAIAM2AoDsAQuyBwIEfwF+IwBBgAFrIg4kACAOIAM2AnwCQAJAAkACQAJAAkAgAkEBaw4DAAMCAQsgBkUEQEG4fyEKDAULIAMgBS0AACICSQ0DIAIgCGotAAAhAyAHIAJBAnRqKAIAIQIgAEEAOgALIABCADcCACAAIAI2AgwgACADOgAKIABBADsBCCABIAA2AgBBASEKDAQLIAEgCTYCAEEAIQoMAwsgCkUNAUEAIQogC0UgDEEZSXINAkEIIAR0QQhyIQBBACEDA0AgACADTQ0DIANBQGshAwwACwALQWwhCiAOIA5B/ABqIA5B+ABqIAUgBhAGIgNBiH9LDQEgDigCeCICIARLDQEgAEEMaiEMIA4oAnxBAWohEUGAgAIgAnRBEHYhEEEAIQRBASEFQQEgAnQiCkEBayILIQkDQCAEIBFHBEACQCAOIARBAXQiD2ovAQAiBkH//wNGBEAgDCAJQQN0aiAENgIAIAlBAWshCUEBIQYMAQsgBUEAIBAgBsFKGyEFCyANIA9qIAY7AQAgBEEBaiEEDAELCyAAIAI2AgQgACAFNgIAAkAgCSALRgRAIA1B6gBqIRBBACEJQQAhBQNAIAkgEUYEQCAKQQN2IApBAXZqQQNqIglBAXQhEUEAIQZBACEFA0AgBSAKTw0EIAUgEGohD0EAIQQDQCAEQQJHBEAgDCAEIAlsIAZqIAtxQQN0aiAEIA9qLQAANgIAIARBAWohBAwBCwsgBUECaiEFIAYgEWogC3EhBgwACwAFIA4gCUEBdGouAQAhBiAFIBBqIg8gEjcAAEEIIQQDQCAEIAZIBEAgBCAPaiASNwAAIARBCGohBAwBCwsgEkKBgoSIkKDAgAF8IRIgCUEBaiEJIAUgBmohBQwBCwALAAsgCkEDdiAKQQF2akEDaiEQQQAhBUEAIQYDQCAFIBFGDQFBACEEIA4gBUEBdGouAQAiD0EAIA9BAEobIQ8DQCAEIA9HBEAgDCAGQQN0aiAFNgIAA0AgBiAQaiALcSIGIAlLDQALIARBAWohBAwBCwsgBUEBaiEFDAALAAsgAEEIaiEJIAJBH2shC0EAIQYDQCAGIApHBEAgDSAJIAZBA3RqIgIoAgQiBEEBdGoiBSAFLwEAIgVBAWo7AQAgAiALIAVnaiIMOgADIAIgBSAMdCAKazsBACACIAQgCGotAAA6AAIgAiAHIARBAnRqKAIANgIEIAZBAWohBgwBCwsgASAANgIAIAMhCgwBC0FsIQoLIA5BgAFqJAAgCgtwAQR/IABCADcCACACBEAgAUEKaiEGIAEoAgQhBEEAIQJBACEBA0AgASAEdkUEQCACIAYgAUEDdGotAAAiBSACIAVLGyECIAFBAWohASADIAVBFktqIQMMAQsLIAAgAjYCBCAAIANBCCAEa3Q2AgALC64BAQR/IAEgAigCBCIDIAEoAgRqIgQ2AgQgACADQQJ0QbAZaigCACABKAIAQQAgBGt2cTYCAAJAIARBIU8EQCABQbAaNgIIDAELIAEoAggiAyABKAIQTwRAIAEQDAwBCyADIAEoAgwiBUYNACABIAMgAyAFayAEQQN2IgYgAyAGayAFSRsiA2siBTYCCCABIAQgA0EDdGs2AgQgASAFKAAANgIACyAAIAJBCGo2AgQLjQICA38BfiAAIAJqIQQCQAJAIAJBCE4EQCAAIAFrIgJBeUgNAQsDQCAAIARPDQIgACABLQAAOgAAIABBAWohACABQQFqIQEMAAsACwJAAkAgAkFvSw0AIAAgBEEgayICSw0AIAEpAAAhBiAAIAEpAAg3AAggACAGNwAAIAIgAGsiBUERTgRAIABBEGohACABIQMDQCADKQAQIQYgACADKQAYNwAIIAAgBjcAACADKQAgIQYgACADKQAoNwAYIAAgBjcAECADQSBqIQMgAEEgaiIAIAJJDQALCyABIAVqIQEMAQsgACECCwNAIAIgBE8NASACIAEtAAA6AAAgAkEBaiECIAFBAWohAQwACwALC98BAQZ/Qbp/IQoCQCACKAIEIgggAigCACIJaiINIAEgAGtLDQBBbCEKIAkgBCADKAIAIgtrSw0AIAAgCWoiBCACKAIIIgxrIQIgACABQSBrIgEgCyAJQQAQIyADIAkgC2o2AgACQAJAIAQgBWsgDE8EQCACIQUMAQsgDCAEIAZrSw0CIAcgByACIAVrIgNqIgIgCGpPBEAgCEUNAiAEIAIgCPwKAAAMAgtBACADayIABEAgBCACIAD8CgAACyADIAhqIQggBCADayEECyAEIAEgBSAIQQEQIwsgDSEKCyAKC+sBAQZ/Qbp/IQsCQCADKAIEIgkgAygCACIKaiINIAEgAGtLDQAgBSAEKAIAIgVrIApJBEBBbA8LIAMoAgghDCAAIAVLIAUgCmoiDiAAS3ENACAAIApqIgMgDGshASAAIAUgChAfIAQgDjYCAAJAAkAgAyAGayAMTwRAIAEhBgwBC0FsIQsgDCADIAdrSw0CIAggCCABIAZrIgBqIgEgCWpPBEAgCUUNAiADIAEgCfwKAAAMAgtBACAAayIEBEAgAyABIAT8CgAACyAAIAlqIQkgAyAAayEDCyADIAIgBiAJQQEQIwsgDSELCyALC6sCAQJ/IAJBH3EhAyABIQQDQCADQQhJRQRAIANBCGshAyAEKQAAQs/W077Sx6vZQn5CH4lCh5Wvr5i23puef34gAIVCG4lCh5Wvr5i23puef35CnaO16oOxjYr6AH0hACAEQQhqIQQMAQsLIAEgAkEYcWohASACQQdxIgNBBEkEfyABBSADQQRrIQMgATUAAEKHla+vmLbem55/fiAAhUIXiULP1tO+0ser2UJ+Qvnz3fGZ9pmrFnwhACABQQRqCyEEA0AgAwRAIANBAWshAyAEMQAAQsXP2bLx5brqJ34gAIVCC4lCh5Wvr5i23puef34hACAEQQFqIQQMAQsLIABCIYggAIVCz9bTvtLHq9lCfiIAQh2IIACFQvnz3fGZ9pmrFn4iAEIgiCAAhQvhBAIBfgJ/IAAgA2ohBwJAIANBB0wEQANAIAAgB08NAiAAIAItAAA6AAAgAEEBaiEAIAJBAWohAgwACwALIAQEQAJAIAAgAmsiBkEHTQRAIAAgAi0AADoAACAAIAItAAE6AAEgACACLQACOgACIAAgAi0AAzoAAyAAIAIgBkECdCIGQeAaaigCAGoiAigAADYABCACIAZBgBtqKAIAayECDAELIAAgAikAADcAAAsgA0EIayEDIAJBCGohAiAAQQhqIQALIAEgB08EQCAAIANqIQEgBEUgACACa0EPSnJFBEADQCAAIAIpAAA3AAAgAkEIaiECIABBCGoiACABSQ0ADAMLAAsgAikAACEFIAAgAikACDcACCAAIAU3AAAgA0ERSQ0BIABBEGohAANAIAIpABAhBSAAIAIpABg3AAggACAFNwAAIAIpACAhBSAAIAIpACg3ABggACAFNwAQIAJBIGohAiAAQSBqIgAgAUkNAAsMAQsCQCAAIAFLBEAgACEBDAELIAEgAGshBgJAIARFIAAgAmtBD0pyRQRAIAIhAwNAIAAgAykAADcAACADQQhqIQMgAEEIaiIAIAFJDQALDAELIAIpAAAhBSAAIAIpAAg3AAggACAFNwAAIAZBEUgNACAAQRBqIQAgAiEDA0AgAykAECEFIAAgAykAGDcACCAAIAU3AAAgAykAICEFIAAgAykAKDcAGCAAIAU3ABAgA0EgaiEDIABBIGoiACABSQ0ACwsgAiAGaiECCwNAIAEgB08NASABIAItAAA6AAAgAUEBaiEBIAJBAWohAgwACwALC6HFAQI2fwV+IwBBEGsiMSQAAkBBwOwFEAEiCEUEQEFAIQYMAQsgCEIANwL86gEgCEEANgKc6wEgCEEANgKQ6wEgCEEANgLU6wEgCEEANgLE6wEgCEIANwKk6wEgCEEANgK46QEgCEEANgK87AUgCEIANwK86wEgCEEANgKs6wEgCEIBNwKU6wEgCEIANwPo6wEgCEGBgIDAADYCzOsBIAhCADcC7OoBIAhCADcDsOsBIAhBADYCuOsBIAhBhOsBakEANgIAIAgQFiAIQbjqAWohNCAIQcDpAWohNiAIQZDqAWohNyAAISwCQAJAAkACQANAQQFBBSAIKALs6gEiCxshEwJAA0AgAyATSQ0BAkAgA0EESSALcg0AIAIoAABBcHFB0NS0wgFHDQBBuH8hBiADQQhJDQcgAigABCIHQXdLBEBBciEGDAgLIAMgB0EIaiIESQ0HIAdBgH9LBEAgBCEGDAgLIAMgBGshAyACIARqIQIMAQsLIAhCADcCrOkBIAhCADcD8OkBIAhBjICA4AA2AqhQIAhBADYCoOsBIAhCADcDiOoBIAhBATYClOsBIAhCAzcDgOoBIAhBtOkBakIANwIAIAhB+OkBakIANwMAIAhB9A4pAgA3AqzQASAIQbTQAWpB/A4oAgA2AgAgCCAIQRBqNgIAIAggCEGgMGo2AgQgCCAIQZggajYCCCAIIAhBqNAAajYCDCAIQQFBBSAIKALs6gEbNgK86QECQCABRQ0AICwgCCgCrOkBIgZGDQAgCCAGNgK46QEgCCAsNgKs6QEgCCgCsOkBIQQgCCAsNgKw6QEgCCAsIAQgBmtqNgK06QELQbh/IQYgA0EFQQkgCCgC7OoBIhMbSQ0FIAJBAUEFIBMbIBMQGCIEQYh/Sw0EIAMgBEEDakkNBSA2IAIgBCATEBciBkGIf0sEQCAGIQQMBQsgBg0DAkACQCAIKAKw6wFBAUcNACAIKAKs6wEiC0UNACAIKAKc6wFFDQAgCygCBCEGIDEgCCgC3OkBIgo2AgQgBkEBayIHQsnP2bLx5brqJyAxQQRqQQQQIqdxIRMgCygCACELA0AgCiALIBNBAnRqKAIAIgwEfyAMKAKo1QEFQQALIgZHBEAgByATcUEBaiETIAYNAQsLIAxFDQAgCBAWIAhBfzYCqOsBIAggDDYCnOsBIAggCCgC3OkBIhM2AqDrAQwBCyAIKALc6QEhEwsCQCATRQ0AIAgoAqDrASATRg0AQWAhBAwFCwJAIAgoAuDpAQRAIAggCCgC8OoBIgZFNgL06gEgBg0BIDdBAEHYAPwLACAIQvnq0NDnyaHk4QA3A7DqASAIQs/W077Sx6vZQjcDoOoBIAhC1uuC7ur9ifXgADcDmOoBDAELIAhBADYC9OoBCyAIIAgpA/DpASAErXw3A/DpASAIKAK46wEiEwRAIAggCCgC0OkBIgYgEyAGIBNJGzYC0OkBCyABICxqITUgAyAEayEDIAIgBGohAiAsIRMDQCACIAMgMUEEahAaIiBBiH9LBEAgICEEDAYLIANBA2siOCAgSQ0EIAJBA2oiHSA1IB0gNUkbIDUgEyAdTRshAkFsIQQCQAJAAkACQAJAAkACQAJAIDEoAgQOAwECAA0LIAIgE2shFEEAITMjAEHQAmsiBSQAAkACQCAIKAKU6wEiAgR/IAgoAtDpAQVBgIAICyAgSQ0AAkAgIEECSQ0AIB0tAAAiA0EDcSEaIAIEfyAIKALQ6QEFQYCACAshBgJAAkACQAJAAkACQAJAAkACQAJAIBpBAWsOAwMBAAILIAgoAojqAQ0AQWIhAwwLCyAgQQVJDQhBAyEMIB0oAAAhBAJ/An8CQAJAAkAgA0ECdkEDcSICQQJrDgIBAgALIARBDnZB/wdxIQ0gBEEEdkH/B3EhECACQQBHDAMLIARBEnYhDSAEQQR2Qf//AHEhEEEEDAELIB0tAARBCnQgBEEWdnIhDSAEQQR2Qf//D3EhEEEFCyEMQQELIQRBun8hAyATQQEgEBtFDQogBiAQSQ0IIBBBBkkgBHEEQEFoIQMMCwsgDCANaiIKICBLDQggBiAUIAYgFEkbIgIgEEkNCiAIIBMgFCAQIAJBABAbAkAgCCgCpOsBRSAQQYEGSXINAEEAIQMDQCADQYOAAUsNASADQUBrIQMMAAsACyAaQQNGBEAgDCAdaiEGIAgoAgwiCy0AAUEIdCECIAgoAvzrASEDIARFBEAgAgRAIAVB4AFqIAYgDRAIIg5BiH9LDQkgC0EEaiEZIAMgEGohESALLwECIQkgEEEETwRAIBFBA2shBkEAIAlrQR9xIQcgBSgC6AEhDCAFKALsASEPIAUoAvABIQQgBSgC4AEhDSAFKALkASEOA0AgDkEgSwRAQbAaIQwMCgsCQCAEIAxNBEAgDkEHcSESIA5BA3YhDUEBIQ4MAQsgDCAPRg0KIA4gDkEDdiICIAwgD2sgDCACayAPTyIOGyINQQN0ayESCyAMIA1rIgwoAAAhDSAORSADIAZPcg0IIAMgGSANIBJ0IAd2QQJ0aiICLwEAOwAAIAMgAi0AA2oiAyAZIA0gEiACLQACaiICdCAHdkECdGoiCy8BADsAACADIAstAANqIQMgAiALLQACaiEODAALAAsgBSgC5AEiDkEhTwRAIAVBsBo2AugBDAkLIAUoAugBIgYgBSgC8AFPBEAgBSAOQQdxIgI2AuQBIAUgBiAOQQN2ayIENgLoASAFIAQoAAA2AuABIAIhDgwJCyAGIAUoAuwBIgRGDQggBSAOIAYgBGsgDkEDdiICIAYgAmsgBEkbIgJBA3RrIg42AuQBIAUgBiACayICNgLoASAFIAIoAAA2AuABDAgLIAMgECAGIA0gCxARIQ4MCAsgAgRAIAMgECAGIA0gCxASIQ4MCAsgAyAQIAYgDSALEBQhDgwHCyAIQazVAWohFyAMIB1qISEgCEGo0ABqIQcgCCgC/OsBIRYgBEUEQCAHICEgDSAXEA4iDkGIf0sNByANIA5NDQMgFiAQIA4gIWogDSAOayAHEBEhDgwHCyAQRQRAQbp/IQ4MBwsgDUUEQEFsIQ4MBwsgEEEIdiIDIA0gEEkEfyANQQR0IBBuBUEPC0EEdCIEQYwIaigCAGwgBEGICGooAgBqIgJBBXYgAmogBEGACGooAgAgBEGECGooAgAgA2xqSQRAIwBBEGsiLSQAIAcoAgAhESAXQfAEaiIeQQBB8AD8CwBBVCEDAkAgEUH/AXEiL0EMSw0AIBdB4AdqIgkgHiAtQQhqIC1BDGogISANIBdB4AlqEAciBEGIf00EQCAtKAIMIgsgL0sNASAXQagFaiEZIBdBpAVqITAgB0EEaiEbIBFBgICAeHEhJCALQQFqIjIhAyALIQYDQCADIgJBAWshAyAGIgxBAWshBiAeIAxBAnRqKAIARQ0AC0EBIAIgAkEBTRshDkEAIQZBASEDA0AgAyAORwRAIB4gA0ECdCIPaigCACECIA8gGWogBjYCACADQQFqIQMgAiAGaiEGDAELCyAXIAY2AqgFIBkgDEEBaiIfQQJ0aiAGNgIAIBdB4AVqISZBACEDIC0oAgghBgNAIAMgBkcEQCAZIAMgCWotAABBAnRqIgIgAigCACICQQFqNgIAIAIgJmogAzoAACADQQFqIQMMAQsLQQAhBiAZQQA2AgBBCyAvIBFB/wFxQQxGGyAvIAtBDEkbIikgC0F/c2ohD0EBIQMDQCADIA5HBEAgHiADQQJ0IgtqKAIAIQIgCyAXaiAGNgIAIAIgAyAPanQgBmohBiADQQFqIQMMAQsLICkgMiAMayILa0EBaiEJIAshBgNAIAYgCUkEQCAXIAZBNGxqIQ9BASEDA0AgAyAORwRAIA8gA0ECdCICaiACIBdqKAIAIAZ2NgIAIANBAWohAwwBCwsgBkEBaiEGDAELCyAyIClrIRUgDEEAIAxBAEobQQFqISdBASEuA0AgJyAuRwRAIDIgLmshBiAXIC5BAnQiAmooAgAhJSACIDBqKAIAISogMCAuQQFqIi5BAnRqKAIAIRggCyApIAZrIgNNBEAgHyAGIBVqIgJBASACQQFKIhIbIgIgAiAfSBshHCAXIAZBNGxqIh4gAkECdGohGSAGIDJqIREgBkEQdEGAgIAIaiEOQQEgA3QiCUECayEPA0AgGCAqRg0DIBsgJUECdGohKCAmICpqLQAAISsgAiEDIBIEQCAOICtyrUKBgICAEH4hOiAZKAIAIQZBACEDAkACQAJAAkAgDw4DAQIAAgsgKCA6NwEICyAoIDo3AQAMAQsDQCADIAZODQEgKCADQQJ0aiIMIDo3ARggDCA6NwEQIAwgOjcBCCAMIDo3AQAgA0EIaiEDDAALAAsgAiEDCwNAIAMgHEcEQCARIANrIQwgKCAeIANBAnQiBmooAgBBAnRqICYgBiAwaigCAGogJiAwIANBAWoiA0ECdGooAgBqIAwgKSArQQIQDwwBCwsgKkEBaiEqIAkgJWohJQwACwAFIBsgJUECdGogJiAqaiAYICZqIAYgKUEAQQEQDwwCCwALCyAHIClBEHQgJHIgL3JBgAJyNgIACyAEIQMLIC1BEGokACADIg5BiH9LDQcgAyANTw0DIBYgECADICFqIA0gA2sgBxASIQ4MBwsgByAhIA0gFxAOIg5BiH9LDQYgDSAOTQ0CIBYgECAOICFqIA0gDmsgBxAUIQ4MBgtBAiEQAn8CQAJAAkAgA0ECdkEDcUEBaw4DAQACAAtBASEQIANBA3YMAgsgHS8AAEEEdgwBCyAgQQJGDQhBAyEQIB0vAAAgHS0AAkEQdHJBBHYLIQtBun8hAyATQQEgCxtFDQkgBiALSQ0HIAsgFEsNCSAIIBMgFCALIAYgFCAGIBRJG0EBEBsgICALIBBqIgpBIGpJBEAgCiAgSw0IIBAgHWohBCAIKAL86wEhAwJAIAgoAoTsAUECRgRAIAtBgIAEayICBEAgAyAEIAL8CgAACyAIQYjsAWogAiAEakGAgAT8CgAADAELIAtFDQAgAyAEIAv8CgAACyAIIAs2AojrASAIIAgoAvzrATYC+OoBDAcLIAhBADYChOwBIAggCzYCiOsBIAggECAdaiICNgL46gEgCCACIAtqNgKA7AEMBgsCfwJAAkACQCADQQJ2QQNxQQFrDgMBAAIAC0EBIRAgA0EDdgwCCyAgQQJGDQhBAiEQIB0vAABBBHYMAQsgIEEESQ0HQQMhECAdLwAAIB0tAAJBEHRyQQR2CyELQbp/IQMgE0EBIAsbRQ0IIAYgC0kNBiALIBRLDQggCCATIBQgCyAGIBQgBiAUSRtBARAbIBAgHWoiAy0AACEGIAgoAvzrASEEAkAgCCgChOwBQQJGBEAgC0GAgARrIgIEQCAEIAYgAvwLAAsgCEGI7AFqIAMtAABBgIAE/AsADAELIAtFDQAgBCAGIAv8CwALIAggCzYCiOsBIAggCCgC/OsBNgL46gEgEEEBaiEKDAULQbh/IQ4MAwsgEiEOCyAFIA42AuQBIAUgDDYC6AEgBSANNgLgAQsCQCARIANrQQJJDQAgEUECayELQQAgCWtBH3EhBgNAAkAgDkEhTwRAIAVBsBo2AugBDAELIAUCfyAFKALoASIHIAUoAvABTwRAIAUgByAOQQN2ayIMNgLoAUEBISUgDkEHcQwBCyAHIAUoAuwBIgRGDQEgBSAHIA5BA3YiAiAHIARrIAcgAmsgBE8iJRsiAmsiDDYC6AEgDiACQQN0awsiDjYC5AEgBSAMKAAAIgI2AuABICVFIAMgC0tyDQAgAyAZIAIgDnQgBnZBAnRqIgIvAQA7AAAgBSAFKALkASACLQACaiIONgLkASADIAItAANqIQMMAQsLA0AgAyALSw0BIAMgGSAFKALgASAOdCAGdkECdGoiAi8BADsAACAFIAUoAuQBIAItAAJqIg42AuQBIAMgAi0AA2ohAwwACwALAkAgAyARTw0AIAMgGSAFKALgASAOdEEAIAlrdkECdGoiAi0AADoAACACLQADQQFGBEAgBSgC5AEgAi0AAmohDgwBCyAFKALkASIOQR9LDQBBICAOIAItAAJqIgIgAkEgTxshDgtBbEFsIBAgDkEgRxsgBSgC6AEgBSgC7AFHGyEOCyAIKAKE7AFBAkYEQCAIQYjsAWogCCgCgOwBQYCABGtBgIAE/AoAACAQQYCABGsiAwRAIAgoAvzrASICQeD/A2ogAiAD/AoAAAsgCCAIKAL86wFB4P8DajYC/OsBIAggCCgCgOwBQSBrNgKA7AELIA5BiH9LDQEgCCAQNgKI6wEgCEEBNgKI6gEgCCAIKAL86wE2AvjqASAaQQJGBEAgCCAIQajQAGo2AgwLIAoiA0GIf0sNAwsgCCgClOsBBH8gCCgC0OkBBUGAgAgLIQwgCiAgRg0BICAgCmshCSAIKAK06QEhCyAdICBqIQ0gCCgCpOsBIQYCfwJAAn8gCiAdaiIRLQAAIg7AIgJBAE4EQCARQQFqDAELIAJBf0YEQCAJQQNJDQUgEUEDaiEEIBEvAAFBgP4BaiEODAILIAlBAUYNBCARLQABIA5BCHRyQYCAAmshDiARQQJqCyEEIA4NAEFsIQMgBCANRw0EQQAhDiAJDAELQbh/IQMgBEEBaiIPIA1LDQMgBC0AACIKQQNxDQEgCEEQaiAIIApBBnZBI0EJIA8gDSAPa0HADUHQDkGADyAIKAKM6gEgBiAOIAhBrNUBaiIHEBwiAkGIf0sNASAIQZggaiAIQQhqIApBBHZBA3FBH0EIIAIgD2oiBCANIARrQYAKQYALQZATIAgoAozqASAIKAKk6wEgDiAHEBwiAkGIf0sNAUFsIQMgCEGgMGogCEEEaiAKQQJ2QQNxQTRBCSACIARqIgQgDSAEa0GgC0GADUGgFSAIKAKM6gEgCCgCpOsBIA4gBxAcIgJBiH9LDQMgAiAEaiARawsiA0GIf0sNAgJAIBNBAEcgFEEAR3FFIA5BAEpxDQACQAJAIBMgFCAMIAwgFEsbIgJBACACQQBKG2ogC2siAkH8//8fTQRAIAYgAkGBgIAISXIgDkEJSHINAiAFQeABaiAIKAIIIA4QHQwBCyAFQeABaiAIKAIIIA4QHSAFKALkAUEZSyEzIAYNAQsgBSgC4AFBE0shBgsgCSADayEHIAMgEWohBCAIQQA2AqTrASAIKAKE7AEhAgJAIAYEQAJ/IAJBAUYEQCAIKAL86wEMAQsgEyAUQQAgFEEAShtqCyEUIAUgCCgC+OoBIgM2AswCIAgoAoDsASEcIA5FBEAgEyEJDAILIAgoArjpASEiIAgoArTpASEXIAgoArDpASELIAhBATYCjOoBIAhBrNABaiEyIAVB1AFqISZBACECA0AgAkEDRwRAICYgAkECdCIDaiADIDJqKAIANgIAIAJBAWohAgwBCwtBbCEDIAVBqAFqIgIgBCAHEAhBiH9LDQUgBUG8AWogAiAIKAIAEB4gBUHEAWogAiAIKAIIEB4gBUHMAWogAiAIKAIEEB5BCCAOIA5BCE4bIihBACAoQQBKGyElIA5BAWshGiATIAtrIS0gBSgCsAEhAiAFKALYASEGIAUoAtQBIRIgBSgCrAEhBCAFKAK0ASEjIAUoArgBISkgBSgCyAEhGCAFKALQASErIAUoAsABISQgBSgCqAEhCSAFKALEASEhIAUoAswBISogBSgCvAEhMCAzRSEVQQAhEANAIBIhESAQICVGBEAgBSAqNgLMASAFIDA2ArwBIAUgAjYCsAEgBSAhNgLEASAFIAk2AqgBIAhBmOwBaiEeIAhBiOwFaiEZIAhBiOwBaiEWIBRBIGshGyAzRSEnIBMhCQNAIA4gJUcEQCAFKALAASAFKAK8AUEDdGoiBi0AAiEfIAUoAtABIAUoAswBQQN0aiIELQACIRggBSgCyAEgBSgCxAFBA3RqIgItAAMhKyAELQADISQgBi0AAyEVIAIvAQAhEiAELwEAIREgBi8BACEKIAIoAgQhByAGKAIEIRAgBCgCBCEMAkAgAi0AAiINQQJPBEACQCAnIA1BGUlyRQRAIAcgBSgCqAEiDyAFKAKsASICdEEFIA1rdkEFdGohBwJAIAIgDWpBBWsiAkEhTwRAIAVBsBo2ArABDAELIAUoArABIgYgBSgCuAFPBEAgBSACQQdxIgQ2AqwBIAUgBiACQQN2ayICNgKwASAFIAIoAAAiDzYCqAEgBCECDAELIAYgBSgCtAEiBEYNACAFIAIgBiAEayACQQN2IgIgBiACayAESRsiBEEDdGsiAjYCrAEgBSAGIARrIgQ2ArABIAUgBCgAACIPNgKoAQsgBSACQQVqIgY2AqwBIAcgDyACdEEbdmohDQwBCyAFIAUoAqwBIgIgDWoiBjYCrAEgBSgCqAEgAnRBACANa3YgB2ohDSAGQSFPBEAgBUGwGjYCsAEMAQsgBSgCsAEiByAFKAK4AU8EQCAFIAZBB3EiAjYCrAEgBSAHIAZBA3ZrIgQ2ArABIAUgBCgAADYCqAEgAiEGDAELIAcgBSgCtAEiBEYNACAFIAYgByAEayAGQQN2IgIgByACayAESRsiAkEDdGsiBjYCrAEgBSAHIAJrIgI2ArABIAUgAigAADYCqAELIAUpAtQBITogBSANNgLUASAFIDo3AtgBDAELIBBFIQQgDUUEQCAmIBBBAEdBAnRqKAIAIQIgBSAmIARBAnRqKAIAIg02AtQBIAUgAjYC2AEgBSgCrAEhBgwBCyAFIAUoAqwBIgJBAWoiBjYCrAECQAJAIAQgB2ogBSgCqAEgAnRBH3ZqIgRBA0YEQCAFKALUAUEBayICQX8gAhshDQwBCyAmIARBAnRqKAIAIgJBfyACGyENIARBAUYNAQsgBSAFKALYATYC3AELIAUgBSgC1AE2AtgBIAUgDTYC1AELIBggH2ohBAJAIBhFBEAgBiECDAELIAUgBiAYaiICNgKsASAFKAKoASAGdEEAIBhrdiAMaiEMCwJAIARBFEkNACACQSFPBEAgBUGwGjYCsAEMAQsgBSgCsAEiBiAFKAK4AU8EQCAFIAJBB3EiBDYCrAEgBSAGIAJBA3ZrIgI2ArABIAUgAigAADYCqAEgBCECDAELIAYgBSgCtAEiBEYNACAFIAIgBiAEayACQQN2IgIgBiACayAESRsiBEEDdGsiAjYCrAEgBSAGIARrIgQ2ArABIAUgBCgAADYCqAELAkAgH0UEQCACIQQMAQsgBSACIB9qIgQ2AqwBIAUoAqgBIAJ0QQAgH2t2IBBqIRALAkAgBEEhTwRAQbAaIQIgBUGwGjYCsAEMAQsgBSgCsAEiAiAFKAK4AU8EQCAFIARBB3EiBjYCrAEgBSACIARBA3ZrIgI2ArABIAUgAigAADYCqAEgBiEEDAELIAIgBSgCtAEiB0YNACAFIAIgAiAHayAEQQN2IgYgAiAGayAHSRsiBmsiAjYCsAEgBSAEIAZBA3RrIgQ2AqwBIAUgAigAADYCqAELAkAgGiAlRg0AIAUgFUECdEGwGWooAgAgBSgCqAEiB0EAIAQgFWoiBGt2cSAKajYCvAEgBSAkQQJ0QbAZaigCACAHQQAgBCAkaiIEa3ZxIBFqNgLMAQJAIARBIU8EQEGwGiECIAVBsBo2ArABDAELIAUoArgBIAJNBEAgBSAEQQdxIgY2AqwBIAUgAiAEQQN2ayICNgKwASAFIAIoAAAiBzYCqAEgBiEEDAELIAIgBSgCtAEiCkYNACAFIAIgAiAKayAEQQN2IgYgAiAGayAKSRsiBmsiAjYCsAEgBSAEIAZBA3RrIgQ2AqwBIAUgAigAACIHNgKoAQsgBSAEICtqIgQ2AqwBIAUgK0ECdEGwGWooAgAgB0EAIARrdnEgEmo2AsQBIARBIU8EQCAFQbAaNgKwAQwBCyAFKAK4ASACTQRAIAUgBEEHcTYCrAEgBSACIARBA3ZrIgI2ArABIAUgAigAADYCqAEMAQsgAiAFKAK0ASIGRg0AIAUgBCACIAZrIARBA3YiBCACIARrIAZJGyIEQQN0azYCrAEgBSACIARrIgI2ArABIAUgAigAADYCqAELAkACQCAIKAKE7AFBAkYEQCAFKALMAiIHIAVB4AFqICVBB3FBDGxqIhUoAgAiAmoiCiAIKAKA7AEiBEsEQCAEIAdHBEAgBCAHayIEIBQgCWtLDQsgCSAHIAQQHyAVIAIgBGsiAjYCACAEIAlqIQkLIAUgFjYCzAIgCEEANgKE7AECQAJAAkAgAkGAgARKDQAgCSAVKAIEIhIgAmoiBmogG0sNACAGQSBqIBQgCWtNDQELIAUgFSgCCDYCgAEgBSAVKQIANwN4IAkgFCAFQfgAaiAFQcwCaiAZIAsgFyAiECAhBgwBCyACIBZqIQcgAiAJaiEEIBUoAgghESAWKQAAITogCSAWKQAINwAIIAkgOjcAAAJAIAJBEUkNACAeKQAAITogCSAeKQAINwAYIAkgOjcAECACQRBrQRFIDQAgCUEgaiECIB4hDwNAIA8pABAhOiACIA8pABg3AAggAiA6NwAAIA8pACAhOiACIA8pACg3ABggAiA6NwAQIA9BIGohDyACQSBqIgIgBEkNAAsLIAQgEWshAiAFIAc2AswCIAQgC2sgEUkEQCARIAQgF2tLDQ8gIiAiIAIgC2siCmoiByASak8EQCASRQ0CIAQgByAS/AoAAAwCC0EAIAprIgIEQCAEIAcgAvwKAAALIAogEmohEiAEIAprIQQgCyECCyARQRBPBEAgAikAACE6IAQgAikACDcACCAEIDo3AAAgEkERSA0BIAQgEmohByAEQRBqIQQDQCACKQAQITogBCACKQAYNwAIIAQgOjcAACACKQAgITogBCACKQAoNwAYIAQgOjcAECACQSBqIQIgBEEgaiIEIAdJDQALDAELAkAgEUEHTQRAIAQgAi0AADoAACAEIAItAAE6AAEgBCACLQACOgACIAQgAi0AAzoAAyAEIAIgEUECdCIHQeAaaigCAGoiAigAADYABCACIAdBgBtqKAIAayECDAELIAQgAikAADcAAAsgEkEJSQ0AIAQgEmohCiAEQQhqIgcgAkEIaiICa0EPTARAA0AgByACKQAANwAAIAJBCGohAiAHQQhqIgcgCkkNAAwCCwALIAIpAAAhOiAHIAIpAAg3AAggByA6NwAAIBJBGUgNACAEQRhqIQQDQCACKQAQITogBCACKQAYNwAIIAQgOjcAACACKQAgITogBCACKQAoNwAYIAQgOjcAECACQSBqIQIgBEEgaiIEIApJDQALCyAGQYh/SwRAIAYhAwwOCyAVIA02AgggFSAMNgIEIBUgEDYCACAZIRwMAwsgCkEgayEEAkACQCAKIBxLDQAgCSAVKAIEIhEgAmoiBmogBEsNACAGQSBqIBQgCWtNDQELIAUgFSgCCDYCkAEgBSAVKQIANwOIASAJIBQgBCAFQYgBaiAFQcwCaiAcIAsgFyAiECEhBgwCCyACIAlqIQQgFSgCCCEPIAcpAAAhOiAJIAcpAAg3AAggCSA6NwAAAkAgAkERSQ0AIAcpABAhOiAJIAcpABg3ABggCSA6NwAQIAJBEGtBEUgNACAHQRBqIQIgCUEgaiEHA0AgAikAECE6IAcgAikAGDcACCAHIDo3AAAgAikAICE6IAcgAikAKDcAGCAHIDo3ABAgAkEgaiECIAdBIGoiByAESQ0ACwsgBCAPayECIAUgCjYCzAIgBCALayAPSQRAIA8gBCAXa0sNDSAiICIgAiALayIKaiIHIBFqTwRAIBFFDQMgBCAHIBH8CgAADAMLQQAgCmsiAgRAIAQgByAC/AoAAAsgCiARaiERIAQgCmshBCALIQILIA9BEE8EQCACKQAAITogBCACKQAINwAIIAQgOjcAACARQRFIDQIgBCARaiEHIARBEGohBANAIAIpABAhOiAEIAIpABg3AAggBCA6NwAAIAIpACAhOiAEIAIpACg3ABggBCA6NwAQIAJBIGohAiAEQSBqIgQgB0kNAAsMAgsCQCAPQQdNBEAgBCACLQAAOgAAIAQgAi0AAToAASAEIAItAAI6AAIgBCACLQADOgADIAQgAiAPQQJ0IgdB4BpqKAIAaiICKAAANgAEIAIgB0GAG2ooAgBrIQIMAQsgBCACKQAANwAACyARQQlJDQEgBCARaiEKIARBCGoiByACQQhqIgJrQQ9MBEADQCAHIAIpAAA3AAAgAkEIaiECIAdBCGoiByAKSQ0ADAMLAAsgAikAACE6IAcgAikACDcACCAHIDo3AAAgEUEZSA0BIARBGGohBANAIAIpABAhOiAEIAIpABg3AAggBCA6NwAAIAIpACAhOiAEIAIpACg3ABggBCA6NwAQIAJBIGohAiAEQSBqIgQgCkkNAAsMAQsCQAJAIAUoAswCIhEgBUHgAWogJUEHcUEMbGoiDygCACICaiIHIBxLDQAgCSAPKAIEIgogAmoiBmogG0sNACAGQSBqIBQgCWtNDQELIAUgDygCCDYCoAEgBSAPKQIANwOYASAJIBQgBUGYAWogBUHMAmogHCALIBcgIhAgIQYMAQsgAiAJaiEEIA8oAgghFSARKQAAITogCSARKQAINwAIIAkgOjcAAAJAIAJBEUkNACARKQAQITogCSARKQAYNwAYIAkgOjcAECACQRBrQRFIDQAgEUEQaiECIAlBIGohEgNAIAIpABAhOiASIAIpABg3AAggEiA6NwAAIAIpACAhOiASIAIpACg3ABggEiA6NwAQIAJBIGohAiASQSBqIhIgBEkNAAsLIAQgFWshAiAFIAc2AswCIAQgC2sgFUkEQCAVIAQgF2tLDQwgIiAiIAIgC2siD2oiByAKak8EQCAKRQ0CIAQgByAK/AoAAAwCC0EAIA9rIgIEQCAEIAcgAvwKAAALIAogD2ohCiAEIA9rIQQgCyECCyAVQRBPBEAgAikAACE6IAQgAikACDcACCAEIDo3AAAgCkERSA0BIAQgCmohByAEQRBqIQQDQCACKQAQITogBCACKQAYNwAIIAQgOjcAACACKQAgITogBCACKQAoNwAYIAQgOjcAECACQSBqIQIgBEEgaiIEIAdJDQALDAELAkAgFUEHTQRAIAQgAi0AADoAACAEIAItAAE6AAEgBCACLQACOgACIAQgAi0AAzoAAyAEIAIgFUECdCIHQeAaaigCAGoiAigAADYABCACIAdBgBtqKAIAayECDAELIAQgAikAADcAAAsgCkEJSQ0AIAQgCmohDyAEQQhqIgcgAkEIaiICa0EPTARAA0AgByACKQAANwAAIAJBCGohAiAHQQhqIgcgD0kNAAwCCwALIAIpAAAhOiAHIAIpAAg3AAggByA6NwAAIApBGUgNACAEQRhqIQQDQCACKQAQITogBCACKQAYNwAIIAQgOjcAACACKQAgITogBCACKQAoNwAYIAQgOjcAECACQSBqIQIgBEEgaiIEIA9JDQALCyAGQYh/SwRAIAYhAwwLCyAFQeABaiAlQQdxQQxsaiICIA02AgggAiAMNgIEIAIgEDYCAAsgBiAJaiEJICVBAWohJSAQIC1qIAxqIS0MAQsLIAUoArABIAUoArQBRw0HIAUoAqwBQSBHDQcgDiAoayEQA0ACQCAOIBBMBEBBACECA0AgAkEDRg0CIDIgAkECdCIDaiADICZqKAIANgIAIAJBAWohAgwACwALIAVB4AFqIBBBB3FBDGxqIQoCfwJAIAgoAoTsAUECRgRAIAUoAswCIg8gCigCACIEaiIHIAgoAoDsASICSwRAIAIgD0cEQCACIA9rIgIgFCAJa0sNCyAJIA8gAhAfIAogBCACayIENgIAIAIgCWohCQsgBSAWNgLMAiAIQQA2AoTsAQJAAkACQCAEQYCABEoNACAJIAooAgQiDSAEaiIGaiAbSw0AIAZBIGogFCAJa00NAQsgBSAKKAIINgJQIAUgCikCADcDSCAJIBQgBUHIAGogBUHMAmogGSALIBcgIhAgIQYMAQsgBCAWaiEHIAQgCWohDCAKKAIIIQogFikAACE6IAkgFikACDcACCAJIDo3AAACQCAEQRFJDQAgHikAACE6IAkgHikACDcAGCAJIDo3ABAgBEEQa0ERSA0AIAlBIGohAiAeIQQDQCAEKQAQITogAiAEKQAYNwAIIAIgOjcAACAEKQAgITogAiAEKQAoNwAYIAIgOjcAECAEQSBqIQQgAkEgaiICIAxJDQALCyAMIAprIQIgBSAHNgLMAiAMIAtrIApJBEAgCiAMIBdrSw0PICIgIiACIAtrIgdqIgQgDWpPBEAgDUUNAiAMIAQgDfwKAAAMAgtBACAHayICBEAgDCAEIAL8CgAACyAHIA1qIQ0gDCAHayEMIAshAgsgCkEQTwRAIAIpAAAhOiAMIAIpAAg3AAggDCA6NwAAIA1BEUgNASAMIA1qIQcgDEEQaiEEA0AgAikAECE6IAQgAikAGDcACCAEIDo3AAAgAikAICE6IAQgAikAKDcAGCAEIDo3ABAgAkEgaiECIARBIGoiBCAHSQ0ACwwBCwJAIApBB00EQCAMIAItAAA6AAAgDCACLQABOgABIAwgAi0AAjoAAiAMIAItAAM6AAMgDCACIApBAnQiBEHgGmooAgBqIgIoAAA2AAQgAiAEQYAbaigCAGshAgwBCyAMIAIpAAA3AAALIA1BCUkNACAMIA1qIQcgDEEIaiIEIAJBCGoiAmtBD0wEQANAIAQgAikAADcAACACQQhqIQIgBEEIaiIEIAdJDQAMAgsACyACKQAAITogBCACKQAINwAIIAQgOjcAACANQRlIDQAgDEEYaiEEA0AgAikAECE6IAQgAikAGDcACCAEIDo3AAAgAikAICE6IAQgAikAKDcAGCAEIDo3ABAgAkEgaiECIARBIGoiBCAHSQ0ACwsgBkGJf08EQCAGIQMMDgsgGSEcIAYgCWoMAwsgB0EgayECAkACQCAHIBxLDQAgCSAKKAIEIhIgBGoiDGogAksNACAMQSBqIBQgCWtNDQELIAUgCigCCDYCYCAFIAopAgA3A1ggCSAUIAIgBUHYAGogBUHMAmogHCALIBcgIhAhIQwMAgsgBCAJaiEGIAooAgghCiAPKQAAITogCSAPKQAINwAIIAkgOjcAAAJAIARBEUkNACAPKQAQITogCSAPKQAYNwAYIAkgOjcAECAEQRBrQRFIDQAgD0EQaiECIAlBIGohBANAIAIpABAhOiAEIAIpABg3AAggBCA6NwAAIAIpACAhOiAEIAIpACg3ABggBCA6NwAQIAJBIGohAiAEQSBqIgQgBkkNAAsLIAYgCmshAiAFIAc2AswCIAYgC2sgCkkEQCAKIAYgF2tLDQ0gIiAiIAIgC2siB2oiBCASak8EQCASRQ0DIAYgBCAS/AoAAAwDC0EAIAdrIgIEQCAGIAQgAvwKAAALIAcgEmohEiAGIAdrIQYgCyECCyAKQRBPBEAgAikAACE6IAYgAikACDcACCAGIDo3AAAgEkERSA0CIAYgEmohByAGQRBqIQQDQCACKQAQITogBCACKQAYNwAIIAQgOjcAACACKQAgITogBCACKQAoNwAYIAQgOjcAECACQSBqIQIgBEEgaiIEIAdJDQALDAILAkAgCkEHTQRAIAYgAi0AADoAACAGIAItAAE6AAEgBiACLQACOgACIAYgAi0AAzoAAyAGIAIgCkECdCIEQeAaaigCAGoiAigAADYABCACIARBgBtqKAIAayECDAELIAYgAikAADcAAAsgEkEJSQ0BIAYgEmohByAGQQhqIgQgAkEIaiICa0EPTARAA0AgBCACKQAANwAAIAJBCGohAiAEQQhqIgQgB0kNAAwDCwALIAIpAAAhOiAEIAIpAAg3AAggBCA6NwAAIBJBGUgNASAGQRhqIQQDQCACKQAQITogBCACKQAYNwAIIAQgOjcAACACKQAgITogBCACKQAoNwAYIAQgOjcAECACQSBqIQIgBEEgaiIEIAdJDQALDAELAkACQCAFKALMAiIGIAooAgAiAmoiByAcSw0AIAkgCigCBCINIAJqIgxqIBtLDQAgDEEgaiAUIAlrTQ0BCyAFIAooAgg2AnAgBSAKKQIANwNoIAkgFCAFQegAaiAFQcwCaiAcIAsgFyAiECAhDAwBCyACIAlqIQQgCigCCCEKIAYpAAAhOiAJIAYpAAg3AAggCSA6NwAAAkAgAkERSQ0AIAYpABAhOiAJIAYpABg3ABggCSA6NwAQIAJBEGtBEUgNACAGQRBqIQIgCUEgaiEGA0AgAikAECE6IAYgAikAGDcACCAGIDo3AAAgAikAICE6IAYgAikAKDcAGCAGIDo3ABAgAkEgaiECIAZBIGoiBiAESQ0ACwsgBCAKayECIAUgBzYCzAIgBCALayAKSQRAIAogBCAXa0sNDCAiICIgAiALayIHaiIGIA1qTwRAIA1FDQIgBCAGIA38CgAADAILQQAgB2siAgRAIAQgBiAC/AoAAAsgByANaiENIAQgB2shBCALIQILIApBEE8EQCACKQAAITogBCACKQAINwAIIAQgOjcAACANQRFIDQEgBCANaiEGIARBEGohBANAIAIpABAhOiAEIAIpABg3AAggBCA6NwAAIAIpACAhOiAEIAIpACg3ABggBCA6NwAQIAJBIGohAiAEQSBqIgQgBkkNAAsMAQsCQCAKQQdNBEAgBCACLQAAOgAAIAQgAi0AAToAASAEIAItAAI6AAIgBCACLQADOgADIAQgAiAKQQJ0IgZB4BpqKAIAaiICKAAANgAEIAIgBkGAG2ooAgBrIQIMAQsgBCACKQAANwAACyANQQlJDQAgBCANaiEGIARBCGoiByACQQhqIgJrQQ9MBEADQCAHIAIpAAA3AAAgAkEIaiECIAdBCGoiByAGSQ0ADAILAAsgAikAACE6IAcgAikACDcACCAHIDo3AAAgDUEZSA0AIARBGGohBANAIAIpABAhOiAEIAIpABg3AAggBCA6NwAAIAIpACAhOiAEIAIpACg3ABggBCA6NwAQIAJBIGohAiAEQSBqIgQgBkkNAAsLIAxBiH9LBEAgDCEDDAsLIAkgDGoLIQkgEEEBaiEQDAELCyAIKAKE7AEhAiAFKALMAiEDDAMFICQgMEEDdGoiBy0AAiEuICsgKkEDdGoiCi0AAiEvIBggIUEDdGoiDC0AAyEWIAotAAMhGyAHLQADIR8gDC8BACEnIAovAQAhHiAHLwEAIRkgDCgCBCENIAcoAgQhByAKKAIEIQoCQAJAIAwtAAIiEkECTwRAIAkgBHQhDCAVIBJBGUlyRQRAIAxBBSASa3ZBBXQgDWohDQJAIAQgEmpBBWsiBEEgSwRAQbAaIQIMAQsgAiApTwRAIAUgBEEHcSIMNgKsASACIARBA3ZrIgIoAAAhCSAMIQQMAQsgAiAjRg0AIAUgBCACICNrIARBA3YiBCACIARrICNJGyIMQQN0ayIENgKsASACIAxrIgIoAAAhCQsgBSAEQQVqIg82AqwBIA0gCSAEdEEbdmohEgwCCyAFIAQgEmoiDzYCrAEgDEEAIBJrdiANaiESIA9BIEsEQEGwGiECDAILIAIgKU8EQCAFIA9BB3EiBDYCrAEgAiAPQQN2ayICKAAAIQkgBCEPDAILIAIgI0YNASAFIA8gAiAjayAPQQN2IgQgAiAEayAjSRsiBEEDdGsiDzYCrAEgAiAEayICKAAAIQkMAQsgB0UhDCASRQRAICYgDEECdGooAgAhEiAmIAdBAEdBAnRqKAIAIREgBCEPDAILIAUgBEEBaiIPNgKsASANIAkgBHRBH3ZqIAxqIgxBA0YEQCARQQFrIgRBfyAEGyESDAELICYgDEECdGooAgAiBEF/IAQbIRIgDEEBRg0BCyAFIAY2AtwBCyAuIC9qIQQgBSASNgLUASAFIBE2AtgBAkAgL0UEQCAPIQwMAQsgBSAPIC9qIgw2AqwBIAkgD3RBACAva3YgCmohCgsCQCAEQRRJDQAgDEEgSwRAQbAaIQIMAQsgAiApTwRAIAUgDEEHcSIENgKsASACIAxBA3ZrIgIoAAAhCSAEIQwMAQsgAiAjRg0AIAUgDCACICNrIAxBA3YiBCACIARrICNJGyIEQQN0ayIMNgKsASACIARrIgIoAAAhCQsCQCAuRQRAIAwhBAwBCyAFIAwgLmoiBDYCrAEgCSAMdEEAIC5rdiAHaiEHCwJAIARBIEsEQEGwGiECDAELIAIgKU8EQCAFIARBB3EiBjYCrAEgAiAEQQN2ayICKAAAIQkgBiEEDAELIAIgI0YNACAFIAQgAiAjayAEQQN2IgQgAiAEayAjSRsiBkEDdGsiBDYCrAEgAiAGayICKAAAIQkLAkAgECAaRg0AIB9BAnRBsBlqKAIAIAlBACAEIB9qIgRrdnEhDyAbQQJ0QbAZaigCACAJQQAgBCAbaiIEa3ZxIQYCQAJ/AkACQCAEQSBLBEBBsBohAgwBCyACIClPBEAgBSAEQQdxIgw2AqwBIAIgBEEDdmsMAwsgAiAjRw0BCyAEIQwMAgsgBSAEIAIgI2sgBEEDdiIEIAIgBGsgI0kbIgRBA3RrIgw2AqwBIAIgBGsLIgIoAAAhCQsgDyAZaiEwIAYgHmohKiAFIAwgFmoiBjYCrAEgFkECdEGwGWooAgAgCUEAIAZrdnEgJ2ohIQJ/AkACQCAGQSBLBEBBsBohAgwBCyACIClPBEAgBSAGQQdxIgQ2AqwBIAIgBkEDdmsMAwsgAiAjRw0BCyAGIQQMAgsgBSAGIAIgI2sgBkEDdiIEIAIgBGsgI0kbIgZBA3RrIgQ2AqwBIAIgBmsLIgIoAAAhCQsgBUHgAWogEEEMbGoiBiASNgIIIAYgCjYCBCAGIAc2AgAgEEEBaiEQIAcgLWogCmohLSARIQYMAQsACwALAn8CQAJAAkAgAg4DAQIAAgsgBSAIKAL46gEiAzYCzAJBACECIBMgFEEAIBRBAEobaiEaIAgoAoDsASERAn8CQCAORQRAIBMhBwwBCyAIKAK46QEhFiAIKAK06QEhHyAIKAKw6QEhCyAIQQE2AozqASAIQazQAWohKyAFQYwCaiEbA0AgAkEDRwRAIBsgAkECdCIDaiADICtqKAIANgIAIAJBAWohAgwBCwsgBUHgAWoiAiAEIAcQCEGIf0sNByAFQfQBaiACIAgoAgAQHiAFQfwBaiACIAgoAggQHiAFQYQCaiACIAgoAgQQHiAzRSEeIBMhBwJAA0AgDkUNASAFKAL4ASAFKAL0AUEDdGoiBC0AAiEkIAUoAogCIAUoAoQCQQN0aiIDLQACIRUgBSgCgAIgBSgC/AFBA3RqIgItAAMhJyADLQADIRIgBC0AAyEcIAIvAQAhGSADLwEAIQ8gBC8BACEMIAIoAgQhBiAEKAIEIQQgAygCBCEJAkAgAi0AAiINQQJPBEACQCAeIA1BGUlyRQRAIAUoAuABIiEgBSgC5AEiAnRBBSANa3ZBBXQgBmohBgJAIAIgDWpBBWsiAkEhTwRAIAVBsBo2AugBDAELIAUoAugBIgogBSgC8AFPBEAgBSACQQdxIgM2AuQBIAUgCiACQQN2ayICNgLoASAFIAIoAAAiITYC4AEgAyECDAELIAogBSgC7AEiA0YNACAFIAIgCiADayACQQN2IgIgCiACayADSRsiA0EDdGsiAjYC5AEgBSAKIANrIgM2AugBIAUgAygAACIhNgLgAQsgBSACQQVqIgo2AuQBIAYgISACdEEbdmohDQwBCyAFIAUoAuQBIgIgDWoiCjYC5AEgBSgC4AEgAnRBACANa3YgBmohDSAKQSFPBEAgBUGwGjYC6AEMAQsgBSgC6AEiBiAFKALwAU8EQCAFIApBB3EiAjYC5AEgBSAGIApBA3ZrIgM2AugBIAUgAygAADYC4AEgAiEKDAELIAYgBSgC7AEiA0YNACAFIAogBiADayAKQQN2IgIgBiACayADSRsiAkEDdGsiCjYC5AEgBSAGIAJrIgI2AugBIAUgAigAADYC4AELIAUpAowCITogBSANNgKMAiAFIDo3ApACDAELIARFIQMgDUUEQCAbIARBAEdBAnRqKAIAIQIgBSAbIANBAnRqKAIAIg02AowCIAUgAjYCkAIgBSgC5AEhCgwBCyAFIAUoAuQBIgJBAWoiCjYC5AECQAJAIAMgBmogBSgC4AEgAnRBH3ZqIgNBA0YEQCAFKAKMAkEBayICQX8gAhshDQwBCyAbIANBAnRqKAIAIgJBfyACGyENIANBAUYNAQsgBSAFKAKQAjYClAILIAUgBSgCjAI2ApACIAUgDTYCjAILIBUgJGohAwJAIBVFBEAgCiECDAELIAUgCiAVaiICNgLkASAFKALgASAKdEEAIBVrdiAJaiEJCwJAIANBFEkNACACQSFPBEAgBUGwGjYC6AEMAQsgBSgC6AEiBiAFKALwAU8EQCAFIAJBB3EiAzYC5AEgBSAGIAJBA3ZrIgI2AugBIAUgAigAADYC4AEgAyECDAELIAYgBSgC7AEiA0YNACAFIAIgBiADayACQQN2IgIgBiACayADSRsiA0EDdGsiAjYC5AEgBSAGIANrIgM2AugBIAUgAygAADYC4AELAkAgJEUEQCACIQMMAQsgBSACICRqIgM2AuQBIAUoAuABIAJ0QQAgJGt2IARqIQQLAkAgA0EhTwRAQbAaIQIgBUGwGjYC6AEMAQsgBSgC6AEiAiAFKALwAU8EQCAFIANBB3EiBjYC5AEgBSACIANBA3ZrIgI2AugBIAUgAigAADYC4AEgBiEDDAELIAIgBSgC7AEiCkYNACAFIAIgAiAKayADQQN2IgYgAiAGayAKSRsiBmsiAjYC6AEgBSADIAZBA3RrIgM2AuQBIAUgAigAADYC4AELAkAgDkEBRg0AIAUgHEECdEGwGWooAgAgBSgC4AEiBkEAIAMgHGoiA2t2cSAMajYC9AEgBSASQQJ0QbAZaigCACAGQQAgAyASaiIDa3ZxIA9qNgKEAgJAIANBIU8EQEGwGiECIAVBsBo2AugBDAELIAUoAvABIAJNBEAgBSADQQdxIgo2AuQBIAUgAiADQQN2ayICNgLoASAFIAIoAAAiBjYC4AEgCiEDDAELIAIgBSgC7AEiCkYNACAFIAIgAiAKayADQQN2IgYgAiAGayAKSRsiBmsiAjYC6AEgBSADIAZBA3RrIgM2AuQBIAUgAigAACIGNgLgAQsgBSADICdqIgM2AuQBIAUgJ0ECdEGwGWooAgAgBkEAIANrdnEgGWo2AvwBIANBIU8EQCAFQbAaNgLoAQwBCyAFKALwASACTQRAIAUgA0EHcTYC5AEgBSACIANBA3ZrIgI2AugBIAUgAigAADYC4AEMAQsgAiAFKALsASIGRg0AIAUgAyACIAZrIANBA3YiAyACIANrIAZJGyIDQQN0azYC5AEgBSACIANrIgI2AugBIAUgAigAADYC4AELIAUoAswCIgwgBGoiCiAIKAKA7AEiAk0EQCAKQSBrIQIgBSAENgKoASAFIAk2AqwBIAUgDTYCsAECQAJAAkAgCiARSw0AIAcgBCAJaiIDaiACSw0AIANBIGogGiAHa00NAQsgBUFAayAFKAKwATYCACAFIAUpA6gBNwM4IAcgGiACIAVBOGogBUHMAmogESALIB8gFhAhIQMMAQsgBCAHaiEGIAwpAAAhOiAHIAwpAAg3AAggByA6NwAAAkAgBEERSQ0AIAwpABAhOiAHIAwpABg3ABggByA6NwAQIARBEGtBEUgNACAMQRBqIQIgB0EgaiEEA0AgAikAECE6IAQgAikAGDcACCAEIDo3AAAgAikAICE6IAQgAikAKDcAGCAEIDo3ABAgAkEgaiECIARBIGoiBCAGSQ0ACwsgBiANayECIAUgCjYCzAIgBiALayANSQRAIA0gBiAfa0sNDCAWIBYgAiALayIKaiIEIAlqTwRAIAlFDQIgBiAEIAn8CgAADAILQQAgCmsiAgRAIAYgBCAC/AoAAAsgBSAJIApqIgk2AqwBIAYgCmshBiALIQILIA1BEE8EQCACKQAAITogBiACKQAINwAIIAYgOjcAACAJQRFIDQEgBiAJaiEKIAZBEGohBANAIAIpABAhOiAEIAIpABg3AAggBCA6NwAAIAIpACAhOiAEIAIpACg3ABggBCA6NwAQIAJBIGohAiAEQSBqIgQgCkkNAAsMAQsCQCANQQdNBEAgBiACLQAAOgAAIAYgAi0AAToAASAGIAItAAI6AAIgBiACLQADOgADIAYgAiANQQJ0IgRB4BpqKAIAaiICKAAANgAEIAIgBEGAG2ooAgBrIQIMAQsgBiACKQAANwAACyAJQQlJDQAgBiAJaiEKIAZBCGoiBCACQQhqIgJrQQ9MBEADQCAEIAIpAAA3AAAgAkEIaiECIARBCGoiBCAKSQ0ADAILAAsgAikAACE6IAQgAikACDcACCAEIDo3AAAgCUEZSA0AIAZBGGohBANAIAIpABAhOiAEIAIpABg3AAggBCA6NwAAIAIpACAhOiAEIAIpACg3ABggBCA6NwAQIAJBIGohAiAEQSBqIgQgCkkNAAsLIANBiH9LDQwgDkEBayEOIAMgB2ohBwwBCwsgDkEATA0IIAIgDEcEQEG6fyEDIAIgDGsiAiAaIAdrSw0LIAcgDCACEB8gAiAHaiEHIAQgAmshBAsgBSAIQYjsAWoiAjYCzAIgCEEANgKE7AEgCEGI7AVqIREgBSAENgKoASAFIAk2AqwBIAUgDTYCsAECQAJAAkAgBEGAgARKDQAgByAEIAlqIgNqIBpBIGtLDQAgA0EgaiAaIAdrTQ0BCyAFIAUoArABNgIwIAUgBSkDqAE3AyggByAaIAVBKGogBUHMAmogESALIB8gFhAgIQMMAQsgAiAEaiEKIAQgB2ohBiACKQAAITogByACKQAINwAIIAcgOjcAAAJAIARBEUkNACAIKQCY7AEhOiAHIAhBoOwBaikAADcAGCAHIDo3ABAgBEEQa0ERSA0AIAhBmOwBaiECIAdBIGohBANAIAIpABAhOiAEIAIpABg3AAggBCA6NwAAIAIpACAhOiAEIAIpACg3ABggBCA6NwAQIAJBIGohAiAEQSBqIgQgBkkNAAsLIAYgDWshAiAFIAo2AswCIAYgC2sgDUkEQCANIAYgH2tLDQogFiAWIAIgC2siCmoiBCAJak8EQCAJRQ0CIAYgBCAJ/AoAAAwCC0EAIAprIgIEQCAGIAQgAvwKAAALIAUgCSAKaiIJNgKsASAGIAprIQYgCyECCyANQRBPBEAgAikAACE6IAYgAikACDcACCAGIDo3AAAgCUERSA0BIAYgCWohCiAGQRBqIQQDQCACKQAQITogBCACKQAYNwAIIAQgOjcAACACKQAgITogBCACKQAoNwAYIAQgOjcAECACQSBqIQIgBEEgaiIEIApJDQALDAELAkAgDUEHTQRAIAYgAi0AADoAACAGIAItAAE6AAEgBiACLQACOgACIAYgAi0AAzoAAyAGIAIgDUECdCIEQeAaaigCAGoiAigAADYABCACIARBgBtqKAIAayECDAELIAYgAikAADcAAAsgCUEJSQ0AIAYgCWohCiAGQQhqIgQgAkEIaiICa0EPTARAA0AgBCACKQAANwAAIAJBCGohAiAEQQhqIgQgCkkNAAwCCwALIAIpAAAhOiAEIAIpAAg3AAggBCA6NwAAIAlBGUgNACAGQRhqIQQDQCACKQAQITogBCACKQAYNwAIIAQgOjcAACACKQAgITogBCACKQAoNwAYIAQgOjcAECACQSBqIQIgBEEgaiIEIApJDQALCyADQYh/Sw0KIAMgB2ohByAOQQFrIgpFDQAgGkEgayESIDNFIRwDQCAFKAL4ASAFKAL0AUEDdGoiBC0AAiEJIAUoAogCIAUoAoQCQQN0aiIDLQACIQwgBSgCgAIgBSgC/AFBA3RqIgItAAMhJCADLQADIRUgBC0AAyEnIAIvAQAhHiADLwEAIRkgBC8BACEPIAIoAgQhBiAEKAIEIQQgAygCBCEOAkAgAi0AAiIYQQJPBEACQCAcIBhBGUlyRQRAIAUoAuABIiogBSgC5AEiAnRBBSAYa3ZBBXQgBmohBgJAIAIgGGpBBWsiAkEhTwRAIAVBsBo2AugBDAELIAUoAugBIg0gBSgC8AFPBEAgBSACQQdxIgM2AuQBIAUgDSACQQN2ayICNgLoASAFIAIoAAAiKjYC4AEgAyECDAELIA0gBSgC7AEiA0YNACAFIAIgDSADayACQQN2IgIgDSACayADSRsiA0EDdGsiAjYC5AEgBSANIANrIgM2AugBIAUgAygAACIqNgLgAQsgBSACQQVqIg02AuQBIAYgKiACdEEbdmohBgwBCyAFIAUoAuQBIgIgGGoiDTYC5AEgBSgC4AEgAnRBACAYa3YgBmohBiANQSFPBEAgBUGwGjYC6AEMAQsgBSgC6AEiGCAFKALwAU8EQCAFIA1BB3EiAjYC5AEgBSAYIA1BA3ZrIgM2AugBIAUgAygAADYC4AEgAiENDAELIBggBSgC7AEiA0YNACAFIA0gGCADayANQQN2IgIgGCACayADSRsiAkEDdGsiDTYC5AEgBSAYIAJrIgI2AugBIAUgAigAADYC4AELIAUpAowCITogBSAGNgKMAiAFIDo3ApACDAELIARFIQMgGEUEQCAbIARBAEdBAnRqKAIAIQIgBSAbIANBAnRqKAIAIgY2AowCIAUgAjYCkAIgBSgC5AEhDQwBCyAFIAUoAuQBIgJBAWoiDTYC5AECQAJAIAMgBmogBSgC4AEgAnRBH3ZqIgNBA0YEQCAFKAKMAkEBayICQX8gAhshBgwBCyAbIANBAnRqKAIAIgJBfyACGyEGIANBAUYNAQsgBSAFKAKQAjYClAILIAUgBSgCjAI2ApACIAUgBjYCjAILIAkgDGohAwJAIAxFBEAgDSECDAELIAUgDCANaiICNgLkASAFKALgASANdEEAIAxrdiAOaiEOCwJAIANBFEkNACACQSFPBEAgBUGwGjYC6AEMAQsgBSgC6AEiDCAFKALwAU8EQCAFIAJBB3EiAzYC5AEgBSAMIAJBA3ZrIgI2AugBIAUgAigAADYC4AEgAyECDAELIAwgBSgC7AEiA0YNACAFIAIgDCADayACQQN2IgIgDCACayADSRsiA0EDdGsiAjYC5AEgBSAMIANrIgM2AugBIAUgAygAADYC4AELAkAgCUUEQCACIQMMAQsgBSACIAlqIgM2AuQBIAUoAuABIAJ0QQAgCWt2IARqIQQLAkAgA0EhTwRAQbAaIQIgBUGwGjYC6AEMAQsgBSgC6AEiAiAFKALwAU8EQCAFIANBB3EiDDYC5AEgBSACIANBA3ZrIgI2AugBIAUgAigAADYC4AEgDCEDDAELIAIgBSgC7AEiCUYNACAFIAIgAiAJayADQQN2IgwgAiAMayAJSRsiDGsiAjYC6AEgBSADIAxBA3RrIgM2AuQBIAUgAigAADYC4AELAkAgCkEBRg0AIAUgJ0ECdEGwGWooAgAgBSgC4AEiCUEAIAMgJ2oiA2t2cSAPajYC9AEgBSAVQQJ0QbAZaigCACAJQQAgAyAVaiIDa3ZxIBlqNgKEAgJAIANBIU8EQEGwGiECIAVBsBo2AugBDAELIAUoAvABIAJNBEAgBSADQQdxIgw2AuQBIAUgAiADQQN2ayICNgLoASAFIAIoAAAiCTYC4AEgDCEDDAELIAIgBSgC7AEiD0YNACAFIAIgAiAPayADQQN2IgwgAiAMayAPSRsiDGsiAjYC6AEgBSADIAxBA3RrIgM2AuQBIAUgAigAACIJNgLgAQsgBSADICRqIgM2AuQBIAUgJEECdEGwGWooAgAgCUEAIANrdnEgHmo2AvwBIANBIU8EQCAFQbAaNgLoAQwBCyAFKALwASACTQRAIAUgA0EHcTYC5AEgBSACIANBA3ZrIgI2AugBIAUgAigAADYC4AEMAQsgAiAFKALsASIMRg0AIAUgAyACIAxrIANBA3YiAyACIANrIAxJGyIDQQN0azYC5AEgBSACIANrIgI2AugBIAUgAigAADYC4AELIAUgBDYCqAEgBSAONgKsASAFIAY2ArABAkACQAJAIAUoAswCIgIgBGoiDCARSw0AIAcgBCAOaiIDaiASSw0AIANBIGogGiAHa00NAQsgBSAFKAKwATYCICAFIAUpA6gBNwMYIAcgGiAFQRhqIAVBzAJqIBEgCyAfIBYQICEDDAELIAQgB2ohCSACKQAAITogByACKQAINwAIIAcgOjcAAAJAIARBEUkNACACKQAQITogByACKQAYNwAYIAcgOjcAECAEQRBrQRFIDQAgAkEQaiECIAdBIGohBANAIAIpABAhOiAEIAIpABg3AAggBCA6NwAAIAIpACAhOiAEIAIpACg3ABggBCA6NwAQIAJBIGohAiAEQSBqIgQgCUkNAAsLIAkgBmshAiAFIAw2AswCIAkgC2sgBkkEQCAGIAkgH2tLDQsgFiAWIAIgC2siDGoiBCAOak8EQCAORQ0CIAkgBCAO/AoAAAwCC0EAIAxrIgIEQCAJIAQgAvwKAAALIAUgDCAOaiIONgKsASAJIAxrIQkgCyECCyAGQRBPBEAgAikAACE6IAkgAikACDcACCAJIDo3AAAgDkERSA0BIAkgDmohBiAJQRBqIQQDQCACKQAQITogBCACKQAYNwAIIAQgOjcAACACKQAgITogBCACKQAoNwAYIAQgOjcAECACQSBqIQIgBEEgaiIEIAZJDQALDAELAkAgBkEHTQRAIAkgAi0AADoAACAJIAItAAE6AAEgCSACLQACOgACIAkgAi0AAzoAAyAJIAIgBkECdCIEQeAaaigCAGoiAigAADYABCACIARBgBtqKAIAayECDAELIAkgAikAADcAAAsgDkEJSQ0AIAkgDmohBiAJQQhqIgQgAkEIaiICa0EPTARAA0AgBCACKQAANwAAIAJBCGohAiAEQQhqIgQgBkkNAAwCCwALIAIpAAAhOiAEIAIpAAg3AAggBCA6NwAAIA5BGUgNACAJQRhqIQQDQCACKQAQITogBCACKQAYNwAIIAQgOjcAACACKQAgITogBCACKQAoNwAYIAQgOjcAECACQSBqIQIgBEEgaiIEIAZJDQALCyADQYh/Sw0LIAMgB2ohByAKQQFrIgoNAAsLIAUoAugBIAUoAuwBRw0HQWwhAyAFKALkAUEgRw0JQQAhAgNAIAJBA0cEQCArIAJBAnQiA2ogAyAbaigCADYCACACQQFqIQIMAQsLIAUoAswCIgMgCCgChOwBQQJHDQEaCyARIANrIgIgGiAHa0sNBUEAIQQgBwRAIAIEQCAHIAMgAvwKAAALIAIgB2ohBAsgCEEANgKE7AEgCEGI7AVqIREgBCEHIAhBiOwBagshAiARIAJrIgMgGiAHa0sNBCAHBH8gAwRAIAcgAiAD/AoAAAsgAyAHagVBAAsgE2shAwwHCyATIBRBACAUQQBKG2oMAQsgCCgC/OsBCyEWIAUgCCgC+OoBIgI2AswCIAIgCCgCiOsBaiEfAkAgDkUEQCATIQkMAQsgCCgCuOkBIRggCCgCtOkBISsgCCgCsOkBIQwgCEEBNgKM6gEgCEGs0AFqISQgBUGMAmohGkEAIQIDQCACQQNHBEAgGiACQQJ0IgNqIAMgJGooAgA2AgAgAkEBaiECDAELC0FsIQMgBUHgAWoiAiAEIAcQCEGIf0sNBSAFQfQBaiACIAgoAgAQHiAFQfwBaiACIAgoAggQHiAFQYQCaiACIAgoAgQQHiAWQSBrIRwgM0UhHiATIQkDQCAOBEAgBSgC+AEgBSgC9AFBA3RqIgItAAIhGyAFKAKIAiAFKAKEAkEDdGoiBC0AAiENIAUoAoACIAUoAvwBQQN0aiIGLQADIRUgBC0AAyEnIAItAAMhEiAGLwEAIRkgBC8BACERIAIvAQAhDyAGKAIEIQcgAigCBCECIAQoAgQhBAJAIAYtAAIiKEECTwRAAkAgHiAoQRlJckUEQCAFKALgASIhIAUoAuQBIgZ0QQUgKGt2QQV0IAdqIQcCQCAGIChqQQVrIgZBIU8EQCAFQbAaNgLoAQwBCyAFKALoASIKIAUoAvABTwRAIAUgBkEHcSILNgLkASAFIAogBkEDdmsiBjYC6AEgBSAGKAAAIiE2AuABIAshBgwBCyAKIAUoAuwBIgtGDQAgBSAGIAogC2sgBkEDdiIGIAogBmsgC0kbIgtBA3RrIgY2AuQBIAUgCiALayILNgLoASAFIAsoAAAiITYC4AELIAUgBkEFaiIKNgLkASAHICEgBnRBG3ZqIRAMAQsgBSAFKALkASIGIChqIgo2AuQBIAUoAuABIAZ0QQAgKGt2IAdqIRAgCkEhTwRAIAVBsBo2AugBDAELIAUoAugBIgcgBSgC8AFPBEAgBSAKQQdxIgY2AuQBIAUgByAKQQN2ayILNgLoASAFIAsoAAA2AuABIAYhCgwBCyAHIAUoAuwBIgtGDQAgBSAKIAcgC2sgCkEDdiIGIAcgBmsgC0kbIgZBA3RrIgo2AuQBIAUgByAGayIGNgLoASAFIAYoAAA2AuABCyAFKQKMAiE6IAUgEDYCjAIgBSA6NwKQAgwBCyACRSELIChFBEAgGiACQQBHQQJ0aigCACEGIAUgGiALQQJ0aigCACIQNgKMAiAFIAY2ApACIAUoAuQBIQoMAQsgBSAFKALkASIGQQFqIgo2AuQBAkACQCAHIAtqIAUoAuABIAZ0QR92aiILQQNGBEAgBSgCjAJBAWsiBkF/IAYbIRAMAQsgGiALQQJ0aigCACIGQX8gBhshECALQQFGDQELIAUgBSgCkAI2ApQCCyAFIAUoAowCNgKQAiAFIBA2AowCCyANIBtqIQsCQCANRQRAIAohBgwBCyAFIAogDWoiBjYC5AEgBSgC4AEgCnRBACANa3YgBGohBAsCQCALQRRJDQAgBkEhTwRAIAVBsBo2AugBDAELIAUoAugBIgcgBSgC8AFPBEAgBSAGQQdxIgs2AuQBIAUgByAGQQN2ayIGNgLoASAFIAYoAAA2AuABIAshBgwBCyAHIAUoAuwBIgtGDQAgBSAGIAcgC2sgBkEDdiIGIAcgBmsgC0kbIgtBA3RrIgY2AuQBIAUgByALayILNgLoASAFIAsoAAA2AuABCwJAIBtFBEAgBiEHDAELIAUgBiAbaiIHNgLkASAFKALgASAGdEEAIBtrdiACaiECCwJAIAdBIU8EQEGwGiEGIAVBsBo2AugBDAELIAUoAugBIgYgBSgC8AFPBEAgBSAHQQdxIgs2AuQBIAUgBiAHQQN2ayIGNgLoASAFIAYoAAA2AuABIAshBwwBCyAGIAUoAuwBIgpGDQAgBSAGIAYgCmsgB0EDdiILIAYgC2sgCkkbIgtrIgY2AugBIAUgByALQQN0ayIHNgLkASAFIAYoAAA2AuABCwJAIA5BAUYNACAFIBJBAnRBsBlqKAIAIAUoAuABIg1BACAHIBJqIgtrdnEgD2o2AvQBIAUgJ0ECdEGwGWooAgAgDUEAIAsgJ2oiB2t2cSARajYChAICQCAHQSFPBEBBsBohBiAFQbAaNgLoAQwBCyAFKALwASAGTQRAIAUgB0EHcSILNgLkASAFIAYgB0EDdmsiBjYC6AEgBSAGKAAAIg02AuABIAshBwwBCyAGIAUoAuwBIgpGDQAgBSAGIAYgCmsgB0EDdiILIAYgC2sgCkkbIgtrIgY2AugBIAUgByALQQN0ayIHNgLkASAFIAYoAAAiDTYC4AELIAUgByAVaiILNgLkASAFIBVBAnRBsBlqKAIAIA1BACALa3ZxIBlqNgL8ASALQSFPBEAgBUGwGjYC6AEMAQsgBSgC8AEgBk0EQCAFIAtBB3E2AuQBIAUgBiALQQN2ayIGNgLoASAFIAYoAAA2AuABDAELIAYgBSgC7AEiB0YNACAFIAsgBiAHayALQQN2IgsgBiALayAHSRsiC0EDdGs2AuQBIAUgBiALayIGNgLoASAFIAYoAAA2AuABCyAFIAI2AqgBIAUgBDYCrAEgBSAQNgKwAQJAAkACQCAFKALMAiIGIAJqIgsgH0sNACAJIAIgBGoiDWogHEsNACANQSBqIBYgCWtNDQELIAUgBSgCsAE2AhAgBSAFKQOoATcDCCAJIBYgBUEIaiAFQcwCaiAfIAwgKyAYECAhDQwBCyACIAlqIQcgBikAACE6IAkgBikACDcACCAJIDo3AAACQCACQRFJDQAgBikAECE6IAkgBikAGDcAGCAJIDo3ABAgAkEQa0ERSA0AIAZBEGohBiAJQSBqIQIDQCAGKQAQITogAiAGKQAYNwAIIAIgOjcAACAGKQAgITogAiAGKQAoNwAYIAIgOjcAECAGQSBqIQYgAkEgaiICIAdJDQALCyAHIBBrIQYgBSALNgLMAiAHIAxrIBBJBEAgECAHICtrSw0JIBggGCAGIAxrIgtqIgYgBGpPBEAgBEUNAiAHIAYgBPwKAAAMAgtBACALayICBEAgByAGIAL8CgAACyAFIAQgC2oiBDYCrAEgByALayEHIAwhBgsgEEEQTwRAIAYpAAAhOiAHIAYpAAg3AAggByA6NwAAIARBEUgNASAEIAdqIQQgB0EQaiECA0AgBikAECE6IAIgBikAGDcACCACIDo3AAAgBikAICE6IAIgBikAKDcAGCACIDo3ABAgBkEgaiEGIAJBIGoiAiAESQ0ACwwBCwJAIBBBB00EQCAHIAYtAAA6AAAgByAGLQABOgABIAcgBi0AAjoAAiAHIAYtAAM6AAMgByAGIBBBAnQiC0HgGmooAgBqIgIoAAA2AAQgAiALQYAbaigCAGshBgwBCyAHIAYpAAA3AAALIARBCUkNACAEIAdqIQsgB0EIaiICIAZBCGoiBmtBD0wEQANAIAIgBikAADcAACAGQQhqIQYgAkEIaiICIAtJDQAMAgsACyAGKQAAITogAiAGKQAINwAIIAIgOjcAACAEQRlIDQAgB0EYaiECA0AgBikAECE6IAIgBikAGDcACCACIDo3AAAgBikAICE6IAIgBikAKDcAGCACIDo3ABAgBkEgaiEGIAJBIGoiAiALSQ0ACwsgDUGIf0sEQCANIQMMCAUgDkEBayEOIAkgDWohCQwCCwALCyAFKALoASAFKALsAUcNBSAFKALkAUEgRw0FQQAhBgNAIAZBA0cEQCAkIAZBAnQiAmogAiAaaigCADYCACAGQQFqIQYMAQsLIAUoAswCIQILQbp/IQMgHyACayIEIBYgCWtLDQQgCQR/IAQEQCAJIAIgBPwKAAALIAQgCWoFQQALIBNrIQMMBAsgAkECRgRAIBwgA2siAiAUIAlrSw0BIAkEfyACBEAgCSADIAL8CgAACyACIAlqBUEACyEJIAhBiOwFaiEcIAhBiOwBaiEDCyAcIANrIgIgFCAJa0sNACAJBH8gAgRAIAkgAyAC/AoAAAsgAiAJagVBAAsgE2shAwwDC0G6fyEDDAILQWwhAwwBC0G4fyEDCyAFQdACaiQAIAMhBAwECyAgIDUgE2tLDQkgE0UEQCAgDQIMBQsgICIERQ0FIBMgHSAE/AoAAAwFCyAxKAIMIgQgAiATa0sNCCATDQEgBEUNAwtBtn8hBAwJCyAERQ0AIBMgHS0AACAE/AsACyAEQYh/Sw0HDAELQQAhBAsCQCAIKAL06gFFIBNFcg0AIAggCCkDkOoBIAStfDcDkOoBIAgoAtjqASIGIARqQR9NBEAgBARAIAYgNGogEyAE/AoAAAsgCCAIKALY6gEgBGo2AtjqAQwBCyATIQMgBgRAQSAgBmsiAgRAIAYgNGogAyAC/AoAAAsgCCgC2OoBIQIgCEEANgLY6gEgCCAIKQOY6gEgCCkAuOoBQs/W077Sx6vZQn58Qh+JQoeVr6+Ytt6bnn9+NwOY6gEgCCAIKQOg6gEgCCkAwOoBQs/W077Sx6vZQn58Qh+JQoeVr6+Ytt6bnn9+NwOg6gEgCCAIKQOo6gEgCCkAyOoBQs/W077Sx6vZQn58Qh+JQoeVr6+Ytt6bnn9+NwOo6gEgCCAIKQOw6gEgCCkA0OoBQs/W077Sx6vZQn58Qh+JQoeVr6+Ytt6bnn9+NwOw6gEgEyACa0EgaiEDCyAEIBNqIgYgA0Egak8EQCAGQSBrIQIgCCkDsOoBITsgCCkDqOoBITwgCCkDoOoBIT0gCCkDmOoBIToDQCAIIAMpAABCz9bTvtLHq9lCfiA6fEIfiUKHla+vmLbem55/fiI6NwOY6gEgCCADKQAIQs/W077Sx6vZQn4gPXxCH4lCh5Wvr5i23puef34iPTcDoOoBIAggAykAEELP1tO+0ser2UJ+IDx8Qh+JQoeVr6+Ytt6bnn9+Ijw3A6jqASAIIAMpABhCz9bTvtLHq9lCfiA7fEIfiUKHla+vmLbem55/fiI7NwOw6gEgA0EgaiIDIAJNDQALCyADIAZPDQAgBiADayICBEAgNCADIAL8CgAACyAIIAI2AtjqAQsgOCAgayEDIB0gIGohAiAEIBNqIRMgMSgCCEUNAAsgNikDACI6Qn9RIDogEyAsa6xRckUEQEFsIQYMBgsgCCgC4OkBBEBBaiEGIANBBEkNBiAIKALw6gFFBEAgAigAAAJ+IDcpAwAiPkIgWgRAIAgpA6DqASI7QgeJIAgpA5jqASI8QgGJfCAIKQOo6gEiPUIMiXwgCCkDsOoBIjpCEol8IDxCz9bTvtLHq9lCfkIfiUKHla+vmLbem55/foVCh5Wvr5i23puef35CnaO16oOxjYr6AH0gO0LP1tO+0ser2UJ+Qh+JQoeVr6+Ytt6bnn9+hUKHla+vmLbem55/fkKdo7Xqg7GNivoAfSA9Qs/W077Sx6vZQn5CH4lCh5Wvr5i23puef36FQoeVr6+Ytt6bnn9+Qp2jteqDsY2K+gB9IDpCz9bTvtLHq9lCfkIfiUKHla+vmLbem55/foVCh5Wvr5i23puef35CnaO16oOxjYr6AH0MAQsgCCkDqOoBQsXP2bLx5brqJ3wLID58IDQgPqcQIqdHDQcLIANBBGshAyACQQRqIQILIBMgLGsiBEGJf08NBCABIARrIQEgBCAsaiEsQQEhOQwBCwsgAwRAQbh/IQYMBAsgLCAAayEGDAMLQbp/IQQMAQtBuH8hBAtBuH8gBCAEQXZGGyAEIDkbIQYLIAgoApDrAQ0AIAgoAoTrASECIAgoAoDrASEDIAgQFiAIKALA6wEgAyACEBUgCEEANgLA6wEgCCgCrOsBIgEEQAJAAkACQAJAIAEoAgAiAARAIANFDQIgAiAAIAMRAgAMAQsgA0UNAgsgAiABIAMRAgAMAgsgABACCyABEAILIAhBADYCrOsBCyADBEAgAiAIIAMRAgAMAQsgCBACCyAxQRBqJAAgBgsKACAABEAQJgALCwMAAAsLzRIKAEGICAsFAQAAAAEAQZgIC9sEAQAAAAEAAACWAAAA2AAAAH0BAAB3AAAAqgAAAM0AAAACAgAAcAAAALEAAADHAAAAGwIAAG4AAADFAAAAwgAAAIQCAABrAAAA3QAAAMAAAADfAgAAawAAAAABAAC9AAAAcQMAAGoAAABnAQAAvAAAAI8EAABtAAAARgIAALsAAAAiBgAAcgAAALACAAC7AAAAsAYAAHoAAAA5AwAAugAAAK0HAACIAAAA0AMAALkAAABTCAAAlgAAAJwEAAC6AAAAFggAAK8AAABhBQAAuQAAAMMGAADKAAAAhAUAALkAAACfBgAAygAAAAAAAAABAAAAAQAAAAUAAAANAAAAHQAAAD0AAAB9AAAA/QAAAP0BAAD9AwAA/QcAAP0PAAD9HwAA/T8AAP1/AAD9/wAA/f8BAP3/AwD9/wcA/f8PAP3/HwD9/z8A/f9/AP3//wD9//8B/f//A/3//wf9//8P/f//H/3//z/9//9/AAECAwQFBgcICQoLDA0ODxAREhMUFRYXGBkaGxwdHh8DAAAABAAAAAUAAAAGAAAABwAAAAgAAAAJAAAACgAAAAsAAAAMAAAADQAAAA4AAAAPAAAAEAAAABEAAAASAAAAEwAAABQAAAAVAAAAFgAAABcAAAAYAAAAGQAAABoAAAAbAAAAHAAAAB0AAAAeAAAAHwAAACAAAAAhAAAAIgAAACMAAAAlAAAAJwAAACkAAAArAAAALwAAADMAAAA7AAAAQwAAAFMAAABjAAAAgwAAAAMBAAADAgAAAwQAAAMIAAADEAAAAyAAAANAAAADgAAAAwABAEGgDQsVAQEBAQICAwMEBAUHCAkKCwwNDg8QAEHEDQuLAQEAAAACAAAAAwAAAAQAAAAFAAAABgAAAAcAAAAIAAAACQAAAAoAAAALAAAADAAAAA0AAAAOAAAADwAAABAAAAASAAAAFAAAABYAAAAYAAAAHAAAACAAAAAoAAAAMAAAAEAAAACAAAAAAAEAAAACAAAABAAAAAgAAAAQAAAAIAAAAEAAAACAAAAAAAEAQeAOC6YEAQEBAQICAwMEBgcICQoLDA0ODxABAAAABAAAAAgAAAABAAEBBgAAAAAAAAQAAAAAEAAABAAAAAAgAAAFAQAAAAAAAAUDAAAAAAAABQQAAAAAAAAFBgAAAAAAAAUHAAAAAAAABQkAAAAAAAAFCgAAAAAAAAUMAAAAAAAABg4AAAAAAAEFEAAAAAAAAQUUAAAAAAABBRYAAAAAAAIFHAAAAAAAAwUgAAAAAAAEBTAAAAAgAAYFQAAAAAAABwWAAAAAAAAIBgABAAAAAAoGAAQAAAAADAYAEAAAIAAABAAAAAAAAAAEAQAAAAAAAAUCAAAAIAAABQQAAAAAAAAFBQAAACAAAAUHAAAAAAAABQgAAAAgAAAFCgAAAAAAAAULAAAAAAAABg0AAAAgAAEFEAAAAAAAAQUSAAAAIAABBRYAAAAAAAIFGAAAACAAAwUgAAAAAAADBSgAAAAAAAYEQAAAABAABgRAAAAAIAAHBYAAAAAAAAkGAAIAAAAACwYACAAAMAAABAAAAAAQAAAEAQAAACAAAAUCAAAAIAAABQMAAAAgAAAFBQAAACAAAAUGAAAAIAAABQgAAAAgAAAFCQAAACAAAAULAAAAIAAABQwAAAAAAAAGDwAAACAAAQUSAAAAIAABBRQAAAAgAAIFGAAAACAAAgUcAAAAIAADBSgAAAAgAAQFMAAAAAAAEAYAAAEAAAAPBgCAAAAAAA4GAEAAAAAADQYAIABBkBMLhwIBAAEBBQAAAAAAAAUAAAAAAAAGBD0AAAAAAAkF/QEAAAAADwX9fwAAAAAVBf3/HwAAAAMFBQAAAAAABwR9AAAAAAAMBf0PAAAAABIF/f8DAAAAFwX9/38AAAAFBR0AAAAAAAgE/QAAAAAADgX9PwAAAAAUBf3/DwAAAAIFAQAAABAABwR9AAAAAAALBf0HAAAAABEF/f8BAAAAFgX9/z8AAAAEBQ0AAAAQAAgE/QAAAAAADQX9HwAAAAATBf3/BwAAAAEFAQAAABAABgQ9AAAAAAAKBf0DAAAAABAF/f8AAAAAHAX9//8PAAAbBf3//wcAABoF/f//AwAAGQX9//8BAAAYBf3//wBBoBULhgQBAAEBBgAAAAAAAAYDAAAAAAAABAQAAAAgAAAFBQAAAAAAAAUGAAAAAAAABQgAAAAAAAAFCQAAAAAAAAULAAAAAAAABg0AAAAAAAAGEAAAAAAAAAYTAAAAAAAABhYAAAAAAAAGGQAAAAAAAAYcAAAAAAAABh8AAAAAAAAGIgAAAAAAAQYlAAAAAAABBikAAAAAAAIGLwAAAAAAAwY7AAAAAAAEBlMAAAAAAAcGgwAAAAAACQYDAgAAEAAABAQAAAAAAAAEBQAAACAAAAUGAAAAAAAABQcAAAAgAAAFCQAAAAAAAAUKAAAAAAAABgwAAAAAAAAGDwAAAAAAAAYSAAAAAAAABhUAAAAAAAAGGAAAAAAAAAYbAAAAAAAABh4AAAAAAAAGIQAAAAAAAQYjAAAAAAABBicAAAAAAAIGKwAAAAAAAwYzAAAAAAAEBkMAAAAAAAUGYwAAAAAACAYDAQAAIAAABAQAAAAwAAAEBAAAABAAAAQFAAAAIAAABQcAAAAgAAAFCAAAACAAAAUKAAAAIAAABQsAAAAAAAAGDgAAAAAAAAYRAAAAAAAABhQAAAAAAAAGFwAAAAAAAAYaAAAAAAAABh0AAAAAAAAGIAAAAAAAEAYDAAEAAAAPBgOAAAAAAA4GA0AAAAAADQYDIAAAAAAMBgMQAAAAAAsGAwgAAAAACgYDBABBtBkLfAEAAAADAAAABwAAAA8AAAAfAAAAPwAAAH8AAAD/AAAA/wEAAP8DAAD/BwAA/w8AAP8fAAD/PwAA/38AAP//AAD//wEA//8DAP//BwD//w8A//8fAP//PwD//38A////AP///wH///8D////B////w////8f////P////38AQcQaC1kBAAAAAgAAAAQAAAAAAAAAAgAAAAQAAAAIAAAAAAAAAAEAAAACAAAAAQAAAAQAAAAEAAAABAAAAAQAAAAIAAAACAAAAAgAAAAHAAAACAAAAAkAAAAKAAAACwBBoBsLA6APAQ==';\n// wasm:end\n\nexport { ZSTDDecoder };\n//# sourceMappingURL=zstddec.modern.js.map\n","import { inflate } from 'pako';\nimport Lerc from 'lerc';\nimport { ZSTDDecoder } from 'zstddec';\nimport BaseDecoder from './basedecoder.js';\nimport { LercParameters, LercAddCompression } from '../globals.js';\nexport const zstd = new ZSTDDecoder();\nexport default class LercDecoder extends BaseDecoder {\n    decodeBlock(buffer) {\n        const addCompression = this.parameters.LercParameters[LercParameters.AddCompression];\n        switch (addCompression) {\n            case LercAddCompression.None:\n                break;\n            case LercAddCompression.Deflate:\n                buffer = inflate(new Uint8Array(buffer)).buffer; // eslint-disable-line no-param-reassign, prefer-destructuring\n                break;\n            case LercAddCompression.Zstandard:\n                buffer = zstd.decode(new Uint8Array(buffer)).buffer; // eslint-disable-line no-param-reassign, prefer-destructuring\n                break;\n            default:\n                throw new Error(`Unsupported LERC additional compression method identifier: ${addCompression}`);\n        }\n        const lercResult = Lerc.decode(buffer, { returnPixelInterleavedDims: this.parameters.planarConfiguration === 1 });\n        const lercData = lercResult.pixels[0];\n        return lercData.buffer;\n    }\n}\n"],"names":["LercDecode","CntZImage","input","options","skipMask","parsedData","parse","noDataValue","uncompressedData","uncompressPixelValues","result","formatFileInfo","computeUsedBitDepths","data","TypedArrayClass","maskBitset","storeDecodedMask","blockIdx","numX","numY","blockWidth","blockHeight","scale","minValue","currentValue","resultPixels","resultMask","blockDataBuffer","xx","yy","thisBlockHeight","x","thisBlockWidth","outPtr","outStride","block","blockData","blockPtr","constValue","unstuff","maskByte","numBlocks","bitDepths","i","fp","fileIdView","view","bitset","cnt","ip","op","val","numBlocksX","numBlocksY","actualNumBlocksX","actualNumBlocksY","blockI","blockY","blockX","size","bytesLeft","headerByte","arrayBuf","store8","numPixels","rawData","dataBytes","dataWords","src","bitsPerPixel","offset","dest","maxValue","bitMask","o","bitsLeft","n","buffer","nmax","numInvalidTailBytes","missingBits","Lerc2Decode","BitStuffer","lutArr","bitPos","Lerc2Helpers","sum1","sum2","len","words","tlen","ptr","headerInfo","fileVersion","checksum","keyLength","OutPixelTypeArray","rangeBytes","minValues","maxValues","equal","numBytes","numValidPixel","mask","mb","k","useBSQForOutputDim","numDims","imageType","z","nStart","BITS_MAX","version","i0","i1","codeTable","j","stuffedData","word","srcPtr","numBitsLUT","numBitsLUTQick","tree","TreeNode","decodeLut","entry","code","numEntries","jj","currentBit","node","height","width","huffmanInfo","delta","valTmp","valTmpQuick","ii","prevVal","deltaEncode","resultPixelsAllDim","iDim","viewByteLength","bits67","doLut","numBits","numElements","lutData","lutBytes","zMax","microBlockSize","dataTypeSize","row","col","testCode","bytesleft","blockEncoding","lastBlockHeight","lastBlockWidth","offsetType","fileVersionCheckNum","isDiffEncoding","resultPixelsPrevDim","valMin","t","tp","isValid","s","dt","tc","temp","pixels","inputIsBIP","swap","left","right","bReadDataOneSweep","flagHuffman","diff","count","isPlatformLittleEndian","a","b","c","Lerc","encodedData","inputOffset","fileIdentifierString","lerc","majorVersion","iPlane","eof","encodedMaskData","bandMasks","bandMask","maskData","decodedPixelBlock","uniqueBandMaskCount","module","init","instance","heap","IMPORT_OBJECT","_","ZSTDDecoder$1","wasm","response","arrayBuffer","array","uncompressedSize","compressedSize","compressedPtr","uncompressedPtr","actualSize","dec","zstd","ZSTDDecoder","LercDecoder","BaseDecoder","addCompression","LercParameters","LercAddCompression","inflate"],"mappings":"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","x_google_ignoreList":[0,1,2]}