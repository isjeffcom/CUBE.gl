{"version":3,"file":"basedecoder-B9XUu15s.js","sources":["../node_modules/geotiff/dist-module/predictor.js","../node_modules/geotiff/dist-module/compression/basedecoder.js"],"sourcesContent":["function decodeRowAcc(row, stride) {\n    let length = row.length - stride;\n    let offset = 0;\n    do {\n        for (let i = stride; i > 0; i--) {\n            row[offset + stride] += row[offset];\n            offset++;\n        }\n        length -= stride;\n    } while (length > 0);\n}\nfunction decodeRowFloatingPoint(row, stride, bytesPerSample) {\n    let index = 0;\n    let count = row.length;\n    const wc = count / bytesPerSample;\n    while (count > stride) {\n        for (let i = stride; i > 0; --i) {\n            row[index + stride] += row[index];\n            ++index;\n        }\n        count -= stride;\n    }\n    const copy = row.slice();\n    for (let i = 0; i < wc; ++i) {\n        for (let b = 0; b < bytesPerSample; ++b) {\n            row[(bytesPerSample * i) + b] = copy[((bytesPerSample - b - 1) * wc) + i];\n        }\n    }\n}\nexport function applyPredictor(block, predictor, width, height, bitsPerSample, planarConfiguration) {\n    if (!predictor || predictor === 1) {\n        return block;\n    }\n    for (let i = 0; i < bitsPerSample.length; ++i) {\n        if (bitsPerSample[i] % 8 !== 0) {\n            throw new Error('When decoding with predictor, only multiple of 8 bits are supported.');\n        }\n        if (bitsPerSample[i] !== bitsPerSample[0]) {\n            throw new Error('When decoding with predictor, all samples must have the same size.');\n        }\n    }\n    const bytesPerSample = bitsPerSample[0] / 8;\n    const stride = planarConfiguration === 2 ? 1 : bitsPerSample.length;\n    for (let i = 0; i < height; ++i) {\n        // Last strip will be truncated if height % stripHeight != 0\n        if (i * stride * width * bytesPerSample >= block.byteLength) {\n            break;\n        }\n        let row;\n        if (predictor === 2) { // horizontal prediction\n            switch (bitsPerSample[0]) {\n                case 8:\n                    row = new Uint8Array(block, i * stride * width * bytesPerSample, stride * width * bytesPerSample);\n                    break;\n                case 16:\n                    row = new Uint16Array(block, i * stride * width * bytesPerSample, stride * width * bytesPerSample / 2);\n                    break;\n                case 32:\n                    row = new Uint32Array(block, i * stride * width * bytesPerSample, stride * width * bytesPerSample / 4);\n                    break;\n                default:\n                    throw new Error(`Predictor 2 not allowed with ${bitsPerSample[0]} bits per sample.`);\n            }\n            decodeRowAcc(row, stride, bytesPerSample);\n        }\n        else if (predictor === 3) { // horizontal floating point\n            row = new Uint8Array(block, i * stride * width * bytesPerSample, stride * width * bytesPerSample);\n            decodeRowFloatingPoint(row, stride, bytesPerSample);\n        }\n    }\n    return block;\n}\n","import { applyPredictor } from '../predictor.js';\nexport default class BaseDecoder {\n    constructor(parameters) {\n        this.parameters = parameters;\n    }\n    async decode(buffer) {\n        const decoded = await this.decodeBlock(buffer);\n        const { tileWidth, tileHeight, predictor, bitsPerSample, planarConfiguration, } = this.parameters;\n        if (predictor !== 1) {\n            return applyPredictor(decoded, predictor, tileWidth, tileHeight, bitsPerSample, planarConfiguration);\n        }\n        return decoded;\n    }\n}\n"],"names":["decodeRowAcc","row","stride","length","offset","i","decodeRowFloatingPoint","bytesPerSample","index","count","wc","copy","b","applyPredictor","block","predictor","width","height","bitsPerSample","planarConfiguration","BaseDecoder","parameters","buffer","decoded","tileWidth","tileHeight"],"mappings":"AAAA,SAASA,EAAaC,GAAKC,GAAQ;AAC/B,MAAIC,IAASF,EAAI,SAASC,GACtBE,IAAS;AACb,KAAG;AACC,aAASC,IAAIH,GAAQG,IAAI,GAAGA;AACxB,MAAAJ,EAAIG,IAASF,CAAM,KAAKD,EAAIG,CAAM,GAClCA;AAEJ,IAAAD,KAAUD;AAAA,EACd,SAASC,IAAS;AACtB;AACA,SAASG,EAAuBL,GAAKC,GAAQK,GAAgB;AACzD,MAAIC,IAAQ,GACRC,IAAQR,EAAI;AAChB,QAAMS,IAAKD,IAAQF;AACnB,SAAOE,IAAQP,KAAQ;AACnB,aAASG,IAAIH,GAAQG,IAAI,GAAG,EAAEA;AAC1B,MAAAJ,EAAIO,IAAQN,CAAM,KAAKD,EAAIO,CAAK,GAChC,EAAEA;AAEN,IAAAC,KAASP;AAAA,EACb;AACA,QAAMS,IAAOV,EAAI,MAAK;AACtB,WAASI,IAAI,GAAGA,IAAIK,GAAI,EAAEL;AACtB,aAASO,IAAI,GAAGA,IAAIL,GAAgB,EAAEK;AAClC,MAAAX,EAAKM,IAAiBF,IAAKO,CAAC,IAAID,GAAOJ,IAAiBK,IAAI,KAAKF,IAAML,CAAC;AAGpF;AACO,SAASQ,EAAeC,GAAOC,GAAWC,GAAOC,GAAQC,GAAeC,GAAqB;AAChG,MAAI,CAACJ,KAAaA,MAAc;AAC5B,WAAOD;AAEX,WAAST,IAAI,GAAGA,IAAIa,EAAc,QAAQ,EAAEb,GAAG;AAC3C,QAAIa,EAAcb,CAAC,IAAI,MAAM;AACzB,YAAM,IAAI,MAAM,sEAAsE;AAE1F,QAAIa,EAAcb,CAAC,MAAMa,EAAc,CAAC;AACpC,YAAM,IAAI,MAAM,oEAAoE;AAAA,EAE5F;AACA,QAAMX,IAAiBW,EAAc,CAAC,IAAI,GACpChB,IAASiB,MAAwB,IAAI,IAAID,EAAc;AAC7D,WAASb,IAAI,GAAGA,IAAIY,KAEZ,EAAAZ,IAAIH,IAASc,IAAQT,KAAkBO,EAAM,aAFzB,EAAET,GAAG;AAK7B,QAAIJ;AACJ,QAAIc,MAAc,GAAG;AACjB,cAAQG,EAAc,CAAC,GAAC;AAAA,QACpB,KAAK;AACD,UAAAjB,IAAM,IAAI,WAAWa,GAAOT,IAAIH,IAASc,IAAQT,GAAgBL,IAASc,IAAQT,CAAc;AAChG;AAAA,QACJ,KAAK;AACD,UAAAN,IAAM,IAAI,YAAYa,GAAOT,IAAIH,IAASc,IAAQT,GAAgBL,IAASc,IAAQT,IAAiB,CAAC;AACrG;AAAA,QACJ,KAAK;AACD,UAAAN,IAAM,IAAI,YAAYa,GAAOT,IAAIH,IAASc,IAAQT,GAAgBL,IAASc,IAAQT,IAAiB,CAAC;AACrG;AAAA,QACJ;AACI,gBAAM,IAAI,MAAM,gCAAgCW,EAAc,CAAC,CAAC,mBAAmB;AAAA,MACvG;AACY,MAAAlB,EAAaC,GAAKC,CAAsB;AAAA,IAC5C,MACK,CAAIa,MAAc,MACnBd,IAAM,IAAI,WAAWa,GAAOT,IAAIH,IAASc,IAAQT,GAAgBL,IAASc,IAAQT,CAAc,GAChGD,EAAuBL,GAAKC,GAAQK,CAAc;AAAA,EAE1D;AACA,SAAOO;AACX;ACtEe,MAAMM,EAAY;AAAA,EAC7B,YAAYC,GAAY;AACpB,SAAK,aAAaA;AAAA,EACtB;AAAA,EACA,MAAM,OAAOC,GAAQ;AACjB,UAAMC,IAAU,MAAM,KAAK,YAAYD,CAAM,GACvC,EAAE,WAAAE,GAAW,YAAAC,GAAY,WAAAV,GAAW,eAAAG,GAAe,qBAAAC,EAAmB,IAAM,KAAK;AACvF,WAAIJ,MAAc,IACPF,EAAeU,GAASR,GAAWS,GAAWC,GAAYP,GAAeC,CAAmB,IAEhGI;AAAA,EACX;AACJ;","x_google_ignoreList":[0,1]}