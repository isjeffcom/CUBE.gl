{"version":3,"file":"jpeg-BX1FCF4W.js","sources":["../node_modules/geotiff/dist-module/compression/jpeg.js"],"sourcesContent":["import BaseDecoder from './basedecoder.js';\n/* -*- tab-width: 2; indent-tabs-mode: nil; c-basic-offset: 2 -*- /\n/* vim: set shiftwidth=2 tabstop=2 autoindent cindent expandtab: */\n/*\n   Copyright 2011 notmasteryet\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n       http://www.apache.org/licenses/LICENSE-2.0\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\n// - The JPEG specification can be found in the ITU CCITT Recommendation T.81\n//   (www.w3.org/Graphics/JPEG/itu-t81.pdf)\n// - The JFIF specification can be found in the JPEG File Interchange Format\n//   (www.w3.org/Graphics/JPEG/jfif3.pdf)\n// - The Adobe Application-Specific JPEG markers in the Supporting the DCT Filters\n//   in PostScript Level 2, Technical Note #5116\n//   (partners.adobe.com/public/developer/en/ps/sdk/5116.DCT_Filter.pdf)\nconst dctZigZag = new Int32Array([\n    0,\n    1, 8,\n    16, 9, 2,\n    3, 10, 17, 24,\n    32, 25, 18, 11, 4,\n    5, 12, 19, 26, 33, 40,\n    48, 41, 34, 27, 20, 13, 6,\n    7, 14, 21, 28, 35, 42, 49, 56,\n    57, 50, 43, 36, 29, 22, 15,\n    23, 30, 37, 44, 51, 58,\n    59, 52, 45, 38, 31,\n    39, 46, 53, 60,\n    61, 54, 47,\n    55, 62,\n    63,\n]);\nconst dctCos1 = 4017; // cos(pi/16)\nconst dctSin1 = 799; // sin(pi/16)\nconst dctCos3 = 3406; // cos(3*pi/16)\nconst dctSin3 = 2276; // sin(3*pi/16)\nconst dctCos6 = 1567; // cos(6*pi/16)\nconst dctSin6 = 3784; // sin(6*pi/16)\nconst dctSqrt2 = 5793; // sqrt(2)\nconst dctSqrt1d2 = 2896; // sqrt(2) / 2\nfunction buildHuffmanTable(codeLengths, values) {\n    let k = 0;\n    const code = [];\n    let length = 16;\n    while (length > 0 && !codeLengths[length - 1]) {\n        --length;\n    }\n    code.push({ children: [], index: 0 });\n    let p = code[0];\n    let q;\n    for (let i = 0; i < length; i++) {\n        for (let j = 0; j < codeLengths[i]; j++) {\n            p = code.pop();\n            p.children[p.index] = values[k];\n            while (p.index > 0) {\n                p = code.pop();\n            }\n            p.index++;\n            code.push(p);\n            while (code.length <= i) {\n                code.push(q = { children: [], index: 0 });\n                p.children[p.index] = q.children;\n                p = q;\n            }\n            k++;\n        }\n        if (i + 1 < length) {\n            // p here points to last code\n            code.push(q = { children: [], index: 0 });\n            p.children[p.index] = q.children;\n            p = q;\n        }\n    }\n    return code[0].children;\n}\nfunction decodeScan(data, initialOffset, frame, components, resetInterval, spectralStart, spectralEnd, successivePrev, successive) {\n    const { mcusPerLine, progressive } = frame;\n    const startOffset = initialOffset;\n    let offset = initialOffset;\n    let bitsData = 0;\n    let bitsCount = 0;\n    function readBit() {\n        if (bitsCount > 0) {\n            bitsCount--;\n            return (bitsData >> bitsCount) & 1;\n        }\n        bitsData = data[offset++];\n        if (bitsData === 0xFF) {\n            const nextByte = data[offset++];\n            if (nextByte) {\n                throw new Error(`unexpected marker: ${((bitsData << 8) | nextByte).toString(16)}`);\n            }\n            // unstuff 0\n        }\n        bitsCount = 7;\n        return bitsData >>> 7;\n    }\n    function decodeHuffman(tree) {\n        let node = tree;\n        let bit;\n        while ((bit = readBit()) !== null) { // eslint-disable-line no-cond-assign\n            node = node[bit];\n            if (typeof node === 'number') {\n                return node;\n            }\n            if (typeof node !== 'object') {\n                throw new Error('invalid huffman sequence');\n            }\n        }\n        return null;\n    }\n    function receive(initialLength) {\n        let length = initialLength;\n        let n = 0;\n        while (length > 0) {\n            const bit = readBit();\n            if (bit === null) {\n                return undefined;\n            }\n            n = (n << 1) | bit;\n            --length;\n        }\n        return n;\n    }\n    function receiveAndExtend(length) {\n        const n = receive(length);\n        if (n >= 1 << (length - 1)) {\n            return n;\n        }\n        return n + (-1 << length) + 1;\n    }\n    function decodeBaseline(component, zz) {\n        const t = decodeHuffman(component.huffmanTableDC);\n        const diff = t === 0 ? 0 : receiveAndExtend(t);\n        component.pred += diff;\n        zz[0] = component.pred;\n        let k = 1;\n        while (k < 64) {\n            const rs = decodeHuffman(component.huffmanTableAC);\n            const s = rs & 15;\n            const r = rs >> 4;\n            if (s === 0) {\n                if (r < 15) {\n                    break;\n                }\n                k += 16;\n            }\n            else {\n                k += r;\n                const z = dctZigZag[k];\n                zz[z] = receiveAndExtend(s);\n                k++;\n            }\n        }\n    }\n    function decodeDCFirst(component, zz) {\n        const t = decodeHuffman(component.huffmanTableDC);\n        const diff = t === 0 ? 0 : (receiveAndExtend(t) << successive);\n        component.pred += diff;\n        zz[0] = component.pred;\n    }\n    function decodeDCSuccessive(component, zz) {\n        zz[0] |= readBit() << successive;\n    }\n    let eobrun = 0;\n    function decodeACFirst(component, zz) {\n        if (eobrun > 0) {\n            eobrun--;\n            return;\n        }\n        let k = spectralStart;\n        const e = spectralEnd;\n        while (k <= e) {\n            const rs = decodeHuffman(component.huffmanTableAC);\n            const s = rs & 15;\n            const r = rs >> 4;\n            if (s === 0) {\n                if (r < 15) {\n                    eobrun = receive(r) + (1 << r) - 1;\n                    break;\n                }\n                k += 16;\n            }\n            else {\n                k += r;\n                const z = dctZigZag[k];\n                zz[z] = receiveAndExtend(s) * (1 << successive);\n                k++;\n            }\n        }\n    }\n    let successiveACState = 0;\n    let successiveACNextValue;\n    function decodeACSuccessive(component, zz) {\n        let k = spectralStart;\n        const e = spectralEnd;\n        let r = 0;\n        while (k <= e) {\n            const z = dctZigZag[k];\n            const direction = zz[z] < 0 ? -1 : 1;\n            switch (successiveACState) {\n                case 0: { // initial state\n                    const rs = decodeHuffman(component.huffmanTableAC);\n                    const s = rs & 15;\n                    r = rs >> 4;\n                    if (s === 0) {\n                        if (r < 15) {\n                            eobrun = receive(r) + (1 << r);\n                            successiveACState = 4;\n                        }\n                        else {\n                            r = 16;\n                            successiveACState = 1;\n                        }\n                    }\n                    else {\n                        if (s !== 1) {\n                            throw new Error('invalid ACn encoding');\n                        }\n                        successiveACNextValue = receiveAndExtend(s);\n                        successiveACState = r ? 2 : 3;\n                    }\n                    continue; // eslint-disable-line no-continue\n                }\n                case 1: // skipping r zero items\n                case 2:\n                    if (zz[z]) {\n                        zz[z] += (readBit() << successive) * direction;\n                    }\n                    else {\n                        r--;\n                        if (r === 0) {\n                            successiveACState = successiveACState === 2 ? 3 : 0;\n                        }\n                    }\n                    break;\n                case 3: // set value for a zero item\n                    if (zz[z]) {\n                        zz[z] += (readBit() << successive) * direction;\n                    }\n                    else {\n                        zz[z] = successiveACNextValue << successive;\n                        successiveACState = 0;\n                    }\n                    break;\n                case 4: // eob\n                    if (zz[z]) {\n                        zz[z] += (readBit() << successive) * direction;\n                    }\n                    break;\n                default:\n                    break;\n            }\n            k++;\n        }\n        if (successiveACState === 4) {\n            eobrun--;\n            if (eobrun === 0) {\n                successiveACState = 0;\n            }\n        }\n    }\n    function decodeMcu(component, decodeFunction, mcu, row, col) {\n        const mcuRow = (mcu / mcusPerLine) | 0;\n        const mcuCol = mcu % mcusPerLine;\n        const blockRow = (mcuRow * component.v) + row;\n        const blockCol = (mcuCol * component.h) + col;\n        decodeFunction(component, component.blocks[blockRow][blockCol]);\n    }\n    function decodeBlock(component, decodeFunction, mcu) {\n        const blockRow = (mcu / component.blocksPerLine) | 0;\n        const blockCol = mcu % component.blocksPerLine;\n        decodeFunction(component, component.blocks[blockRow][blockCol]);\n    }\n    const componentsLength = components.length;\n    let component;\n    let i;\n    let j;\n    let k;\n    let n;\n    let decodeFn;\n    if (progressive) {\n        if (spectralStart === 0) {\n            decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;\n        }\n        else {\n            decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;\n        }\n    }\n    else {\n        decodeFn = decodeBaseline;\n    }\n    let mcu = 0;\n    let marker;\n    let mcuExpected;\n    if (componentsLength === 1) {\n        mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;\n    }\n    else {\n        mcuExpected = mcusPerLine * frame.mcusPerColumn;\n    }\n    const usedResetInterval = resetInterval || mcuExpected;\n    while (mcu < mcuExpected) {\n        // reset interval stuff\n        for (i = 0; i < componentsLength; i++) {\n            components[i].pred = 0;\n        }\n        eobrun = 0;\n        if (componentsLength === 1) {\n            component = components[0];\n            for (n = 0; n < usedResetInterval; n++) {\n                decodeBlock(component, decodeFn, mcu);\n                mcu++;\n            }\n        }\n        else {\n            for (n = 0; n < usedResetInterval; n++) {\n                for (i = 0; i < componentsLength; i++) {\n                    component = components[i];\n                    const { h, v } = component;\n                    for (j = 0; j < v; j++) {\n                        for (k = 0; k < h; k++) {\n                            decodeMcu(component, decodeFn, mcu, j, k);\n                        }\n                    }\n                }\n                mcu++;\n                // If we've reached our expected MCU's, stop decoding\n                if (mcu === mcuExpected) {\n                    break;\n                }\n            }\n        }\n        // find marker\n        bitsCount = 0;\n        marker = (data[offset] << 8) | data[offset + 1];\n        if (marker < 0xFF00) {\n            throw new Error('marker was not found');\n        }\n        if (marker >= 0xFFD0 && marker <= 0xFFD7) { // RSTx\n            offset += 2;\n        }\n        else {\n            break;\n        }\n    }\n    return offset - startOffset;\n}\nfunction buildComponentData(frame, component) {\n    const lines = [];\n    const { blocksPerLine, blocksPerColumn } = component;\n    const samplesPerLine = blocksPerLine << 3;\n    const R = new Int32Array(64);\n    const r = new Uint8Array(64);\n    // A port of poppler's IDCT method which in turn is taken from:\n    //   Christoph Loeffler, Adriaan Ligtenberg, George S. Moschytz,\n    //   \"Practical Fast 1-D DCT Algorithms with 11 Multiplications\",\n    //   IEEE Intl. Conf. on Acoustics, Speech & Signal Processing, 1989,\n    //   988-991.\n    function quantizeAndInverse(zz, dataOut, dataIn) {\n        const qt = component.quantizationTable;\n        let v0;\n        let v1;\n        let v2;\n        let v3;\n        let v4;\n        let v5;\n        let v6;\n        let v7;\n        let t;\n        const p = dataIn;\n        let i;\n        // dequant\n        for (i = 0; i < 64; i++) {\n            p[i] = zz[i] * qt[i];\n        }\n        // inverse DCT on rows\n        for (i = 0; i < 8; ++i) {\n            const row = 8 * i;\n            // check for all-zero AC coefficients\n            if (p[1 + row] === 0 && p[2 + row] === 0 && p[3 + row] === 0\n                && p[4 + row] === 0 && p[5 + row] === 0 && p[6 + row] === 0\n                && p[7 + row] === 0) {\n                t = ((dctSqrt2 * p[0 + row]) + 512) >> 10;\n                p[0 + row] = t;\n                p[1 + row] = t;\n                p[2 + row] = t;\n                p[3 + row] = t;\n                p[4 + row] = t;\n                p[5 + row] = t;\n                p[6 + row] = t;\n                p[7 + row] = t;\n                continue; // eslint-disable-line no-continue\n            }\n            // stage 4\n            v0 = ((dctSqrt2 * p[0 + row]) + 128) >> 8;\n            v1 = ((dctSqrt2 * p[4 + row]) + 128) >> 8;\n            v2 = p[2 + row];\n            v3 = p[6 + row];\n            v4 = ((dctSqrt1d2 * (p[1 + row] - p[7 + row])) + 128) >> 8;\n            v7 = ((dctSqrt1d2 * (p[1 + row] + p[7 + row])) + 128) >> 8;\n            v5 = p[3 + row] << 4;\n            v6 = p[5 + row] << 4;\n            // stage 3\n            t = (v0 - v1 + 1) >> 1;\n            v0 = (v0 + v1 + 1) >> 1;\n            v1 = t;\n            t = ((v2 * dctSin6) + (v3 * dctCos6) + 128) >> 8;\n            v2 = ((v2 * dctCos6) - (v3 * dctSin6) + 128) >> 8;\n            v3 = t;\n            t = (v4 - v6 + 1) >> 1;\n            v4 = (v4 + v6 + 1) >> 1;\n            v6 = t;\n            t = (v7 + v5 + 1) >> 1;\n            v5 = (v7 - v5 + 1) >> 1;\n            v7 = t;\n            // stage 2\n            t = (v0 - v3 + 1) >> 1;\n            v0 = (v0 + v3 + 1) >> 1;\n            v3 = t;\n            t = (v1 - v2 + 1) >> 1;\n            v1 = (v1 + v2 + 1) >> 1;\n            v2 = t;\n            t = ((v4 * dctSin3) + (v7 * dctCos3) + 2048) >> 12;\n            v4 = ((v4 * dctCos3) - (v7 * dctSin3) + 2048) >> 12;\n            v7 = t;\n            t = ((v5 * dctSin1) + (v6 * dctCos1) + 2048) >> 12;\n            v5 = ((v5 * dctCos1) - (v6 * dctSin1) + 2048) >> 12;\n            v6 = t;\n            // stage 1\n            p[0 + row] = v0 + v7;\n            p[7 + row] = v0 - v7;\n            p[1 + row] = v1 + v6;\n            p[6 + row] = v1 - v6;\n            p[2 + row] = v2 + v5;\n            p[5 + row] = v2 - v5;\n            p[3 + row] = v3 + v4;\n            p[4 + row] = v3 - v4;\n        }\n        // inverse DCT on columns\n        for (i = 0; i < 8; ++i) {\n            const col = i;\n            // check for all-zero AC coefficients\n            if (p[(1 * 8) + col] === 0 && p[(2 * 8) + col] === 0 && p[(3 * 8) + col] === 0\n                && p[(4 * 8) + col] === 0 && p[(5 * 8) + col] === 0 && p[(6 * 8) + col] === 0\n                && p[(7 * 8) + col] === 0) {\n                t = ((dctSqrt2 * dataIn[i + 0]) + 8192) >> 14;\n                p[(0 * 8) + col] = t;\n                p[(1 * 8) + col] = t;\n                p[(2 * 8) + col] = t;\n                p[(3 * 8) + col] = t;\n                p[(4 * 8) + col] = t;\n                p[(5 * 8) + col] = t;\n                p[(6 * 8) + col] = t;\n                p[(7 * 8) + col] = t;\n                continue; // eslint-disable-line no-continue\n            }\n            // stage 4\n            v0 = ((dctSqrt2 * p[(0 * 8) + col]) + 2048) >> 12;\n            v1 = ((dctSqrt2 * p[(4 * 8) + col]) + 2048) >> 12;\n            v2 = p[(2 * 8) + col];\n            v3 = p[(6 * 8) + col];\n            v4 = ((dctSqrt1d2 * (p[(1 * 8) + col] - p[(7 * 8) + col])) + 2048) >> 12;\n            v7 = ((dctSqrt1d2 * (p[(1 * 8) + col] + p[(7 * 8) + col])) + 2048) >> 12;\n            v5 = p[(3 * 8) + col];\n            v6 = p[(5 * 8) + col];\n            // stage 3\n            t = (v0 - v1 + 1) >> 1;\n            v0 = (v0 + v1 + 1) >> 1;\n            v1 = t;\n            t = ((v2 * dctSin6) + (v3 * dctCos6) + 2048) >> 12;\n            v2 = ((v2 * dctCos6) - (v3 * dctSin6) + 2048) >> 12;\n            v3 = t;\n            t = (v4 - v6 + 1) >> 1;\n            v4 = (v4 + v6 + 1) >> 1;\n            v6 = t;\n            t = (v7 + v5 + 1) >> 1;\n            v5 = (v7 - v5 + 1) >> 1;\n            v7 = t;\n            // stage 2\n            t = (v0 - v3 + 1) >> 1;\n            v0 = (v0 + v3 + 1) >> 1;\n            v3 = t;\n            t = (v1 - v2 + 1) >> 1;\n            v1 = (v1 + v2 + 1) >> 1;\n            v2 = t;\n            t = ((v4 * dctSin3) + (v7 * dctCos3) + 2048) >> 12;\n            v4 = ((v4 * dctCos3) - (v7 * dctSin3) + 2048) >> 12;\n            v7 = t;\n            t = ((v5 * dctSin1) + (v6 * dctCos1) + 2048) >> 12;\n            v5 = ((v5 * dctCos1) - (v6 * dctSin1) + 2048) >> 12;\n            v6 = t;\n            // stage 1\n            p[(0 * 8) + col] = v0 + v7;\n            p[(7 * 8) + col] = v0 - v7;\n            p[(1 * 8) + col] = v1 + v6;\n            p[(6 * 8) + col] = v1 - v6;\n            p[(2 * 8) + col] = v2 + v5;\n            p[(5 * 8) + col] = v2 - v5;\n            p[(3 * 8) + col] = v3 + v4;\n            p[(4 * 8) + col] = v3 - v4;\n        }\n        // convert to 8-bit integers\n        for (i = 0; i < 64; ++i) {\n            const sample = 128 + ((p[i] + 8) >> 4);\n            if (sample < 0) {\n                dataOut[i] = 0;\n            }\n            else if (sample > 0XFF) {\n                dataOut[i] = 0xFF;\n            }\n            else {\n                dataOut[i] = sample;\n            }\n        }\n    }\n    for (let blockRow = 0; blockRow < blocksPerColumn; blockRow++) {\n        const scanLine = blockRow << 3;\n        for (let i = 0; i < 8; i++) {\n            lines.push(new Uint8Array(samplesPerLine));\n        }\n        for (let blockCol = 0; blockCol < blocksPerLine; blockCol++) {\n            quantizeAndInverse(component.blocks[blockRow][blockCol], r, R);\n            let offset = 0;\n            const sample = blockCol << 3;\n            for (let j = 0; j < 8; j++) {\n                const line = lines[scanLine + j];\n                for (let i = 0; i < 8; i++) {\n                    line[sample + i] = r[offset++];\n                }\n            }\n        }\n    }\n    return lines;\n}\nclass JpegStreamReader {\n    constructor() {\n        this.jfif = null;\n        this.adobe = null;\n        this.quantizationTables = [];\n        this.huffmanTablesAC = [];\n        this.huffmanTablesDC = [];\n        this.resetFrames();\n    }\n    resetFrames() {\n        this.frames = [];\n    }\n    parse(data) {\n        let offset = 0;\n        // const { length } = data;\n        function readUint16() {\n            const value = (data[offset] << 8) | data[offset + 1];\n            offset += 2;\n            return value;\n        }\n        function readDataBlock() {\n            const length = readUint16();\n            const array = data.subarray(offset, offset + length - 2);\n            offset += array.length;\n            return array;\n        }\n        function prepareComponents(frame) {\n            let maxH = 0;\n            let maxV = 0;\n            let component;\n            let componentId;\n            for (componentId in frame.components) {\n                if (frame.components.hasOwnProperty(componentId)) {\n                    component = frame.components[componentId];\n                    if (maxH < component.h) {\n                        maxH = component.h;\n                    }\n                    if (maxV < component.v) {\n                        maxV = component.v;\n                    }\n                }\n            }\n            const mcusPerLine = Math.ceil(frame.samplesPerLine / 8 / maxH);\n            const mcusPerColumn = Math.ceil(frame.scanLines / 8 / maxV);\n            for (componentId in frame.components) {\n                if (frame.components.hasOwnProperty(componentId)) {\n                    component = frame.components[componentId];\n                    const blocksPerLine = Math.ceil(Math.ceil(frame.samplesPerLine / 8) * component.h / maxH);\n                    const blocksPerColumn = Math.ceil(Math.ceil(frame.scanLines / 8) * component.v / maxV);\n                    const blocksPerLineForMcu = mcusPerLine * component.h;\n                    const blocksPerColumnForMcu = mcusPerColumn * component.v;\n                    const blocks = [];\n                    for (let i = 0; i < blocksPerColumnForMcu; i++) {\n                        const row = [];\n                        for (let j = 0; j < blocksPerLineForMcu; j++) {\n                            row.push(new Int32Array(64));\n                        }\n                        blocks.push(row);\n                    }\n                    component.blocksPerLine = blocksPerLine;\n                    component.blocksPerColumn = blocksPerColumn;\n                    component.blocks = blocks;\n                }\n            }\n            frame.maxH = maxH;\n            frame.maxV = maxV;\n            frame.mcusPerLine = mcusPerLine;\n            frame.mcusPerColumn = mcusPerColumn;\n        }\n        let fileMarker = readUint16();\n        if (fileMarker !== 0xFFD8) { // SOI (Start of Image)\n            throw new Error('SOI not found');\n        }\n        fileMarker = readUint16();\n        while (fileMarker !== 0xFFD9) { // EOI (End of image)\n            switch (fileMarker) {\n                case 0xFF00: break;\n                case 0xFFE0: // APP0 (Application Specific)\n                case 0xFFE1: // APP1\n                case 0xFFE2: // APP2\n                case 0xFFE3: // APP3\n                case 0xFFE4: // APP4\n                case 0xFFE5: // APP5\n                case 0xFFE6: // APP6\n                case 0xFFE7: // APP7\n                case 0xFFE8: // APP8\n                case 0xFFE9: // APP9\n                case 0xFFEA: // APP10\n                case 0xFFEB: // APP11\n                case 0xFFEC: // APP12\n                case 0xFFED: // APP13\n                case 0xFFEE: // APP14\n                case 0xFFEF: // APP15\n                case 0xFFFE: { // COM (Comment)\n                    const appData = readDataBlock();\n                    if (fileMarker === 0xFFE0) {\n                        if (appData[0] === 0x4A && appData[1] === 0x46 && appData[2] === 0x49\n                            && appData[3] === 0x46 && appData[4] === 0) { // 'JFIF\\x00'\n                            this.jfif = {\n                                version: { major: appData[5], minor: appData[6] },\n                                densityUnits: appData[7],\n                                xDensity: (appData[8] << 8) | appData[9],\n                                yDensity: (appData[10] << 8) | appData[11],\n                                thumbWidth: appData[12],\n                                thumbHeight: appData[13],\n                                thumbData: appData.subarray(14, 14 + (3 * appData[12] * appData[13])),\n                            };\n                        }\n                    }\n                    // TODO APP1 - Exif\n                    if (fileMarker === 0xFFEE) {\n                        if (appData[0] === 0x41 && appData[1] === 0x64 && appData[2] === 0x6F\n                            && appData[3] === 0x62 && appData[4] === 0x65 && appData[5] === 0) { // 'Adobe\\x00'\n                            this.adobe = {\n                                version: appData[6],\n                                flags0: (appData[7] << 8) | appData[8],\n                                flags1: (appData[9] << 8) | appData[10],\n                                transformCode: appData[11],\n                            };\n                        }\n                    }\n                    break;\n                }\n                case 0xFFDB: { // DQT (Define Quantization Tables)\n                    const quantizationTablesLength = readUint16();\n                    const quantizationTablesEnd = quantizationTablesLength + offset - 2;\n                    while (offset < quantizationTablesEnd) {\n                        const quantizationTableSpec = data[offset++];\n                        const tableData = new Int32Array(64);\n                        if ((quantizationTableSpec >> 4) === 0) { // 8 bit values\n                            for (let j = 0; j < 64; j++) {\n                                const z = dctZigZag[j];\n                                tableData[z] = data[offset++];\n                            }\n                        }\n                        else if ((quantizationTableSpec >> 4) === 1) { // 16 bit\n                            for (let j = 0; j < 64; j++) {\n                                const z = dctZigZag[j];\n                                tableData[z] = readUint16();\n                            }\n                        }\n                        else {\n                            throw new Error('DQT: invalid table spec');\n                        }\n                        this.quantizationTables[quantizationTableSpec & 15] = tableData;\n                    }\n                    break;\n                }\n                case 0xFFC0: // SOF0 (Start of Frame, Baseline DCT)\n                case 0xFFC1: // SOF1 (Start of Frame, Extended DCT)\n                case 0xFFC2: { // SOF2 (Start of Frame, Progressive DCT)\n                    readUint16(); // skip data length\n                    const frame = {\n                        extended: (fileMarker === 0xFFC1),\n                        progressive: (fileMarker === 0xFFC2),\n                        precision: data[offset++],\n                        scanLines: readUint16(),\n                        samplesPerLine: readUint16(),\n                        components: {},\n                        componentsOrder: [],\n                    };\n                    const componentsCount = data[offset++];\n                    let componentId;\n                    // let maxH = 0;\n                    // let maxV = 0;\n                    for (let i = 0; i < componentsCount; i++) {\n                        componentId = data[offset];\n                        const h = data[offset + 1] >> 4;\n                        const v = data[offset + 1] & 15;\n                        const qId = data[offset + 2];\n                        frame.componentsOrder.push(componentId);\n                        frame.components[componentId] = {\n                            h,\n                            v,\n                            quantizationIdx: qId,\n                        };\n                        offset += 3;\n                    }\n                    prepareComponents(frame);\n                    this.frames.push(frame);\n                    break;\n                }\n                case 0xFFC4: { // DHT (Define Huffman Tables)\n                    const huffmanLength = readUint16();\n                    for (let i = 2; i < huffmanLength;) {\n                        const huffmanTableSpec = data[offset++];\n                        const codeLengths = new Uint8Array(16);\n                        let codeLengthSum = 0;\n                        for (let j = 0; j < 16; j++, offset++) {\n                            codeLengths[j] = data[offset];\n                            codeLengthSum += codeLengths[j];\n                        }\n                        const huffmanValues = new Uint8Array(codeLengthSum);\n                        for (let j = 0; j < codeLengthSum; j++, offset++) {\n                            huffmanValues[j] = data[offset];\n                        }\n                        i += 17 + codeLengthSum;\n                        if ((huffmanTableSpec >> 4) === 0) {\n                            this.huffmanTablesDC[huffmanTableSpec & 15] = buildHuffmanTable(codeLengths, huffmanValues);\n                        }\n                        else {\n                            this.huffmanTablesAC[huffmanTableSpec & 15] = buildHuffmanTable(codeLengths, huffmanValues);\n                        }\n                    }\n                    break;\n                }\n                case 0xFFDD: // DRI (Define Restart Interval)\n                    readUint16(); // skip data length\n                    this.resetInterval = readUint16();\n                    break;\n                case 0xFFDA: { // SOS (Start of Scan)\n                    readUint16(); // skip length\n                    const selectorsCount = data[offset++];\n                    const components = [];\n                    const frame = this.frames[0];\n                    for (let i = 0; i < selectorsCount; i++) {\n                        const component = frame.components[data[offset++]];\n                        const tableSpec = data[offset++];\n                        component.huffmanTableDC = this.huffmanTablesDC[tableSpec >> 4];\n                        component.huffmanTableAC = this.huffmanTablesAC[tableSpec & 15];\n                        components.push(component);\n                    }\n                    const spectralStart = data[offset++];\n                    const spectralEnd = data[offset++];\n                    const successiveApproximation = data[offset++];\n                    const processed = decodeScan(data, offset, frame, components, this.resetInterval, spectralStart, spectralEnd, successiveApproximation >> 4, successiveApproximation & 15);\n                    offset += processed;\n                    break;\n                }\n                case 0xFFFF: // Fill bytes\n                    if (data[offset] !== 0xFF) { // Avoid skipping a valid marker.\n                        offset--;\n                    }\n                    break;\n                default:\n                    if (data[offset - 3] === 0xFF\n                        && data[offset - 2] >= 0xC0 && data[offset - 2] <= 0xFE) {\n                        // could be incorrect encoding -- last 0xFF byte of the previous\n                        // block was eaten by the encoder\n                        offset -= 3;\n                        break;\n                    }\n                    throw new Error(`unknown JPEG marker ${fileMarker.toString(16)}`);\n            }\n            fileMarker = readUint16();\n        }\n    }\n    getResult() {\n        const { frames } = this;\n        if (this.frames.length === 0) {\n            throw new Error('no frames were decoded');\n        }\n        else if (this.frames.length > 1) {\n            console.warn('more than one frame is not supported');\n        }\n        // set each frame's components quantization table\n        for (let i = 0; i < this.frames.length; i++) {\n            const cp = this.frames[i].components;\n            for (const j of Object.keys(cp)) {\n                cp[j].quantizationTable = this.quantizationTables[cp[j].quantizationIdx];\n                delete cp[j].quantizationIdx;\n            }\n        }\n        const frame = frames[0];\n        const { components, componentsOrder } = frame;\n        const outComponents = [];\n        const width = frame.samplesPerLine;\n        const height = frame.scanLines;\n        for (let i = 0; i < componentsOrder.length; i++) {\n            const component = components[componentsOrder[i]];\n            outComponents.push({\n                lines: buildComponentData(frame, component),\n                scaleX: component.h / frame.maxH,\n                scaleY: component.v / frame.maxV,\n            });\n        }\n        const out = new Uint8Array(width * height * outComponents.length);\n        let oi = 0;\n        for (let y = 0; y < height; ++y) {\n            for (let x = 0; x < width; ++x) {\n                for (let i = 0; i < outComponents.length; ++i) {\n                    const component = outComponents[i];\n                    out[oi] = component.lines[0 | y * component.scaleY][0 | x * component.scaleX];\n                    ++oi;\n                }\n            }\n        }\n        return out;\n    }\n}\nexport default class JpegDecoder extends BaseDecoder {\n    constructor(parameters) {\n        super(parameters);\n        this.reader = new JpegStreamReader();\n        if (parameters.JPEGTables) {\n            this.reader.parse(parameters.JPEGTables);\n        }\n    }\n    decodeBlock(buffer) {\n        this.reader.resetFrames();\n        this.reader.parse(new Uint8Array(buffer));\n        return this.reader.getResult().buffer;\n    }\n}\n"],"names":["dctZigZag","dctCos1","dctSin1","dctCos3","dctSin3","dctCos6","dctSin6","dctSqrt2","dctSqrt1d2","buildHuffmanTable","codeLengths","values","k","code","length","p","q","i","j","decodeScan","data","initialOffset","frame","components","resetInterval","spectralStart","spectralEnd","successivePrev","successive","mcusPerLine","progressive","startOffset","offset","bitsData","bitsCount","readBit","nextByte","decodeHuffman","tree","node","bit","receive","initialLength","n","receiveAndExtend","decodeBaseline","component","zz","t","diff","rs","s","r","z","decodeDCFirst","decodeDCSuccessive","eobrun","decodeACFirst","e","successiveACState","successiveACNextValue","decodeACSuccessive","direction","decodeMcu","decodeFunction","mcu","row","col","mcuRow","mcuCol","blockRow","blockCol","decodeBlock","componentsLength","decodeFn","marker","mcuExpected","usedResetInterval","h","v","buildComponentData","lines","blocksPerLine","blocksPerColumn","samplesPerLine","R","quantizeAndInverse","dataOut","dataIn","qt","v0","v1","v2","v3","v4","v5","v6","v7","sample","scanLine","line","JpegStreamReader","readUint16","value","readDataBlock","array","prepareComponents","maxH","maxV","componentId","mcusPerColumn","blocksPerLineForMcu","blocksPerColumnForMcu","blocks","fileMarker","appData","quantizationTablesEnd","quantizationTableSpec","tableData","componentsCount","qId","huffmanLength","huffmanTableSpec","codeLengthSum","huffmanValues","selectorsCount","tableSpec","successiveApproximation","processed","frames","cp","componentsOrder","outComponents","width","height","out","oi","y","x","JpegDecoder","BaseDecoder","parameters","buffer"],"mappings":"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","x_google_ignoreList":[0]}