{"version":3,"file":"webimage-DzzHs4ar.js","sources":["../node_modules/geotiff/dist-module/compression/webimage.js"],"sourcesContent":["import BaseDecoder from './basedecoder.js';\n/**\n * class WebImageDecoder\n *\n * This decoder uses the browsers image decoding facilities to read image\n * formats like WebP when supported.\n */\nexport default class WebImageDecoder extends BaseDecoder {\n    constructor(parameters) {\n        super(parameters);\n        if (typeof createImageBitmap === 'undefined') {\n            throw new Error('Cannot decode WebImage as `createImageBitmap` is not available');\n        }\n        else if (typeof document === 'undefined' && typeof OffscreenCanvas === 'undefined') {\n            throw new Error('Cannot decode WebImage as neither `document` nor `OffscreenCanvas` is not available');\n        }\n    }\n    async decodeBlock(buffer) {\n        const blob = new Blob([buffer]);\n        const imageBitmap = await createImageBitmap(blob);\n        let canvas;\n        if (typeof document !== 'undefined') {\n            canvas = document.createElement('canvas');\n            canvas.width = imageBitmap.width;\n            canvas.height = imageBitmap.height;\n        }\n        else {\n            canvas = new OffscreenCanvas(imageBitmap.width, imageBitmap.height);\n        }\n        // Draw the image onto the canvas to extract the pixel data.\n        // Note: createImageBitmap always returns RGBA data.\n        const ctx = canvas.getContext('2d');\n        ctx.drawImage(imageBitmap, 0, 0);\n        const imageData = ctx.getImageData(0, 0, imageBitmap.width, imageBitmap.height).data;\n        // Return the correct channels to the caller\n        const samplesPerPixel = this.parameters.samplesPerPixel || 4;\n        if (samplesPerPixel === 4) {\n            // RGBA, return as is\n            return imageData.buffer;\n        }\n        else if (samplesPerPixel === 3) {\n            // RGB, remove alpha channel before returning\n            const rgb = new Uint8ClampedArray(imageBitmap.width * imageBitmap.height * 3);\n            for (let i = 0, j = 0; i < rgb.length; i += 3, j += 4) {\n                rgb[i] = imageData[j];\n                rgb[i + 1] = imageData[j + 1];\n                rgb[i + 2] = imageData[j + 2];\n            }\n            return rgb.buffer;\n        }\n        else {\n            throw new Error(`Unsupported SamplesPerPixel value: ${samplesPerPixel}`);\n        }\n    }\n}\n"],"names":["WebImageDecoder","BaseDecoder","parameters","buffer","blob","imageBitmap","canvas","ctx","imageData","samplesPerPixel","rgb","i","j"],"mappings":";AAOe,MAAMA,UAAwBC,EAAY;AAAA,EACrD,YAAYC,GAAY;AAEpB,QADA,MAAMA,CAAU,GACZ,OAAO,oBAAsB;AAC7B,YAAM,IAAI,MAAM,gEAAgE;AAE/E,QAAI,OAAO,WAAa,OAAe,OAAO,kBAAoB;AACnE,YAAM,IAAI,MAAM,qFAAqF;AAAA,EAE7G;AAAA,EACA,MAAM,YAAYC,GAAQ;AACtB,UAAMC,IAAO,IAAI,KAAK,CAACD,CAAM,CAAC,GACxBE,IAAc,MAAM,kBAAkBD,CAAI;AAChD,QAAIE;AACJ,IAAI,OAAO,WAAa,OACpBA,IAAS,SAAS,cAAc,QAAQ,GACxCA,EAAO,QAAQD,EAAY,OAC3BC,EAAO,SAASD,EAAY,UAG5BC,IAAS,IAAI,gBAAgBD,EAAY,OAAOA,EAAY,MAAM;AAItE,UAAME,IAAMD,EAAO,WAAW,IAAI;AAClC,IAAAC,EAAI,UAAUF,GAAa,GAAG,CAAC;AAC/B,UAAMG,IAAYD,EAAI,aAAa,GAAG,GAAGF,EAAY,OAAOA,EAAY,MAAM,EAAE,MAE1EI,IAAkB,KAAK,WAAW,mBAAmB;AAC3D,QAAIA,MAAoB;AAEpB,aAAOD,EAAU;AAEhB,QAAIC,MAAoB,GAAG;AAE5B,YAAMC,IAAM,IAAI,kBAAkBL,EAAY,QAAQA,EAAY,SAAS,CAAC;AAC5E,eAASM,IAAI,GAAGC,IAAI,GAAGD,IAAID,EAAI,QAAQC,KAAK,GAAGC,KAAK;AAChD,QAAAF,EAAIC,CAAC,IAAIH,EAAUI,CAAC,GACpBF,EAAIC,IAAI,CAAC,IAAIH,EAAUI,IAAI,CAAC,GAC5BF,EAAIC,IAAI,CAAC,IAAIH,EAAUI,IAAI,CAAC;AAEhC,aAAOF,EAAI;AAAA,IACf;AAEI,YAAM,IAAI,MAAM,sCAAsCD,CAAe,EAAE;AAAA,EAE/E;AACJ;","x_google_ignoreList":[0]}